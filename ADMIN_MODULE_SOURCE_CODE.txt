========================================
PROSTOCK - ADMIN MODULE SOURCE CODE
Generated: 11/12/2025 11:10:36
========================================

MODULE DESCRIPTION:
This module contains all administrator functionality including:
- Admin Dashboard & Screen
- User Management
- Activity Monitoring & Logs
- System Settings
- Backup & Restore
- Security & Authentication
- Role-based Access Control

========================================


================================================================
FILE #1: D:\flutter project\prostock\lib\screens\admin\activity_screen.dart
SIZE: 3.32 KB
MODIFIED: 10/04/2025 04:57:01
================================================================

import 'package:flutter/material.dart';
import 'package:prostock/screens/admin/system_monitoring_screen.dart';
import 'package:provider/provider.dart';
import 'package:prostock/providers/auth_provider.dart';
import 'package:prostock/services/firestore/activity_service.dart';
import 'package:prostock/models/user_activity.dart';
import 'package:prostock/models/app_user.dart';
import 'package:prostock/models/user_role.dart';
import 'package:prostock/widgets/sync_status_indicator.dart';

class ActivityScreen extends StatelessWidget {
  const ActivityScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 4,
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Activity & Monitoring'),
          actions: const [SyncStatusIndicator()],
          bottom: const TabBar(
            tabs: [
              Tab(text: 'Activity'),
              Tab(text: 'Status'),
              Tab(text: 'Pending'),
              Tab(text: 'Failures'),
            ],
          ),
        ),
        body: const TabBarView(
          children: [
            UserActivityList(),
            SyncStatusWidget(),
            PendingOperationsWidget(),
            SyncFailuresWidget(),
          ],
        ),
      ),
    );
  }
}

class UserActivityList extends StatefulWidget {
  const UserActivityList({super.key});

  @override
  State<UserActivityList> createState() => _UserActivityListState();
}

class _UserActivityListState extends State<UserActivityList> {
  late Stream<List<UserActivity>> _activityStream;
  Map<String, AppUser> _usersMap = {};
  final AppUser _unknownUser = AppUser(
    id: '',
    username: 'Unknown',
    email: '',
    passwordHash: '',
    role: UserRole.user,
    createdAt: DateTime.now(),
  );

  @override
  void initState() {
    super.initState();
    _activityStream = context
        .read<ActivityService>()
        .getAllUserActivitiesStream();
    _fetchUsers();
  }

  Future<void> _fetchUsers() async {
    final users = await context.read<AuthProvider>().getAllUsersList();
    if (mounted) {
      setState(() {
        _usersMap = {for (var user in users) user.id!: user};
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<List<UserActivity>>(
      stream: _activityStream,
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting ||
            _usersMap.isEmpty) {
          return const Center(child: CircularProgressIndicator());
        }
        if (snapshot.hasError) {
          return Center(child: Text('Error: ${snapshot.error}'));
        }
        if (!snapshot.hasData || snapshot.data!.isEmpty) {
          return const Center(child: Text('No activities found.'));
        }

        final activities = snapshot.data!;

        return ListView.builder(
          itemCount: activities.length,
          itemBuilder: (context, index) {
            final activity = activities[index];
            final username =
                _usersMap[activity.userId]?.username ?? _unknownUser.username;
            return ListTile(
              title: Text('${activity.action} by $username'),
              subtitle: Text(activity.details ?? ''),
              trailing: Text('${activity.timestamp.toLocal()}'.split(' ')[0]),
            );
          },
        );
      },
    );
  }
}




================================================================
FILE #2: D:\flutter project\prostock\lib\screens\admin\admin_screen.dart
SIZE: 9.78 KB
MODIFIED: 10/02/2025 15:42:18
================================================================

import 'package:flutter/material.dart';
import 'package:prostock/screens/admin/activity_screen.dart';
import 'package:prostock/screens/settings/settings_screen.dart';
import 'package:provider/provider.dart';
import '../../providers/auth_provider.dart';
import '../pos/pos_screen.dart';
import '../inventory/inventory_screen.dart';
import '../report_tabs/reports_screen.dart';
import '../customers/customers_screen.dart';
import '../../services/offline_manager.dart';

class AdminScreen extends StatefulWidget {
  const AdminScreen({super.key});

  @override
  State<AdminScreen> createState() => _AdminScreenState();
}

class _AdminScreenState extends State<AdminScreen>
    with TickerProviderStateMixin {
  int _selectedIndex = 0;
  late List<AnimationController> _animationControllers;
  late List<Animation<double>> _scaleAnimations;

  final List<Widget> _screens = [
    const ActivityScreen(),
    const POSScreen(),
    const InventoryScreen(),
    const CustomersScreen(),
    const ReportsScreen(),
  ];

  final List<IconData> _icons = [
    Icons.admin_panel_settings,
    Icons.point_of_sale,
    Icons.inventory,
    Icons.people,
    Icons.assessment,
  ];

  final List<String> _labels = [
    'Activity & Monitoring',
    'POS',
    'Items',
    'Clients',
    'Reports',
  ];

  @override
  void initState() {
    super.initState();
    _animationControllers = List.generate(
      _screens.length,
      (index) => AnimationController(
        duration: const Duration(milliseconds: 200),
        vsync: this,
      ),
    );

    _scaleAnimations = _animationControllers.map((controller) {
      return Tween<double>(
        begin: 1.0,
        end: 0.95,
      ).animate(CurvedAnimation(parent: controller, curve: Curves.easeInOut));
    }).toList();
  }

  @override
  void dispose() {
    for (var controller in _animationControllers) {
      controller.dispose();
    }
    super.dispose();
  }

  void _onNavTap(int index) async {
    if (index == _selectedIndex) return;

    // Animate the pressed button
    await _animationControllers[index].forward();
    await _animationControllers[index].reverse();

    setState(() => _selectedIndex = index);
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = context.watch<AuthProvider>();

    return Scaffold(
      backgroundColor: Colors.grey[50],
      appBar: AppBar(
        title: Text('Admin - ${authProvider.username}'),
        backgroundColor: Colors.indigo[600],
        foregroundColor: Colors.white,
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.delete_forever),
            onPressed: () async {
              await context.read<OfflineManager>().clearCache();
              if (!context.mounted) return;
              ScaffoldMessenger.of(
                context,
              ).showSnackBar(const SnackBar(content: Text('Cache cleared')));
            },
          ),
          IconButton(
            icon: const Icon(Icons.settings),
            onPressed: () {
              Navigator.of(context).push(
                MaterialPageRoute(builder: (context) => const SettingsScreen()),
              );
            },
          ),
        ],
      ),
      body: AnimatedSwitcher(
        duration: const Duration(milliseconds: 250),
        transitionBuilder: (Widget child, Animation<double> animation) {
          return SlideTransition(
            position:
                Tween<Offset>(
                  begin: const Offset(0.3, 0.0),
                  end: Offset.zero,
                ).animate(
                  CurvedAnimation(
                    parent: animation,
                    curve: Curves.easeInOutCubic,
                  ),
                ),
            child: FadeTransition(opacity: animation, child: child),
          );
        },
        child: Container(
          key: ValueKey(_selectedIndex),
          child: _screens[_selectedIndex],
        ),
      ),
      bottomNavigationBar: Container(
        decoration: BoxDecoration(
          color: Theme.of(context).colorScheme.surface,
          boxShadow: [
            BoxShadow(
              color: Theme.of(context).colorScheme.shadow.withAlpha(26),
              blurRadius: 10,
              offset: const Offset(0, -2),
            ),
          ],
        ),
        child: SafeArea(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: List.generate(_screens.length, (index) {
                final isSelected = index == _selectedIndex;
                return Expanded(
                  child: AnimatedBuilder(
                    animation: _scaleAnimations[index],
                    builder: (context, child) {
                      return Transform.scale(
                        scale: _scaleAnimations[index].value,
                        child: Material(
                          color: Colors.transparent,
                          child: InkWell(
                            borderRadius: BorderRadius.circular(12),
                            splashColor: Theme.of(
                              context,
                            ).colorScheme.primary.withAlpha(77),
                            highlightColor: Theme.of(
                              context,
                            ).colorScheme.primary.withAlpha(26),
                            onTap: () => _onNavTap(index),
                            child: AnimatedContainer(
                              duration: const Duration(milliseconds: 100),
                              curve: Curves.easeInOutCubic,
                              padding: const EdgeInsets.symmetric(
                                vertical: 8.0,
                                horizontal: 12.0,
                              ),
                              decoration: BoxDecoration(
                                borderRadius: BorderRadius.circular(12),
                                color: isSelected
                                    ? Theme.of(context).colorScheme.primary
                                          .withValues(alpha: .1)
                                    : Colors.transparent,
                              ),
                              child: Column(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  AnimatedContainer(
                                    duration: const Duration(milliseconds: 100),
                                    curve: Curves.easeInOutCubic,
                                    padding: const EdgeInsets.all(4),
                                    decoration: BoxDecoration(
                                      borderRadius: BorderRadius.circular(8),
                                      color: isSelected
                                          ? Theme.of(
                                              context,
                                            ).colorScheme.primary
                                          : Colors.transparent,
                                    ),
                                    child: AnimatedScale(
                                      scale: isSelected ? 1.1 : 1.0,
                                      duration: const Duration(
                                        milliseconds: 100,
                                      ),
                                      curve: Curves.easeInOutBack,
                                      child: Icon(
                                        _icons[index],
                                        color: isSelected
                                            ? Theme.of(
                                                context,
                                              ).colorScheme.onPrimary
                                            : Theme.of(
                                                context,
                                              ).colorScheme.onSurfaceVariant,
                                        size: 24,
                                      ),
                                    ),
                                  ),
                                  const SizedBox(height: 4),
                                  AnimatedDefaultTextStyle(
                                    duration: const Duration(milliseconds: 100),
                                    curve: Curves.easeInOutCubic,
                                    style: TextStyle(
                                      fontSize: isSelected ? 11 : 10,
                                      fontWeight: isSelected
                                          ? FontWeight.w600
                                          : FontWeight.w500,
                                      color: isSelected
                                          ? Theme.of(
                                              context,
                                            ).colorScheme.primary
                                          : Theme.of(
                                              context,
                                            ).colorScheme.onSurfaceVariant,
                                    ),
                                    child: Text(
                                      _labels[index],
                                      textAlign: TextAlign.center,
                                      overflow: TextOverflow.ellipsis,
                                      maxLines: 1,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ),
                        ),
                      );
                    },
                  ),
                );
              }),
            ),
          ),
        ),
      ),
    );
  }
}




================================================================
FILE #3: D:\flutter project\prostock\lib\screens\admin\system_monitoring_screen.dart
SIZE: 3.6 KB
MODIFIED: 09/15/2025 23:04:40
================================================================

import 'package:flutter/material.dart';
import 'package:prostock/services/offline_manager.dart';
import 'package:provider/provider.dart';
import 'package:prostock/providers/sync_failure_provider.dart';

class SystemMonitoringScreen extends StatelessWidget {
  const SystemMonitoringScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 3,
      child: Scaffold(
        appBar: AppBar(
          title: const Text('System Monitoring'),
          bottom: const TabBar(
            tabs: [
              Tab(text: 'Status'),
              Tab(text: 'Pending'),
              Tab(text: 'Failures'),
            ],
          ),
        ),
        body: const TabBarView(
          children: [
            SyncStatusWidget(),
            PendingOperationsWidget(),
            SyncFailuresWidget(),
          ],
        ),
      ),
    );
  }
}

class SyncStatusWidget extends StatelessWidget {
  const SyncStatusWidget({super.key});

  @override
  Widget build(BuildContext context) {
    final offlineManager = Provider.of<OfflineManager>(context);

    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('Sync Status', style: Theme.of(context).textTheme.headlineSmall),
          const SizedBox(height: 16),
          ListTile(
            title: const Text('Connectivity'),
            trailing: Text(offlineManager.isOnline ? 'Online' : 'Offline'),
          ),
          ListTile(
            title: const Text('Syncing'),
            trailing: Text(offlineManager.isSyncing ? 'In Progress' : 'Idle'),
          ),
          ListTile(
            title: const Text('Last Sync Time'),
            trailing: Text(
              offlineManager.lastSyncTime?.toLocal().toString() ?? 'Never',
            ),
          ),
          ListTile(
            title: const Text('Pending Operations'),
            trailing: Text(offlineManager.pendingOperationsCount.toString()),
          ),
        ],
      ),
    );
  }
}

class PendingOperationsWidget extends StatelessWidget {
  const PendingOperationsWidget({super.key});

  @override
  Widget build(BuildContext context) {
    final offlineManager = Provider.of<OfflineManager>(context);
    final pendingOperations = offlineManager.pendingOperations;

    if (pendingOperations.isEmpty) {
      return const Center(child: Text('No pending operations.'));
    }

    return ListView.builder(
      itemCount: pendingOperations.length,
      itemBuilder: (context, index) {
        final operation = pendingOperations[index];
        return ListTile(
          title: Text(operation.type.toString().split('.').last),
          subtitle: Text('ID: ${operation.id}'),
          trailing: Text('Retries: ${operation.retryCount}'),
        );
      },
    );
  }
}

class SyncFailuresWidget extends StatelessWidget {
  const SyncFailuresWidget({super.key});

  @override
  Widget build(BuildContext context) {
    final syncFailureProvider = Provider.of<SyncFailureProvider>(context);
    final failures = syncFailureProvider.failures;

    if (failures.isEmpty) {
      return const Center(child: Text('No sync failures.'));
    }

    return ListView.builder(
      itemCount: failures.length,
      itemBuilder: (context, index) {
        final failure = failures[index];
        return ListTile(
          title: Text(failure.operation.type.toString().split('.').last),
          subtitle: Text(failure.error),
          trailing: Text(
            failure.operation.timestamp.toLocal().toString().split(' ')[0],
          ),
        );
      },
    );
  }
}




================================================================
FILE #4: D:\flutter project\prostock\lib\screens\admin\components\stat_card.dart
SIZE: 1.25 KB
MODIFIED: 10/04/2025 06:10:33
================================================================

import 'package:flutter/material.dart';

class StatCard extends StatelessWidget {
  final String title;
  final String value;
  final IconData icon;
  final Color color;

  const StatCard({
    super.key,
    required this.title,
    required this.value,
    required this.icon,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface.withAlpha(51),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        children: [
          Icon(icon, color: Theme.of(context).colorScheme.onSurface, size: 24),
          const SizedBox(height: 8),
          Text(
            value,
            style: TextStyle(
              color: Theme.of(context).colorScheme.onSurface,
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
          Text(
            title,
            style: TextStyle(
              color: Theme.of(
                context,
              ).colorScheme.onSurface.withValues(alpha: 0.7),
              fontSize: 12,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
}




================================================================
FILE #5: D:\flutter project\prostock\lib\screens\settings\settings_screen.dart
SIZE: 5.41 KB
MODIFIED: 10/04/2025 05:03:47
================================================================

import 'package:prostock/widgets/sync_failure_dialog.dart';
import 'package:prostock/providers/sync_failure_provider.dart';
import 'package:flutter/material.dart';
import 'package:prostock/providers/theme_provider.dart';
import 'package:prostock/screens/settings/components/about_screen.dart';
import 'package:prostock/screens/settings/components/user_management_screen.dart';
import 'package:provider/provider.dart';
import '../../providers/auth_provider.dart';
import 'components/change_password_screen.dart';
import 'components/printer_settings_screen.dart';
import 'components/tax_rules_screen.dart';

class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Settings')),
      body: ListView(
        children: [
          ListTile(
            leading: const Icon(Icons.palette_outlined),
            title: const Text('Appearance'),
            onTap: () {
              _showThemeDialog(context);
            },
          ),
          ListTile(
            leading: const Icon(Icons.lock_outline),
            title: const Text('Change Password'),
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => const ChangePasswordScreen(),
                ),
              );
            },
          ),
          ListTile(
            leading: const Icon(Icons.print_outlined),
            title: const Text('Printer Settings'),
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => const PrinterSettingsScreen(),
                ),
              );
            },
          ),
          ListTile(
            leading: const Icon(Icons.rule),
            title: const Text('Markup Rules'),
            subtitle: const Text('Category & product-specific markups'),
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(builder: (context) => const TaxRulesScreen()),
              );
            },
          ),
          ListTile(
            leading: const Icon(Icons.people_outline),
            title: const Text('User Management'),
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => const UserManagementScreen(),
                ),
              );
            },
          ),
          const Divider(),
          Consumer<SyncFailureProvider>(
            builder: (context, syncFailureProvider, child) {
              return ListTile(
                leading: Badge(
                  isLabelVisible: syncFailureProvider.failures.isNotEmpty,
                  label: Text(syncFailureProvider.failures.length.toString()),
                  child: const Icon(Icons.sync_problem_outlined),
                ),
                title: const Text('Sync Failures'),
                onTap: () {
                  showDialog(
                    context: context,
                    builder: (context) => const SyncFailureDialog(),
                  );
                },
              );
            },
          ),
          const Divider(),
          ListTile(
            leading: const Icon(Icons.info_outline),
            title: const Text('About'),
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(builder: (context) => const AboutScreen()),
              );
            },
          ),
          const Divider(),
          ListTile(
            leading: const Icon(Icons.logout),
            title: const Text('Logout'),
            onTap: () async {
              final authProvider = context.read<AuthProvider>();
              await authProvider.logout();
              if (context.mounted) {
                Navigator.of(
                  context,
                ).pushNamedAndRemoveUntil('/login', (route) => false);
              }
            },
          ),
        ],
      ),
    );
  }

  void _showThemeDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) {
        return SimpleDialog(
          title: const Text('Select Theme'),
          children: [
            SimpleDialogOption(
              onPressed: () {
                Provider.of<ThemeProvider>(
                  context,
                  listen: false,
                ).setThemeMode(ThemeMode.light);
                Navigator.of(context).pop();
              },
              child: const Text('Light'),
            ),
            SimpleDialogOption(
              onPressed: () {
                Provider.of<ThemeProvider>(
                  context,
                  listen: false,
                ).setThemeMode(ThemeMode.dark);
                Navigator.of(context).pop();
              },
              child: const Text('Dark'),
            ),
            SimpleDialogOption(
              onPressed: () {
                Provider.of<ThemeProvider>(
                  context,
                  listen: false,
                ).setThemeMode(ThemeMode.system);
                Navigator.of(context).pop();
              },
              child: const Text('System Default'),
            ),
          ],
        );
      },
    );
  }
}




================================================================
FILE #6: D:\flutter project\prostock\lib\screens\settings\components\about_screen.dart
SIZE: 1.15 KB
MODIFIED: 09/10/2025 11:01:43
================================================================

import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart';

class AboutScreen extends StatelessWidget {
  const AboutScreen({super.key});

  Future<void> _launchURL(String url) async {
    final Uri uri = Uri.parse(url);
    if (!await launchUrl(uri)) {
      throw 'Could not launch $url';
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('About'),
      ),
      body: ListView(
        children: [
          ListTile(
            title: const Text('App Version'),
            subtitle: const Text('1.0.0+1'), // Hardcoded for now
          ),
          const Divider(),
          ListTile(
            title: const Text('Help & Support'),
            onTap: () => _launchURL('https://your-support-page.com'),
          ),
          ListTile(
            title: const Text('Privacy Policy'),
            onTap: () => _launchURL('https://your-privacy-policy.com'),
          ),
          ListTile(
            title: const Text('Terms of Service'),
            onTap: () => _launchURL('https://your-terms-of-service.com'),
          ),
        ],
      ),
    );
  }
}




================================================================
FILE #7: D:\flutter project\prostock\lib\screens\settings\components\app_update_widget.dart
SIZE: 1.54 KB
MODIFIED: 09/12/2025 20:25:29
================================================================

import 'package:flutter/material.dart';

class AppUpdateWidget extends StatelessWidget {
  const AppUpdateWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'App Updates',
          style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 10),
        Card(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Maintenance Announcement',
                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 10),
                const Text(
                  'The app will be down for maintenance on Sunday at 2:00 AM for approximately 2 hours.',
                ),
                const SizedBox(height: 10),
                ElevatedButton(
                  onPressed: () {
                    // In a real app, this would trigger an update check.
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                        content: Text('No new updates available.'),
                      ),
                    );
                  },
                  child: const Text('Check for Updates'),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }
}




================================================================
FILE #8: D:\flutter project\prostock\lib\screens\settings\components\change_password_screen.dart
SIZE: 17.48 KB
MODIFIED: 10/03/2025 07:37:38
================================================================

import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../../utils/password_helper.dart';
import '../../../widgets/enhanced_text_field.dart';
import '../../../widgets/password_strength_checklist.dart';

class ChangePasswordScreen extends StatefulWidget {
  const ChangePasswordScreen({super.key});

  @override
  State<ChangePasswordScreen> createState() => _ChangePasswordScreenState();
}

class _ChangePasswordScreenState extends State<ChangePasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final _currentPasswordController = TextEditingController();
  final _newPasswordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();

  bool _isLoading = false;
  String? _error;
  String _newPassword = '';
  String _confirmPassword = '';
  bool _showNewPasswordChecklist = false;
  bool _showConfirmPasswordValidation = false;
  bool _isFormValid = false;

  @override
  void initState() {
    super.initState();
    _newPasswordController.addListener(_onNewPasswordChanged);
    _confirmPasswordController.addListener(_onConfirmPasswordChanged);
  }

  @override
  void dispose() {
    _currentPasswordController.dispose();
    _newPasswordController.removeListener(_onNewPasswordChanged);
    _newPasswordController.dispose();
    _confirmPasswordController.removeListener(_onConfirmPasswordChanged);
    _confirmPasswordController.dispose();
    super.dispose();
  }

  void _onNewPasswordChanged() {
    setState(() {
      _newPassword = _newPasswordController.text;
      _showNewPasswordChecklist = _newPassword.isNotEmpty;
    });
    _validateForm();
  }

  void _onConfirmPasswordChanged() {
    setState(() {
      _confirmPassword = _confirmPasswordController.text;
      _showConfirmPasswordValidation = _confirmPassword.isNotEmpty;
    });
    _validateForm();
  }

  void _validateForm() {
    final isCurrentPasswordValid = _currentPasswordController.text.isNotEmpty;
    final isNewPasswordValid =
        PasswordHelper.isPasswordStrong(_newPassword) &&
        _newPassword != _currentPasswordController.text;
    final isConfirmPasswordValid = _confirmPassword == _newPassword;

    setState(() {
      _isFormValid =
          isCurrentPasswordValid &&
          isNewPasswordValid &&
          isConfirmPasswordValid;
    });
  }

  void _clearError() {
    if (_error != null) {
      setState(() {
        _error = null;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Change Password'),
        backgroundColor: Theme.of(context).colorScheme.surface,
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Card(
                elevation: 2,
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Icon(
                            Icons.security,
                            color: Theme.of(context).colorScheme.primary,
                            size: 24,
                          ),
                          const SizedBox(width: 8),
                          Text(
                            'Password Security',
                            style: TextStyle(
                              fontSize: 18,
                              fontWeight: FontWeight.bold,
                              color: Theme.of(context).colorScheme.primary,
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 8),
                      Text(
                        'Change your account password to keep your account secure. Follow the password guidelines below.',
                        style: TextStyle(
                          color: Theme.of(context).colorScheme.onSurfaceVariant,
                          fontSize: 14,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 24),

              // Current Password Field
              Text(
                'Current Password',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                  color: Theme.of(context).colorScheme.onSurface,
                ),
              ),
              const SizedBox(height: 8),
              EnhancedTextField(
                controller: _currentPasswordController,
                labelText: 'Enter current password',
                prefixIcon: Icons.lock,
                isPassword: true,
                showValidationIcon: false,
                onChanged: (value) {
                  _clearError();
                  _validateForm();
                },
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Current password is required';
                  }
                  return null;
                },
                keyboardType: TextInputType.visiblePassword,
              ),
              const SizedBox(height: 24),

              // New Password Section
              Text(
                'New Password',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                  color: Theme.of(context).colorScheme.onSurface,
                ),
              ),
              const SizedBox(height: 8),
              EnhancedTextField(
                controller: _newPasswordController,
                labelText: 'Create a new secure password',
                prefixIcon: Icons.lock_outline,
                isPassword: true,
                showValidationIcon: false,
                onChanged: (value) {
                  _clearError();
                  _onNewPasswordChanged();
                },
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'New password is required';
                  }
                  if (value.length < 8) {
                    return 'Password must be at least 8 characters long';
                  }
                  if (!PasswordHelper.isPasswordStrong(value)) {
                    return 'Password does not meet security requirements';
                  }
                  if (value == _currentPasswordController.text) {
                    return 'New password must be different from current password';
                  }
                  return null;
                },
                keyboardType: TextInputType.visiblePassword,
              ),

              // Password Strength Checklist
              if (_showNewPasswordChecklist) ...[
                const SizedBox(height: 8),
                PasswordStrengthChecklist(
                  password: _newPassword,
                  isVisible: true,
                ),
              ],
              const SizedBox(height: 24),

              // Confirm Password Section
              Text(
                'Confirm New Password',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                  color: Theme.of(context).colorScheme.onSurface,
                ),
              ),
              const SizedBox(height: 8),
              EnhancedTextField(
                controller: _confirmPasswordController,
                labelText: 'Re-enter your new password',
                prefixIcon: Icons.lock_outline,
                isPassword: true,
                showValidationIcon: false,
                onChanged: (value) {
                  _clearError();
                  _onConfirmPasswordChanged();
                },
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please confirm your new password';
                  }
                  if (value != _newPasswordController.text) {
                    return 'Passwords do not match';
                  }
                  return null;
                },
                keyboardType: TextInputType.visiblePassword,
              ),

              // Confirm Password Validation
              if (_showConfirmPasswordValidation) ...[
                const SizedBox(height: 8),
                AnimatedContainer(
                  duration: const Duration(milliseconds: 200),
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: _confirmPassword == _newPassword
                        ? Colors.green.withValues(alpha: 0.1)
                        : Colors.red.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(
                      color: _confirmPassword == _newPassword
                          ? Colors.green.withValues(alpha: 0.3)
                          : Colors.red.withValues(alpha: 0.3),
                    ),
                  ),
                  child: Row(
                    children: [
                      Icon(
                        _confirmPassword == _newPassword
                            ? Icons.check_circle
                            : Icons.error,
                        size: 16,
                        color: _confirmPassword == _newPassword
                            ? Colors.green
                            : Colors.red,
                      ),
                      const SizedBox(width: 8),
                      Text(
                        _confirmPassword == _newPassword
                            ? 'Passwords match'
                            : 'Passwords do not match',
                        style: TextStyle(
                          fontSize: 12,
                          color: _confirmPassword == _newPassword
                              ? Colors.green
                              : Colors.red,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                ),
              ],

              const SizedBox(height: 24),

              // Error Display
              if (_error != null) ...[
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.red.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(
                      color: Colors.red.withValues(alpha: 0.3),
                    ),
                  ),
                  child: Row(
                    children: [
                      const Icon(Icons.error, color: Colors.red, size: 20),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          _error!,
                          style: const TextStyle(color: Colors.red),
                        ),
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 16),
              ],

              // Submit Button
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: _isLoading || !_isFormValid
                      ? null
                      : _changePassword,
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    backgroundColor: _isFormValid
                        ? Theme.of(context).colorScheme.primary
                        : Colors.grey,
                    foregroundColor: _isFormValid
                        ? Theme.of(context).colorScheme.onPrimary
                        : Colors.white54,
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(8),
                    ),
                  ),
                  child: _isLoading
                      ? const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            color: Colors.white,
                          ),
                        )
                      : const Text(
                          'Change Password',
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                ),
              ),

              const SizedBox(height: 16),

              // Info Card
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Theme.of(
                    context,
                  ).colorScheme.primary.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(
                    color: Theme.of(
                      context,
                    ).colorScheme.primary.withValues(alpha: 0.3),
                  ),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.info,
                      color: Theme.of(context).colorScheme.primary,
                      size: 20,
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        'After changing your password, you may need to log in again with your new password on other devices.',
                        style: TextStyle(
                          color: Theme.of(
                            context,
                          ).colorScheme.onPrimaryContainer,
                          fontSize: 12,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _changePassword() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) {
        setState(() {
          _error = 'No user is currently signed in. Please log in again.';
          _isLoading = false;
        });
        return;
      }

      // Re-authenticate user with current password
      final credential = EmailAuthProvider.credential(
        email: user.email!,
        password: _currentPasswordController.text,
      );

      await user.reauthenticateWithCredential(credential);

      // Update password
      await user.updatePassword(_newPasswordController.text);

      if (mounted) {
        // Show success message
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Row(
              children: [
                Icon(Icons.check_circle, color: Colors.white),
                SizedBox(width: 8),
                Text('Password changed successfully!'),
              ],
            ),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(8),
            ),
          ),
        );

        // Clear form
        _currentPasswordController.clear();
        _newPasswordController.clear();
        _confirmPasswordController.clear();
        setState(() {
          _newPassword = '';
          _confirmPassword = '';
          _showNewPasswordChecklist = false;
          _showConfirmPasswordValidation = false;
          _isFormValid = false;
        });

        // Navigate back
        Navigator.of(context).pop();
      }
    } on FirebaseAuthException catch (e) {
      String errorMessage;
      switch (e.code) {
        case 'wrong-password':
          errorMessage =
              'The current password you entered is incorrect. Please check your password and try again.';
          break;
        case 'weak-password':
          errorMessage =
              'The new password you entered is too weak. Please use a stronger password.';
          break;
        case 'requires-recent-login':
          errorMessage =
              'For security reasons, please log out and log in again before changing your password.';
          break;
        case 'network-request-failed':
          errorMessage =
              'Network error occurred. Please check your internet connection and try again.';
          break;
        case 'too-many-requests':
          errorMessage =
              'Too many failed attempts. Please wait a moment and try again.';
          break;
        default:
          errorMessage =
              'Failed to change password. Please try again or contact support if the problem persists.';
      }

      if (mounted) {
        setState(() {
          _error = errorMessage;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _error =
              'An unexpected error occurred. Please check your connection and try again.';
          _isLoading = false;
        });
      }
    }
  }
}




================================================================
FILE #9: D:\flutter project\prostock\lib\screens\settings\components\create_user_dialog.dart
SIZE: 8.29 KB
MODIFIED: 09/28/2025 12:02:57
================================================================

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/models/user_role.dart';
import 'package:prostock/providers/auth_provider.dart';

class CreateUserDialog extends StatefulWidget {
  const CreateUserDialog({super.key});

  @override
  State<CreateUserDialog> createState() => _CreateUserDialogState();
}

class _CreateUserDialogState extends State<CreateUserDialog> {
  final _formKey = GlobalKey<FormState>();
  final _usernameController = TextEditingController();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();

  UserRole _selectedRole = UserRole.user;
  bool _isLoading = false;
  bool _obscurePassword = true;
  bool _obscureConfirmPassword = true;

  @override
  void dispose() {
    _usernameController.dispose();
    _emailController.dispose();
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Create New User'),
      content: SingleChildScrollView(
        child: Form(
          key: _formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextFormField(
                controller: _usernameController,
                decoration: const InputDecoration(
                  labelText: 'Username',
                  prefixIcon: Icon(Icons.person),
                  border: OutlineInputBorder(),
                ),
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Username is required';
                  }
                  if (value.trim().length < 3) {
                    return 'Username must be at least 3 characters';
                  }
                  return null;
                },
                textInputAction: TextInputAction.next,
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _emailController,
                decoration: const InputDecoration(
                  labelText: 'Email',
                  prefixIcon: Icon(Icons.email),
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.emailAddress,
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Email is required';
                  }
                  if (!RegExp(
                    r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                  ).hasMatch(value.trim())) {
                    return 'Please enter a valid email';
                  }
                  return null;
                },
                textInputAction: TextInputAction.next,
              ),
              const SizedBox(height: 16),
              DropdownButtonFormField<UserRole>(
                initialValue: _selectedRole,
                decoration: const InputDecoration(
                  labelText: 'Role',
                  prefixIcon: Icon(Icons.admin_panel_settings),
                  border: OutlineInputBorder(),
                ),
                onChanged: (UserRole? newValue) {
                  if (newValue != null) {
                    setState(() {
                      _selectedRole = newValue;
                    });
                  }
                },
                items: UserRole.values.map((UserRole role) {
                  return DropdownMenuItem<UserRole>(
                    value: role,
                    child: Text(role.displayName),
                  );
                }).toList(),
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _passwordController,
                decoration: InputDecoration(
                  labelText: 'Password',
                  prefixIcon: const Icon(Icons.lock),
                  border: const OutlineInputBorder(),
                  suffixIcon: IconButton(
                    icon: Icon(
                      _obscurePassword
                          ? Icons.visibility
                          : Icons.visibility_off,
                    ),
                    onPressed: () {
                      setState(() {
                        _obscurePassword = !_obscurePassword;
                      });
                    },
                  ),
                ),
                obscureText: _obscurePassword,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Password is required';
                  }
                  if (value.length < 6) {
                    return 'Password must be at least 6 characters';
                  }
                  return null;
                },
                textInputAction: TextInputAction.next,
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _confirmPasswordController,
                decoration: InputDecoration(
                  labelText: 'Confirm Password',
                  prefixIcon: const Icon(Icons.lock_outline),
                  border: const OutlineInputBorder(),
                  suffixIcon: IconButton(
                    icon: Icon(
                      _obscureConfirmPassword
                          ? Icons.visibility
                          : Icons.visibility_off,
                    ),
                    onPressed: () {
                      setState(() {
                        _obscureConfirmPassword = !_obscureConfirmPassword;
                      });
                    },
                  ),
                ),
                obscureText: _obscureConfirmPassword,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please confirm password';
                  }
                  if (value != _passwordController.text) {
                    return 'Passwords do not match';
                  }
                  return null;
                },
                textInputAction: TextInputAction.done,
                onFieldSubmitted: (_) => _createUser(),
              ),
            ],
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        ElevatedButton(
          onPressed: _isLoading ? null : _createUser,
          child: _isLoading
              ? const SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : const Text('Create User'),
        ),
      ],
    );
  }

  Future<void> _createUser() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    setState(() {
      _isLoading = true;
    });

    try {
      final authProvider = context.read<AuthProvider>();
      final success = await authProvider.createUser(
        _usernameController.text.trim(),
        _emailController.text.trim(),
        _passwordController.text,
        _selectedRole,
      );

      if (mounted) {
        Navigator.of(context).pop();

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              success
                  ? 'User created successfully! Verification email sent to ${_emailController.text.trim()}'
                  : 'Failed to create user: ${authProvider.error ?? 'Unknown error'}',
            ),
            backgroundColor: success ? Colors.green : Colors.red,
            duration: const Duration(seconds: 5),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error creating user: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }
}




================================================================
FILE #10: D:\flutter project\prostock\lib\screens\settings\components\notification_test_screen.dart
SIZE: 5.37 KB
MODIFIED: 10/04/2025 06:16:59
================================================================

import 'package:flutter/material.dart';
import 'package:prostock/utils/notification_tester.dart';

class NotificationTestScreen extends StatefulWidget {
  const NotificationTestScreen({super.key});

  @override
  State<NotificationTestScreen> createState() => _NotificationTestScreenState();
}

class _NotificationTestScreenState extends State<NotificationTestScreen> {
  bool _isLoading = false;

  Future<void> _runTest(
    String testName,
    Future<void> Function() testFunction,
  ) async {
    setState(() {
      _isLoading = true;
    });

    try {
      await testFunction();
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('$testName completed! Check your notifications.'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('$testName failed: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Test Notifications')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Text(
              'Test Notification System',
              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            const Text(
              'Use these buttons to test if notifications are working properly. You should receive push notifications like text messages.',
              style: TextStyle(fontSize: 16, color: Colors.grey),
            ),
            const SizedBox(height: 32),

            ElevatedButton.icon(
              onPressed: _isLoading
                  ? null
                  : () => _runTest(
                      'Direct Notification Test',
                      NotificationTester.testDirectNotifications,
                    ),
              icon: const Icon(Icons.notifications_active),
              label: const Text('Test Direct Notifications'),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.all(16),
              ),
            ),

            const SizedBox(height: 16),

            ElevatedButton.icon(
              onPressed: _isLoading
                  ? null
                  : () => _runTest(
                      'Customer Payment Check',
                      NotificationTester.testCustomerPaymentNotifications,
                    ),
              icon: const Icon(Icons.payment),
              label: const Text('Test Customer Payment Notifications'),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.all(16),
              ),
            ),

            const SizedBox(height: 16),

            ElevatedButton.icon(
              onPressed: _isLoading
                  ? null
                  : () => _runTest(
                      'Scheduled Notification Test',
                      NotificationTester.testScheduledNotification,
                    ),
              icon: const Icon(Icons.schedule),
              label: const Text('Test Scheduled Notification (10s delay)'),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.all(16),
              ),
            ),

            const SizedBox(height: 32),

            if (_isLoading) const Center(child: CircularProgressIndicator()),

            const Expanded(child: SizedBox()),

            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Colors.blue.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.blue.withValues(alpha: 0.3)),
              ),
              child: const Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'How to Test:',
                    style: TextStyle(fontWeight: FontWeight.bold),
                  ),
                  SizedBox(height: 8),
                  Text(
                    '1. Tap "Test Direct Notifications" - you should get 4 test notifications immediately',
                  ),
                  Text(
                    '2. Tap "Test Customer Payment Notifications" - checks your actual sales data',
                  ),
                  Text(
                    '3. Tap "Test Scheduled Notification" - you\'ll get a notification in 10 seconds',
                  ),
                  SizedBox(height: 8),
                  Text(
                    'If you don\'t receive notifications, check your device\'s notification permissions for ProStock.',
                    style: TextStyle(
                      fontStyle: FontStyle.italic,
                      color: Colors.orange,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}




================================================================
FILE #11: D:\flutter project\prostock\lib\screens\settings\components\printer_settings_screen.dart
SIZE: 15.17 KB
MODIFIED: 09/10/2025 11:40:22
================================================================

import 'package:esc_pos_utils_plus/esc_pos_utils_plus.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:provider/provider.dart';
import 'package:prostock/models/bluetooth_device.dart';
import 'package:prostock/services/printing_service.dart';

class PrinterSettingsScreen extends StatefulWidget {
  const PrinterSettingsScreen({super.key});

  @override
  State<PrinterSettingsScreen> createState() => _PrinterSettingsScreenState();
}

class _PrinterSettingsScreenState extends State<PrinterSettingsScreen> {
  late PrintingService _printingService;
  List<BluetoothDevice> _devices = [];
  bool _isLoading = false;
  bool _isConnecting = false;
  String? _defaultPrinterAddress;

  @override
  void initState() {
    super.initState();
    _printingService = Provider.of<PrintingService>(context, listen: false);
    _printingService.loadPaperSize();
    _loadDefaultPrinterAndScan();
  }

  Future<void> _loadDefaultPrinterAndScan() async {
    _defaultPrinterAddress = await _printingService.loadDefaultPrinter();
    if (mounted && _defaultPrinterAddress != null) {
      setState(() {});
      // Non-blocking call to attempt auto-reconnect
      _attemptAutoReconnect();
    }
    // Initial scan is now non-blocking
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        _scanForPrinters();
      }
    });
  }

  Future<void> _attemptAutoReconnect() async {
    if (_defaultPrinterAddress == null || _printingService.isConnected) return;

    await _scanForPrinters();

    BluetoothDevice? defaultDevice;

    for (final device in _devices) {
      if (device.address == _defaultPrinterAddress) {
        defaultDevice = device;
        break;
      }
    }

    if (defaultDevice != null) {
      await _selectPrinter(defaultDevice, showMessages: false);
    }
  }

  Future<void> _scanForPrinters() async {
    if (await _requestPermissions()) {
      setState(() => _isLoading = true);
      try {
        final devices = await _printingService.getBluetooths();
        if (kDebugMode) {
          print('Raw devices found: $devices');
        }
        setState(() {
          _devices = devices;
        });
      } catch (e) {
        if (kDebugMode) {
          print('Error scanning for printers: $e');
        }
        if (!mounted) return;
        _showSnackBar('Error scanning for printers: $e', isError: true);
      }
      setState(() => _isLoading = false);
    } else {
      _showSnackBar('Bluetooth permissions are required to scan for printers.',
          isError: true);
    }
  }

  Future<bool> _requestPermissions() async {
    var status = await Permission.bluetoothScan.status;
    if (status.isDenied) {
      await Permission.bluetoothScan.request();
    }
    status = await Permission.bluetoothConnect.status;
    if (status.isDenied) {
      await Permission.bluetoothConnect.request();
    }
    return await Permission.bluetoothScan.isGranted &&
        await Permission.bluetoothConnect.isGranted;
  }

  Future<void> _selectPrinter(
    BluetoothDevice device, {
    bool showMessages = true,
  }) async {
    if (_isConnecting) return;

    setState(() => _isConnecting = true);

    try {
      final bool connected = await _printingService.connect(device);
      if (connected && showMessages) {
        _showSnackBar('Connected to ${device.name}');
      } else if (!connected && showMessages) {
        _showSnackBar('Failed to connect to ${device.name}', isError: true);
      }
    } catch (e) {
      if (showMessages) {
        _showSnackBar('Error connecting: $e', isError: true);
      }
    } finally {
      setState(() => _isConnecting = false);
    }
  }

  void _showSnackBar(String message, {bool isError = false}) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: isError ? Colors.red : null,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<PrintingService>(
      builder: (context, printingService, child) {
        return Scaffold(
          appBar: AppBar(
            title: const Text('Printer Settings'),
            actions: [
              if (_isLoading)
                const Padding(
                  padding: EdgeInsets.only(right: 16.0),
                  child: Center(
                    child: SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(color: Colors.white),
                    ),
                  ),
                )
              else
                IconButton(
                  icon: const Icon(Icons.refresh),
                  onPressed: _scanForPrinters,
                  tooltip: 'Scan for Printers',
                ),
            ],
          ),
          body: Column(
            children: [
              _buildConnectedDeviceSection(printingService),
              const Divider(),
              const Padding(
                padding: EdgeInsets.all(16.0),
                child: Text(
                  'Available Devices',
                  style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                ),
              ),
              Expanded(
                child: _devices.isEmpty
                    ? Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            const Icon(
                              Icons.bluetooth_searching,
                              size: 64,
                              color: Colors.grey,
                            ),
                            const SizedBox(height: 16),
                            const Text('No devices found.'),
                            const SizedBox(height: 8),
                            ElevatedButton.icon(
                              onPressed: _scanForPrinters,
                              icon: const Icon(Icons.refresh),
                              label: const Text('Scan for Printers'),
                            ),
                          ],
                        ),
                      )
                    : ListView.builder(
                        itemCount: _devices.length,
                        itemBuilder: (context, index) {
                          final device = _devices[index];
                          final isConnected =
                              printingService.connectedDeviceAddress ==
                              device.address;
                          final isDefault =
                              _defaultPrinterAddress == device.address;

                          return Card(
                            margin: const EdgeInsets.symmetric(
                              horizontal: 16,
                              vertical: 4,
                            ),
                            child: ListTile(
                              leading: Icon(
                                Icons.bluetooth,
                                color: isConnected ? Colors.green : null,
                              ),
                              title: Row(
                                children: [
                                  Expanded(child: Text(device.name)),
                                  if (isDefault)
                                    const Icon(
                                      Icons.star,
                                      size: 16,
                                      color: Colors.orange,
                                    ),
                                ],
                              ),
                              subtitle: Text(
                                device.address.isEmpty
                                    ? 'No Address'
                                    : device.address,
                              ),
                              onTap: _isConnecting
                                  ? null
                                  : () => _selectPrinter(device),
                              trailing:
                                  _isConnecting &&
                                      device.address ==
                                          printingService.connectedDeviceAddress
                                  ? const SizedBox(
                                      width: 20,
                                      height: 20,
                                      child: CircularProgressIndicator(),
                                    )
                                  : isConnected
                                  ? const Icon(
                                      Icons.check_circle,
                                      color: Colors.green,
                                    )
                                  : null,
                            ),
                          );
                        },
                      ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildConnectedDeviceSection(PrintingService printingService) {
    final isConnected = printingService.isConnected;
    final address = printingService.connectedDeviceAddress;

    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Status',
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          if (isConnected && address != null) ...[
            Card(
              elevation: 2,
              color: Colors.green.withAlpha(26),
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  children: [
                    Row(
                      children: [
                        const Icon(
                          Icons.bluetooth_connected,
                          color: Colors.green,
                          size: 32,
                        ),
                        const SizedBox(width: 16),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                printingService.connectedDeviceName ??
                                    'Connected Printer',
                                style: const TextStyle(
                                  fontWeight: FontWeight.bold,
                                  fontSize: 16,
                                ),
                              ),
                              const SizedBox(height: 4),
                              Text(
                                address,
                                style: TextStyle(
                                  color: Colors.grey[600],
                                  fontSize: 12,
                                ),
                              ),
                              const SizedBox(height: 4),
                              Container(
                                padding: const EdgeInsets.symmetric(
                                  horizontal: 8,
                                  vertical: 2,
                                ),
                                decoration: BoxDecoration(
                                  color: Colors.green,
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                child: const Text(
                                  'Connected',
                                  style: TextStyle(
                                    color: Colors.white,
                                    fontSize: 10,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        OutlinedButton.icon(
                          onPressed: printingService.printTest,
                          icon: const Icon(Icons.print),
                          label: const Text('Test Print'),
                        ),
                        const SizedBox(width: 8),
                        ElevatedButton.icon(
                          onPressed: printingService.disconnect,
                          icon: const Icon(Icons.bluetooth_disabled),
                          label: const Text('Disconnect'),
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.red,
                            foregroundColor: Colors.white,
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ] else ...[
            Card(
              elevation: 2,
              color: Colors.grey.withAlpha(26),
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Row(
                  children: [
                    Icon(
                      Icons.bluetooth_disabled,
                      color: Colors.grey[600],
                      size: 32,
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          const Text(
                            'No printer connected',
                            style: TextStyle(
                              fontWeight: FontWeight.bold,
                              fontSize: 16,
                            ),
                          ),
                          const SizedBox(height: 4),
                          Text(
                            'Scan for devices and tap to connect',
                            style: TextStyle(
                              color: Colors.grey[600],
                              fontSize: 12,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
          const SizedBox(height: 16),
          Row(
            children: [
              const Text('Paper Size:'),
              const SizedBox(width: 16),
              DropdownButton<PaperSize>(
                value: printingService.paperSize,
                items: const [
                  DropdownMenuItem(value: PaperSize.mm58, child: Text('58 mm')),
                  DropdownMenuItem(value: PaperSize.mm80, child: Text('80 mm')),
                ],
                onChanged: (value) {
                  if (value != null) {
                    printingService.savePaperSize(value);
                  }
                },
              ),
            ],
          ),
        ],
      ),
    );
  }
}




================================================================
FILE #12: D:\flutter project\prostock\lib\screens\settings\components\system_monitoring_widget.dart
SIZE: 1.92 KB
MODIFIED: 09/12/2025 20:21:25
================================================================

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/models/user_activity.dart';
import 'package:prostock/services/firestore/activity_service.dart';

class SystemMonitoringWidget extends StatelessWidget {
  const SystemMonitoringWidget({super.key});

  @override
  Widget build(BuildContext context) {
    final activityService = Provider.of<ActivityService>(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'System Monitoring',
          style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 10),
        const Text('Recent User Activity:'),
        SizedBox(
          height: 200,
          child: StreamBuilder<List<UserActivity>>(
            stream: activityService.getAllUserActivitiesStream(),
            builder: (context, snapshot) {
              if (snapshot.connectionState == ConnectionState.waiting) {
                return const Center(child: CircularProgressIndicator());
              }
              if (snapshot.hasError) {
                return Center(child: Text('Error: \${snapshot.error}'));
              }
              if (!snapshot.hasData || snapshot.data!.isEmpty) {
                return const Center(child: Text('No recent activity.'));
              }

              final activities = snapshot.data!;

              return ListView.builder(
                itemCount: activities.length,
                itemBuilder: (context, index) {
                  final activity = activities[index];
                  return ListTile(
                    title: Text('\${activity.action} by \${activity.userId}'),
                    subtitle: Text(activity.details ?? ''),
                    trailing: Text(activity.timestamp.toString()),
                  );
                },
              );
            },
          ),
        ),
      ],
    );
  }
}




================================================================
FILE #13: D:\flutter project\prostock\lib\screens\settings\components\tax_history_dialog.dart
SIZE: 9.73 KB
MODIFIED: 09/28/2025 19:53:22
================================================================

import 'package:flutter/material.dart';
import 'package:prostock/services/tax_history_service.dart';
import 'package:prostock/models/tax_settings_history.dart';

class TaxHistoryDialog extends StatefulWidget {
  const TaxHistoryDialog({super.key});

  @override
  State<TaxHistoryDialog> createState() => _TaxHistoryDialogState();
}

class _TaxHistoryDialogState extends State<TaxHistoryDialog> {
  List<TaxSettingsHistory> _history = [];
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadHistory();
  }

  Future<void> _loadHistory() async {
    try {
      final history = await TaxHistoryService.getRecentHistory();
      if (mounted) {
        setState(() {
          _history = history;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('Failed to load history: $e')));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      child: Container(
        width: MediaQuery.of(context).size.width * 0.9,
        height: MediaQuery.of(context).size.height * 0.8,
        padding: const EdgeInsets.all(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: Text(
                    'Markup Settings History',
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                IconButton(
                  onPressed: () => Navigator.of(context).pop(),
                  icon: const Icon(Icons.close, size: 20),
                  padding: EdgeInsets.zero,
                  constraints: const BoxConstraints(
                    minWidth: 32,
                    minHeight: 32,
                  ),
                ),
              ],
            ),
            const Divider(),
            Expanded(
              child: _isLoading
                  ? const Center(child: CircularProgressIndicator())
                  : _history.isEmpty
                  ? const Center(
                      child: Text(
                        'No markup history available',
                        style: TextStyle(fontSize: 16, color: Colors.grey),
                      ),
                    )
                  : ListView.builder(
                      itemCount: _history.length,
                      itemBuilder: (context, index) {
                        final entry = _history[index];
                        return Card(
                          margin: const EdgeInsets.only(bottom: 6),
                          child: Padding(
                            padding: const EdgeInsets.all(8),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Row(
                                  children: [
                                    CircleAvatar(
                                      backgroundColor: _getSourceColor(
                                        entry.source,
                                      ),
                                      radius: 14,
                                      child: Icon(
                                        _getSourceIcon(entry.source),
                                        color: Colors.white,
                                        size: 14,
                                      ),
                                    ),
                                    const SizedBox(width: 8),
                                    Expanded(
                                      child: Text(
                                        entry.changeDescription,
                                        style: const TextStyle(
                                          fontWeight: FontWeight.w500,
                                          fontSize: 13,
                                        ),
                                        maxLines: 2,
                                        overflow: TextOverflow.ellipsis,
                                      ),
                                    ),
                                    const SizedBox(width: 4),
                                    Container(
                                      padding: const EdgeInsets.symmetric(
                                        horizontal: 6,
                                        vertical: 2,
                                      ),
                                      decoration: BoxDecoration(
                                        color: _getSourceColor(entry.source),
                                        borderRadius: BorderRadius.circular(8),
                                      ),
                                      child: Text(
                                        entry.source
                                            .replaceAll('_', ' ')
                                            .toUpperCase(),
                                        style: const TextStyle(
                                          fontSize: 9,
                                          color: Colors.white,
                                          fontWeight: FontWeight.bold,
                                        ),
                                      ),
                                    ),
                                  ],
                                ),
                                const SizedBox(height: 4),
                                Text(
                                  'By: ${entry.changedByUserName}',
                                  style: TextStyle(
                                    fontSize: 12,
                                    color: Colors.grey[600],
                                  ),
                                ),
                                Text(
                                  _formatDateTime(entry.timestamp),
                                  style: const TextStyle(
                                    fontSize: 11,
                                    color: Colors.grey,
                                  ),
                                ),
                              ],
                            ),
                          ),
                        );
                      },
                    ),
            ),
            if (_history.isNotEmpty)
              Padding(
                padding: const EdgeInsets.only(top: 8),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      'Showing ${_history.length} changes',
                      style: TextStyle(fontSize: 11, color: Colors.grey[600]),
                    ),
                    TextButton(
                      onPressed: () async {
                        final confirmed = await showDialog<bool>(
                          context: context,
                          builder: (context) => AlertDialog(
                            title: const Text('Clear History'),
                            content: const Text(
                              'Are you sure you want to clear all tax settings history? This action cannot be undone.',
                            ),
                            actions: [
                              TextButton(
                                onPressed: () =>
                                    Navigator.of(context).pop(false),
                                child: const Text('Cancel'),
                              ),
                              TextButton(
                                onPressed: () =>
                                    Navigator.of(context).pop(true),
                                child: const Text('Clear'),
                              ),
                            ],
                          ),
                        );

                        if (confirmed == true) {
                          await TaxHistoryService.clearHistory();
                          _loadHistory();
                        }
                      },
                      child: const Text('Clear'),
                    ),
                  ],
                ),
              ),
          ],
        ),
      ),
    );
  }

  Color _getSourceColor(String source) {
    switch (source) {
      case 'settings_screen':
        return Colors.blue;
      case 'admin':
        return Colors.red;
      case 'api':
        return Colors.green;
      default:
        return Colors.grey;
    }
  }

  IconData _getSourceIcon(String source) {
    switch (source) {
      case 'settings_screen':
        return Icons.settings;
      case 'admin':
        return Icons.admin_panel_settings;
      case 'api':
        return Icons.api;
      default:
        return Icons.edit;
    }
  }

  String _formatDateTime(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inDays > 0) {
      return '${difference.inDays} day${difference.inDays == 1 ? '' : 's'} ago';
    } else if (difference.inHours > 0) {
      return '${difference.inHours} hour${difference.inHours == 1 ? '' : 's'} ago';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes} minute${difference.inMinutes == 1 ? '' : 's'} ago';
    } else {
      return 'Just now';
    }
  }
}




================================================================
FILE #14: D:\flutter project\prostock\lib\screens\settings\components\tax_rules_screen.dart
SIZE: 29.42 KB
MODIFIED: 10/26/2025 13:07:10
================================================================

import 'package:flutter/material.dart';
import 'package:prostock/services/tax_service.dart';
import 'package:prostock/models/tax_rule.dart';
import 'package:prostock/models/product.dart';
import 'package:prostock/providers/inventory_provider.dart';
import 'package:prostock/utils/constants.dart';
import 'package:provider/provider.dart';

class TaxRulesScreen extends StatefulWidget {
  const TaxRulesScreen({super.key});

  @override
  State<TaxRulesScreen> createState() => _TaxRulesScreenState();
}

class _TaxRulesScreenState extends State<TaxRulesScreen> {
  List<TaxRule> _rules = [];
  bool _isLoading = true;
  String? _error;

  @override
  void initState() {
    super.initState();
    _loadRules();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // Reload when dependencies change to ensure we have latest product data
    _loadRules();
  }

  // Map to cache product names by ID
  final Map<String, String> _productNames = {};

  Future<void> _loadRules() async {
    setState(() => _isLoading = true);
    try {
      final rules = await TaxService.getAllTaxRules();

      // Load product names for product-specific rules
      final productIds = rules
          .where((rule) => rule.isProduct && rule.productId != null)
          .map((rule) => rule.productId!)
          .toSet()
          .toList();

      if (productIds.isNotEmpty && mounted) {
        final inventoryProvider = context.read<InventoryProvider>();
        for (final productId in productIds) {
          final product = inventoryProvider.getProductById(productId);
          if (product != null) {
            _productNames[productId] = product.name;
          }
        }
      }

      if (mounted) {
        setState(() {
          _rules = rules;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _error = 'Failed to load tax rules: $e';
          _isLoading = false;
        });
      }
    }
  }

  Future<void> _addRule() async {
    final result = await showDialog<TaxRule>(
      context: context,
      builder: (context) => const AddTaxRuleDialog(),
    );

    if (result != null) {
      // Check for conflicts using the service method
      final conflictRule = await TaxService.checkForConflicts(result);

      if (conflictRule != null) {
        // Determine the scope for the confirmation dialog
        String scope = 'Rule';
        if (result.isGlobal) {
          scope = 'Global';
        } else if (result.isCategory) {
          scope = 'Category (${result.categoryName})';
        } else if (result.isProduct) {
          scope = 'Product';
        }

        if (!mounted) return;
        final confirmed = await showDialog<bool>(
          context: context,
          builder: (context) => AlertDialog(
            title: Text('Replace $scope Rule'),
            content: Text(
              'A $scope markup rule already exists with tubo amount ₱${conflictRule.tubo.toStringAsFixed(2)}.\n\n'
              'Do you want to replace it with the new rule (₱${result.tubo.toStringAsFixed(2)})?',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(false),
                child: const Text('Cancel'),
              ),
              TextButton(
                onPressed: () => Navigator.of(context).pop(true),
                child: const Text('Replace'),
              ),
            ],
          ),
        );

        if (confirmed != true) {
          return; // User cancelled
        }
      }

      final success = await TaxService.addTaxRule(result);
      if (success) {
        _loadRules();
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                result.isGlobal
                    ? 'Global rule replaced successfully!'
                    : result.isCategory
                    ? 'Category rule replaced successfully!'
                    : result.isProduct
                    ? 'Product rule replaced successfully!'
                    : 'Tax rule added successfully!',
              ),
              backgroundColor: Colors.green,
            ),
          );
        }
      } else {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to add tax rule'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    }
  }

  Future<void> _editRule(TaxRule rule) async {
    final result = await showDialog<TaxRule>(
      context: context,
      builder: (context) => AddTaxRuleDialog(rule: rule),
    );

    if (result != null) {
      // Show confirmation dialog for updating rule
      if (!mounted) return;
      final confirmed = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Update Markup Rule'),
          content: Text(
            'Are you sure you want to update this markup rule?\n\n'
            'Current: ${rule.description} (₱${rule.tubo.toStringAsFixed(2)})\n'
            'New: ${result.description} (₱${result.tubo.toStringAsFixed(2)})\n\n'
            'This will affect pricing for all products using this rule.',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: const Text('Update'),
            ),
          ],
        ),
      );

      if (confirmed == true) {
        final success = await TaxService.updateTaxRule(result);
        if (success) {
          _loadRules();
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Tax rule updated successfully!'),
                backgroundColor: Colors.green,
              ),
            );
          }
        } else {
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Failed to update tax rule'),
                backgroundColor: Colors.red,
              ),
            );
          }
        }
      }
    }
  }

  Future<void> _deleteRule(TaxRule rule) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Markup Rule'),
        content: Text(
          'Are you sure you want to delete this markup rule?\n\n'
          'Rule: ${rule.description}\n'
          'Tubo Amount: ₱${rule.tubo.toStringAsFixed(2)}\n\n'
          'This will affect pricing for all products using this rule. '
          'Products will fall back to the next applicable rule or global settings.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('Delete'),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      final success = await TaxService.deleteTaxRule(rule.id);
      if (success) {
        _loadRules();
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Tax rule deleted successfully!'),
              backgroundColor: Colors.green,
            ),
          );
        }
      } else {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to delete tax rule'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Markup Rules'),
        actions: [
          IconButton(
            onPressed: _loadRules,
            icon: const Icon(Icons.refresh),
            tooltip: 'Refresh',
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _error != null
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.error_outline, size: 64, color: Colors.red[300]),
                  const SizedBox(height: 16),
                  Text(
                    _error!,
                    style: TextStyle(fontSize: 16, color: Colors.red[600]),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: _loadRules,
                    child: const Text('Retry'),
                  ),
                ],
              ),
            )
          : _rules.isEmpty
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.rule, size: 64, color: Colors.grey[400]),
                  const SizedBox(height: 16),
                  Text(
                    'No tax rules configured',
                    style: TextStyle(fontSize: 18, color: Colors.grey[600]),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Add rules for different categories or products',
                    style: TextStyle(fontSize: 14, color: Colors.grey[500]),
                  ),
                ],
              ),
            )
          : ListView.builder(
              padding: const EdgeInsets.all(16),
              itemCount: _rules.length,
              itemBuilder: (context, index) {
                final rule = _rules[index];
                return Card(
                  margin: const EdgeInsets.only(bottom: 8),
                  child: ListTile(
                    leading: CircleAvatar(
                      backgroundColor: _getRuleColor(rule),
                      child: Icon(
                        _getRuleIcon(rule),
                        color: Colors.white,
                        size: 20,
                      ),
                    ),
                    title: Text(
                      _getRuleDisplayName(rule),
                      style: const TextStyle(fontWeight: FontWeight.w500),
                    ),
                    subtitle: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('Tubo: ₱${rule.tubo.toStringAsFixed(2)}'),
                        // Method removed; sari-sari pricing always adds tubo on top
                        Text('Priority: ${rule.priority}'),
                      ],
                    ),
                    trailing: PopupMenuButton(
                      itemBuilder: (context) => [
                        const PopupMenuItem(
                          value: 'edit',
                          child: Row(
                            children: [
                              Icon(Icons.edit),
                              SizedBox(width: 8),
                              Text('Edit'),
                            ],
                          ),
                        ),
                        const PopupMenuItem(
                          value: 'delete',
                          child: Row(
                            children: [
                              Icon(Icons.delete, color: Colors.red),
                              SizedBox(width: 8),
                              Text(
                                'Delete',
                                style: TextStyle(color: Colors.red),
                              ),
                            ],
                          ),
                        ),
                      ],
                      onSelected: (value) {
                        if (value == 'edit') {
                          _editRule(rule);
                        } else if (value == 'delete') {
                          _deleteRule(rule);
                        }
                      },
                    ),
                  ),
                );
              },
            ),
      floatingActionButton: FloatingActionButton(
        onPressed: _addRule,
        child: const Icon(Icons.add),
      ),
    );
  }

  Color _getRuleColor(TaxRule rule) {
    if (rule.isProduct) {
      return Colors.purple;
    } else if (rule.isCategory) {
      return Colors.blue;
    } else {
      return Colors.grey;
    }
  }

  // Get a user-friendly display name for the rule
  String _getRuleDisplayName(TaxRule rule) {
    if (rule.isProduct && rule.productId != null) {
      // Return product name if available, fallback to generic description with ID
      return _productNames.containsKey(rule.productId)
          ? 'Product: ${_productNames[rule.productId]}'
          : 'Product: (Unknown - ID: ${rule.productId})';
    } else if (rule.isCategory && rule.categoryName != null) {
      return 'Category: ${rule.categoryName}';
    } else {
      return 'Global rule';
    }
  }

  IconData _getRuleIcon(TaxRule rule) {
    if (rule.isProduct) {
      return Icons.inventory;
    } else if (rule.isCategory) {
      return Icons.category;
    } else {
      return Icons.settings;
    }
  }
}

class _ProductSearchDialog extends StatefulWidget {
  final List<Product> products;

  const _ProductSearchDialog({required this.products});

  @override
  State<_ProductSearchDialog> createState() => _ProductSearchDialogState();
}

class _ProductSearchDialogState extends State<_ProductSearchDialog> {
  final TextEditingController _searchController = TextEditingController();
  List<Product> _filteredProducts = [];

  @override
  void initState() {
    super.initState();
    _filteredProducts = widget.products;
    _searchController.addListener(_filterProducts);
  }

  void _filterProducts() {
    final query = _searchController.text.toLowerCase();
    setState(() {
      _filteredProducts = widget.products
          .where((product) => product.name.toLowerCase().contains(query))
          .toList();
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      child: Container(
        width: MediaQuery.of(context).size.width * 0.9,
        height: MediaQuery.of(context).size.height * 0.7,
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            Text(
              'Select Product',
              style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _searchController,
              decoration: const InputDecoration(
                labelText: 'Search products...',
                prefixIcon: Icon(Icons.search),
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            Expanded(
              child: _filteredProducts.isEmpty
                  ? const Center(
                      child: Text(
                        'No products found',
                        style: TextStyle(
                          color: Colors.grey,
                          fontStyle: FontStyle.italic,
                        ),
                      ),
                    )
                  : ListView.builder(
                      itemCount: _filteredProducts.length,
                      itemBuilder: (context, index) {
                        final product = _filteredProducts[index];
                        return ListTile(
                          leading: const Icon(Icons.inventory),
                          title: Text(product.name),
                          subtitle: Text('Category: ${product.category}'),
                          onTap: () {
                            Navigator.of(context).pop(product);
                          },
                        );
                      },
                    ),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: const Text('Cancel'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

class AddTaxRuleDialog extends StatefulWidget {
  final TaxRule? rule;

  const AddTaxRuleDialog({super.key, this.rule});

  @override
  State<AddTaxRuleDialog> createState() => _AddTaxRuleDialogState();
}

class _AddTaxRuleDialogState extends State<AddTaxRuleDialog> {
  final _formKey = GlobalKey<FormState>();
  final _tuboController = TextEditingController();
  final _categoryController = TextEditingController();
  final _productController = TextEditingController();

  String _ruleType = 'global'; // 'global', 'category', 'product'
  // Inclusive removed; always add on top.
  bool _isLoading = false;

  // For category dropdown
  String? _selectedCategory;
  List<String> _availableCategories = [];

  @override
  void initState() {
    super.initState();
    _loadCategories();
    _setupProductSearch();

    if (widget.rule != null) {
      _ruleType = widget.rule!.isProduct
          ? 'product'
          : widget.rule!.isCategory
          ? 'category'
          : 'global';
      _tuboController.text = widget.rule!.tubo.toStringAsFixed(2);
      // Ignore any stored inclusive flag; not used anymore.
      _selectedCategory = widget.rule!.categoryName;
      _categoryController.text = widget.rule!.categoryName ?? '';

      // For product rules, look up the product name from the ID
      if (widget.rule!.productId != null) {
        final inventoryProvider = context.read<InventoryProvider>();
        final product = inventoryProvider.getProductById(
          widget.rule!.productId!,
        );
        _productController.text = product?.name ?? 'Unknown Product';
      }
    }
  }

  Future<void> _loadCategories() async {
    try {
      // Only use predefined categories from AppConstants
      final predefinedCategories = AppConstants.productCategories;

      // Sort categories alphabetically
      final sortedCategories = List<String>.from(predefinedCategories)..sort();

      if (mounted) {
        setState(() {
          _availableCategories = sortedCategories;
        });
      }
    } catch (e) {
      // Fallback to empty list if there's an error
      if (mounted) {
        setState(() {
          _availableCategories = [];
        });
      }
    }
  }

  void _setupProductSearch() {
    // No longer needed since we use a separate dialog
  }

  void _showProductSearchDialog() async {
    final inventoryProvider = context.read<InventoryProvider>();

    // Ensure products are loaded
    if (inventoryProvider.products.isEmpty) {
      await inventoryProvider.loadProducts();
    }

    if (!mounted) return;

    final products = inventoryProvider.products;

    final selectedProduct = await showDialog<Product>(
      context: context,
      builder: (context) => _ProductSearchDialog(products: products),
    );

    if (selectedProduct != null) {
      setState(() {
        _productController.text = selectedProduct.name;
      });
    }
  }

  @override
  void dispose() {
    _tuboController.dispose();
    _categoryController.dispose();
    _productController.dispose();
    super.dispose();
  }

  Future<void> _saveRule() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      final tubo = double.parse(_tuboController.text);
      final now = DateTime.now();

      // For product rules, we need to find the product ID from the name
      String? productId;
      if (_ruleType == 'product') {
        try {
          final inventoryProvider = context.read<InventoryProvider>();
          final products = inventoryProvider.products;
          final product = products.firstWhere(
            (p) => p.name == _productController.text.trim(),
            orElse: () => throw StateError('Product not found'),
          );
          productId = product.id;
        } catch (e) {
          // Handle error
        }
      }

      final rule = TaxRule(
        id: widget.rule?.id ?? now.millisecondsSinceEpoch.toString(),
        categoryName: _ruleType == 'category' ? _selectedCategory : null,
        productId: productId,
        tubo: tubo,
        isInclusive: false,
        priority: _getPriority(),
        createdAt: widget.rule?.createdAt ?? now,
        updatedAt: now,
      );

      Navigator.of(context).pop(rule);
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('Error: $e')));
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  int _getPriority() {
    switch (_ruleType) {
      case 'product':
        return 100;
      case 'category':
        return 50;
      default:
        return 0;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      insetPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 24),
      child: ConstrainedBox(
        constraints: BoxConstraints(
          maxWidth: MediaQuery.of(context).size.width * 0.95,
          maxHeight: MediaQuery.of(context).size.height * 0.85,
        ),
        child: Padding(
          padding: EdgeInsets.only(
            left: 16,
            right: 16,
            top: 16,
            bottom: 16 + MediaQuery.of(context).viewInsets.bottom,
          ),
          child: SingleChildScrollView(
            physics: const BouncingScrollPhysics(),
            child: Form(
              key: _formKey,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    widget.rule == null
                        ? 'Add Markup Rule'
                        : 'Edit Markup Rule',
                    style: const TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 16),

                  // Rule Type
                  const Text(
                    'Rule Type',
                    style: TextStyle(fontWeight: FontWeight.w500),
                  ),
                  const SizedBox(height: 8),
                  RadioGroup<String>(
                    groupValue: _ruleType,
                    onChanged: (value) {
                      setState(() {
                        _ruleType = value ?? 'global';
                      });
                    },
                    child: Column(
                      children: [
                        RadioListTile<String>(
                          title: const Text('Global'),
                          subtitle: const Text('Applies to all products'),
                          value: 'global',
                        ),
                        RadioListTile<String>(
                          title: const Text('Category'),
                          subtitle: const Text('Applies to specific category'),
                          value: 'category',
                        ),
                        RadioListTile<String>(
                          title: const Text('Product'),
                          subtitle: const Text('Applies to specific product'),
                          value: 'product',
                        ),
                      ],
                    ),
                  ),

                  const SizedBox(height: 16),

                  // Category/Product fields
                  if (_ruleType == 'category') ...[
                    DropdownButtonFormField<String>(
                      initialValue: _selectedCategory,
                      decoration: const InputDecoration(
                        labelText: 'Select Category',
                        border: OutlineInputBorder(),
                        prefixIcon: Icon(Icons.category),
                      ),
                      items: _availableCategories.map((category) {
                        return DropdownMenuItem<String>(
                          value: category,
                          child: Text(
                            category,
                            overflow: TextOverflow.ellipsis,
                            maxLines: 1,
                          ),
                        );
                      }).toList(),
                      onChanged: (value) {
                        setState(() {
                          _selectedCategory = value;
                          _categoryController.text = value ?? '';
                        });
                      },
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please select a category';
                        }
                        return null;
                      },
                      isExpanded: true,
                    ),
                    const SizedBox(height: 16),
                  ],

                  if (_ruleType == 'product') ...[
                    TextFormField(
                      controller: _productController,
                      decoration: const InputDecoration(
                        labelText: 'Search Product',
                        hintText: 'Type product name...',
                        border: OutlineInputBorder(),
                        prefixIcon: Icon(Icons.search),
                        suffixIcon: Icon(Icons.inventory),
                      ),
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) {
                          return 'Please select a product';
                        }
                        return null;
                      },
                      onTap: () {
                        _showProductSearchDialog();
                      },
                      readOnly: true,
                    ),
                    const SizedBox(height: 16),
                  ],

                  // Tubo Amount
                  TextFormField(
                    controller: _tuboController,
                    decoration: const InputDecoration(
                      labelText: 'Tubo Amount (₱)',
                      border: OutlineInputBorder(),
                      isDense: true,
                      suffixText: '₱',
                    ),
                    keyboardType: TextInputType.numberWithOptions(
                      decimal: true,
                    ),
                    textInputAction: TextInputAction.done,
                    maxLines: 1,
                    expands: false,
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Tubo amount is required';
                      }
                      final amount = double.tryParse(value);
                      if (amount == null || amount < 0) {
                        return 'Tubo amount must be 0 or greater';
                      }
                      return null;
                    },
                  ),

                  const SizedBox(height: 16),

                  // Sari-sari pricing always adds tubo on top; method selector removed
                  const SizedBox(height: 24),

                  // Buttons
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      TextButton(
                        onPressed: _isLoading
                            ? null
                            : () => Navigator.of(context).pop(),
                        child: const Text('Cancel'),
                      ),
                      const SizedBox(width: 8),
                      ElevatedButton(
                        onPressed: _isLoading ? null : _saveRule,
                        child: _isLoading
                            ? const SizedBox(
                                width: 16,
                                height: 16,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                ),
                              )
                            : Text(widget.rule == null ? 'Add' : 'Update'),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}




================================================================
FILE #15: D:\flutter project\prostock\lib\screens\settings\components\tax_settings_screen.dart
SIZE: 18.32 KB
MODIFIED: 09/29/2025 14:38:44
================================================================

import 'package:flutter/material.dart';
import 'package:prostock/services/tax_service.dart';
import 'package:prostock/providers/auth_provider.dart';
import 'package:provider/provider.dart';
import 'tax_history_dialog.dart';

// Deprecated: Use Markup Rules screen instead. This screen is no longer used.
class TaxSettingsScreen extends StatefulWidget {
  const TaxSettingsScreen({super.key});

  @override
  State<TaxSettingsScreen> createState() => _TaxSettingsScreenState();
}

class _TaxSettingsScreenState extends State<TaxSettingsScreen> {
  final _formKey = GlobalKey<FormState>();
  final _tuboAmountController = TextEditingController();

  double _tuboAmount = 2.0; // Default ₱2
  bool _tuboInclusive = true;
  bool _isLoading = false;
  String? _error;

  @override
  void initState() {
    super.initState();
    _loadTaxSettings();
  }

  @override
  void dispose() {
    _tuboAmountController.dispose();
    super.dispose();
  }

  Future<void> _loadTaxSettings() async {
    setState(() => _isLoading = true);

    try {
      // Load tubo settings using TaxService
      _tuboAmount = await TaxService.getTuboAmount();
      _tuboAmountController.text = _tuboAmount.toStringAsFixed(2);

      _tuboInclusive = await TaxService.isTuboInclusive();

      setState(() {});
    } catch (e) {
      setState(() {
        _error = 'Failed to load tubo settings: $e';
      });
    } finally {
      setState(() => _isLoading = false);
    }
  }

  Future<void> _saveTaxSettings() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      final authProvider = context.read<AuthProvider>();
      final currentUser = authProvider.currentUser;

      if (currentUser == null) {
        throw Exception('User not authenticated');
      }

      // Save tubo settings using TaxService with history tracking
      final amountSuccess = await TaxService.setTuboAmount(
        _tuboAmount,
        changedByUserId: currentUser.id ?? 'unknown',
        changedByUserName: currentUser.username,
        source: 'settings_screen',
      );

      final inclusiveSuccess = await TaxService.setTuboInclusive(
        _tuboInclusive,
        changedByUserId: currentUser.id ?? 'unknown',
        changedByUserName: currentUser.username,
        source: 'settings_screen',
      );

      if (amountSuccess && inclusiveSuccess) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Tubo settings saved successfully!'),
              backgroundColor: Colors.green,
            ),
          );
        }
      } else {
        throw Exception('Failed to save one or more settings');
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _error = 'Failed to save tubo settings: $e';
        });
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  void _updateTuboAmount(String value) {
    final amount = double.tryParse(value);
    if (amount != null && amount >= 0) {
      setState(() {
        _tuboAmount = amount;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Markup Settings'),
        actions: [
          IconButton(
            onPressed: () {
              showDialog(
                context: context,
                builder: (context) => const TaxHistoryDialog(),
              );
            },
            icon: const Icon(Icons.history),
            tooltip: 'View History',
          ),
          if (!_isLoading)
            TextButton(
              onPressed: _saveTaxSettings,
              child: const Text('Save', style: TextStyle(color: Colors.white)),
            ),
        ],
      ),
      body: _isLoading && _tuboAmountController.text.isEmpty
          ? const Center(child: CircularProgressIndicator())
          : SingleChildScrollView(
              padding: const EdgeInsets.all(16.0),
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Tubo Amount Section
                    Card(
                      child: Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const Row(
                              children: [
                                Icon(Icons.attach_money, color: Colors.blue),
                                SizedBox(width: 8),
                                Text(
                                  'Tubo Configuration',
                                  style: TextStyle(
                                    fontSize: 18,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ],
                            ),
                            const SizedBox(height: 16),
                            TextFormField(
                              controller: _tuboAmountController,
                              decoration: InputDecoration(
                                labelText: 'Tubo Amount (₱)',
                                border: const OutlineInputBorder(),
                                suffixText: '₱',
                                helperText: 'Enter fixed tubo amount in pesos',
                              ),
                              keyboardType: TextInputType.numberWithOptions(
                                decimal: true,
                              ),
                              onChanged: _updateTuboAmount,
                              validator: (value) {
                                if (value == null || value.isEmpty) {
                                  return 'Tubo amount is required';
                                }
                                final amount = double.tryParse(value);
                                if (amount == null) {
                                  return 'Please enter a valid number';
                                }
                                if (amount < 0) {
                                  return 'Tubo amount must be 0 or greater';
                                }
                                return null;
                              },
                            ),
                            const SizedBox(height: 16),
                            Container(
                              padding: const EdgeInsets.all(12),
                              decoration: BoxDecoration(
                                color: Colors.blue.withValues(alpha: 0.1),
                                borderRadius: BorderRadius.circular(8),
                                border: Border.all(
                                  color: Colors.blue.withValues(alpha: 0.3),
                                ),
                              ),
                              child: Row(
                                children: [
                                  const Icon(
                                    Icons.info,
                                    color: Colors.blue,
                                    size: 20,
                                  ),
                                  const SizedBox(width: 8),
                                  Expanded(
                                    child: Text(
                                      'Current tubo: ₱${_tuboAmount.toStringAsFixed(2)}',
                                      style: const TextStyle(
                                        color: Colors.blue,
                                        fontWeight: FontWeight.w500,
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                    const SizedBox(height: 24),

                    // Pricing Method Section
                    Card(
                      child: Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const Row(
                              children: [
                                Icon(Icons.calculate, color: Colors.green),
                                SizedBox(width: 8),
                                Text(
                                  'Tubo Method',
                                  style: TextStyle(
                                    fontSize: 18,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ],
                            ),
                            const SizedBox(height: 16),
                            RadioGroup<bool>(
                              groupValue: _tuboInclusive,
                              onChanged: (value) {
                                setState(() {
                                  _tuboInclusive = value ?? true;
                                });
                              },
                              child: Column(
                                children: [
                                  RadioListTile<bool>(
                                    title: const Text('Tubo Inclusive'),
                                    subtitle: const Text(
                                      'Selling price equals cost (tubo included)',
                                    ),
                                    value: true,
                                  ),
                                  RadioListTile<bool>(
                                    title: const Text('Tubo Added on Top'),
                                    subtitle: const Text(
                                      'Tubo is added to the cost',
                                    ),
                                    value: false,
                                  ),
                                ],
                              ),
                            ),
                            const SizedBox(height: 16),
                            Container(
                              padding: const EdgeInsets.all(12),
                              decoration: BoxDecoration(
                                color: Colors.green.withValues(alpha: 0.1),
                                borderRadius: BorderRadius.circular(8),
                                border: Border.all(
                                  color: Colors.green.withValues(alpha: 0.3),
                                ),
                              ),
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Row(
                                    children: [
                                      Icon(
                                        _tuboInclusive
                                            ? Icons.check_circle
                                            : Icons.add_circle,
                                        color: Colors.green,
                                        size: 20,
                                      ),
                                      const SizedBox(width: 8),
                                      Text(
                                        _tuboInclusive
                                            ? 'Tubo Inclusive'
                                            : 'Tubo Added on Top',
                                        style: const TextStyle(
                                          color: Colors.green,
                                          fontWeight: FontWeight.w500,
                                        ),
                                      ),
                                    ],
                                  ),
                                  const SizedBox(height: 8),
                                  Text(
                                    _tuboInclusive
                                        ? 'Example: Cost ₱100 → Selling ₱100 (tubo included)'
                                        : 'Example: Cost ₱100 → Selling ₱${(100 + _tuboAmount).toStringAsFixed(0)} (₱100 + ₱${_tuboAmount.toStringAsFixed(0)} tubo)',
                                    style: const TextStyle(
                                      color: Colors.green,
                                      fontSize: 12,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                    const SizedBox(height: 24),

                    // Tax Information Section
                    Card(
                      child: Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const Row(
                              children: [
                                Icon(Icons.info_outline, color: Colors.orange),
                                SizedBox(width: 8),
                                Text(
                                  'Tubo Information',
                                  style: TextStyle(
                                    fontSize: 18,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ],
                            ),
                            const SizedBox(height: 16),
                            _buildTaxInfoRow(
                              'Current Tubo',
                              '₱${_tuboAmount.toStringAsFixed(2)}',
                            ),
                            _buildTaxInfoRow(
                              'Tubo Method',
                              _tuboInclusive
                                  ? 'Tubo Inclusive'
                                  : 'Tubo Added on Top',
                            ),
                            _buildTaxInfoRow(
                              'Tubo Application',
                              _tuboInclusive
                                  ? 'Included in price'
                                  : 'Added on top of cost',
                            ),
                            _buildTaxInfoRow(
                              'Receipt Display',
                              'Profit shown via tubo settings',
                            ),
                          ],
                        ),
                      ),
                    ),

                    if (_error != null) ...[
                      const SizedBox(height: 16),
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.red.withValues(alpha: 0.1),
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(
                            color: Colors.red.withValues(alpha: 0.3),
                          ),
                        ),
                        child: Row(
                          children: [
                            const Icon(
                              Icons.error,
                              color: Colors.red,
                              size: 20,
                            ),
                            const SizedBox(width: 8),
                            Expanded(
                              child: Text(
                                _error!,
                                style: const TextStyle(color: Colors.red),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],

                    const SizedBox(height: 24),
                    SizedBox(
                      width: double.infinity,
                      child: ElevatedButton(
                        onPressed: _isLoading ? null : _saveTaxSettings,
                        style: ElevatedButton.styleFrom(
                          padding: const EdgeInsets.symmetric(vertical: 16),
                        ),
                        child: _isLoading
                            ? const SizedBox(
                                height: 20,
                                width: 20,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                ),
                              )
                            : const Text(
                                'Save Markup Settings',
                                style: TextStyle(fontSize: 16),
                              ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
    );
  }

  Widget _buildTaxInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(label, style: const TextStyle(fontWeight: FontWeight.w500)),
          const SizedBox(height: 2),
          Text(
            value,
            style: TextStyle(
              color: Colors.grey[600],
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }
}




================================================================
FILE #16: D:\flutter project\prostock\lib\screens\settings\components\user_management_screen.dart
SIZE: 26.22 KB
MODIFIED: 09/28/2025 12:30:21
================================================================

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/models/app_user.dart';
import 'package:prostock/models/user_role.dart';
import 'package:prostock/providers/auth_provider.dart';
import 'package:prostock/screens/settings/components/app_update_widget.dart';
import 'package:prostock/screens/settings/components/create_user_dialog.dart';

class UserManagementScreen extends StatefulWidget {
  const UserManagementScreen({super.key});

  @override
  State<UserManagementScreen> createState() => _UserManagementScreenState();
}

class _UserManagementScreenState extends State<UserManagementScreen> {
  bool _showInactiveUsers = false;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('User Management'),
        actions: [
          Consumer<AuthProvider>(
            builder: (context, authProvider, child) {
              if (authProvider.isAdmin) {
                return IconButton(
                  icon: const Icon(Icons.person_add),
                  onPressed: () => _showCreateUserDialog(context),
                  tooltip: 'Add New User',
                );
              }
              return const SizedBox.shrink();
            },
          ),
        ],
      ),
      body: Consumer<AuthProvider>(
        builder: (context, authProvider, child) {
          // SECURITY CHECK - Only admins can access user management
          if (!authProvider.isAdmin) {
            return const Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.lock_outline, size: 64, color: Colors.grey),
                  SizedBox(height: 16),
                  Text(
                    'Access Denied',
                    style: TextStyle(
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                      color: Colors.grey,
                    ),
                  ),
                  SizedBox(height: 8),
                  Text(
                    'You do not have permission to access this page.',
                    style: TextStyle(fontSize: 16, color: Colors.grey),
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            );
          }

          return SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      const Text(
                        'User Accounts',
                        style: TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Row(
                        children: [
                          Switch(
                            value: _showInactiveUsers,
                            onChanged: (value) {
                              setState(() {
                                _showInactiveUsers = value;
                              });
                            },
                          ),
                          const Text('Show Inactive'),
                        ],
                      ),
                    ],
                  ),
                  const SizedBox(height: 10),
                  StreamBuilder<List<AppUser>>(
                    stream: authProvider.getAllUsers(),
                    builder: (context, snapshot) {
                      if (snapshot.connectionState == ConnectionState.waiting) {
                        return const Center(child: CircularProgressIndicator());
                      }
                      if (snapshot.hasError) {
                        return Center(child: Text('Error: ${snapshot.error}'));
                      }
                      if (!snapshot.hasData || snapshot.data!.isEmpty) {
                        return const Center(child: Text('No users found.'));
                      }

                      final allUsers = snapshot.data!;
                      final users = _showInactiveUsers
                          ? allUsers
                          : allUsers.where((user) => user.isActive).toList();

                      return ListView.builder(
                        shrinkWrap: true,
                        physics: const NeverScrollableScrollPhysics(),
                        itemCount: users.length,
                        itemBuilder: (context, index) {
                          final user = users[index];
                          final isCurrentUser =
                              user.id == authProvider.currentUser?.id;
                          final isLastAdmin =
                              user.role == UserRole.admin &&
                              allUsers
                                      .where(
                                        (u) =>
                                            u.role == UserRole.admin &&
                                            u.isActive,
                                      )
                                      .length ==
                                  1;

                          return Card(
                            margin: const EdgeInsets.only(bottom: 8),
                            color: !user.isActive ? Colors.grey[100] : null,
                            child: ListTile(
                              leading: CircleAvatar(
                                backgroundColor: user.role == UserRole.admin
                                    ? Colors.blue
                                    : Colors.grey,
                                child: Icon(
                                  user.role == UserRole.admin
                                      ? Icons.admin_panel_settings
                                      : Icons.person,
                                  color: Colors.white,
                                ),
                              ),
                              title: Text(
                                user.username,
                                style: const TextStyle(
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                              subtitle: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(user.email),
                                  Row(
                                    children: [
                                      Container(
                                        padding: const EdgeInsets.symmetric(
                                          horizontal: 8,
                                          vertical: 2,
                                        ),
                                        decoration: BoxDecoration(
                                          color: user.role == UserRole.admin
                                              ? Colors.blue.withValues(
                                                  alpha: 0.1,
                                                )
                                              : Colors.grey.withValues(
                                                  alpha: 0.1,
                                                ),
                                          borderRadius: BorderRadius.circular(
                                            12,
                                          ),
                                        ),
                                        child: Text(
                                          user.role.displayName,
                                          style: TextStyle(
                                            fontSize: 12,
                                            color: user.role == UserRole.admin
                                                ? Colors.blue
                                                : Colors.grey[600],
                                            fontWeight: FontWeight.w500,
                                          ),
                                        ),
                                      ),
                                      if (isCurrentUser) ...[
                                        const SizedBox(width: 8),
                                        Container(
                                          padding: const EdgeInsets.symmetric(
                                            horizontal: 8,
                                            vertical: 2,
                                          ),
                                          decoration: BoxDecoration(
                                            color: Colors.green.withValues(
                                              alpha: 0.1,
                                            ),
                                            borderRadius: BorderRadius.circular(
                                              12,
                                            ),
                                          ),
                                          child: const Text(
                                            'You',
                                            style: TextStyle(
                                              fontSize: 12,
                                              color: Colors.green,
                                              fontWeight: FontWeight.w500,
                                            ),
                                          ),
                                        ),
                                      ],
                                      if (!user.isActive) ...[
                                        const SizedBox(width: 8),
                                        Container(
                                          padding: const EdgeInsets.symmetric(
                                            horizontal: 8,
                                            vertical: 2,
                                          ),
                                          decoration: BoxDecoration(
                                            color: Colors.red.withValues(
                                              alpha: 0.1,
                                            ),
                                            borderRadius: BorderRadius.circular(
                                              12,
                                            ),
                                          ),
                                          child: const Text(
                                            'Inactive',
                                            style: TextStyle(
                                              fontSize: 12,
                                              color: Colors.red,
                                              fontWeight: FontWeight.w500,
                                            ),
                                          ),
                                        ),
                                      ],
                                    ],
                                  ),
                                ],
                              ),
                              trailing: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  if (!isCurrentUser) ...[
                                    if (user.isActive) ...[
                                      IconButton(
                                        icon: const Icon(Icons.edit),
                                        onPressed: () =>
                                            _editUserRole(context, user),
                                        tooltip: 'Edit Role',
                                      ),
                                      IconButton(
                                        icon: Icon(
                                          isLastAdmin
                                              ? Icons.block
                                              : Icons.delete,
                                          color: isLastAdmin
                                              ? Colors.grey
                                              : null,
                                        ),
                                        onPressed: isLastAdmin
                                            ? null
                                            : () => _deleteUser(context, user),
                                        tooltip: isLastAdmin
                                            ? 'Cannot delete last admin'
                                            : 'Deactivate User',
                                      ),
                                    ] else ...[
                                      IconButton(
                                        icon: const Icon(Icons.restore),
                                        onPressed: () =>
                                            _restoreUser(context, user),
                                        tooltip: 'Restore User',
                                      ),
                                      IconButton(
                                        icon: const Icon(Icons.delete_forever),
                                        onPressed: () =>
                                            _hardDeleteUser(context, user),
                                        tooltip: 'Permanently Delete',
                                      ),
                                    ],
                                  ],
                                  IconButton(
                                    icon: const Icon(Icons.vpn_key),
                                    onPressed: () =>
                                        _resetPassword(context, user),
                                    tooltip: 'Reset Password',
                                  ),
                                ],
                              ),
                            ),
                          );
                        },
                      );
                    },
                  ),
                  const SizedBox(height: 20),
                  const AppUpdateWidget(),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  void _editUserRole(BuildContext context, AppUser user) async {
    UserRole selectedRole = user.role;
    final authProvider = context.read<AuthProvider>();
    final scaffoldMessenger = ScaffoldMessenger.of(context);

    final result = await showDialog<bool>(
      context: context,
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setState) {
            return AlertDialog(
              title: Text('Edit Role for ${user.username}'),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    'Current role: ${user.role.displayName}',
                    style: const TextStyle(fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 16),
                  DropdownButtonFormField<UserRole>(
                    initialValue: selectedRole,
                    decoration: const InputDecoration(
                      labelText: 'Select New Role',
                      border: OutlineInputBorder(),
                    ),
                    onChanged: (UserRole? newValue) {
                      if (newValue != null) {
                        setState(() {
                          selectedRole = newValue;
                        });
                      }
                    },
                    items: UserRole.values.map((UserRole role) {
                      return DropdownMenuItem<UserRole>(
                        value: role,
                        child: Text(role.displayName),
                      );
                    }).toList(),
                  ),
                ],
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(false),
                  child: const Text('Cancel'),
                ),
                ElevatedButton(
                  onPressed: selectedRole != user.role
                      ? () => Navigator.of(context).pop(true)
                      : null,
                  child: const Text('Update Role'),
                ),
              ],
            );
          },
        );
      },
    );

    if (result == true && selectedRole != user.role) {
      final success = await authProvider.updateUserRole(user, selectedRole);

      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(
              success
                  ? 'User role updated successfully'
                  : 'Failed to update user role',
            ),
            backgroundColor: success ? Colors.green : Colors.red,
          ),
        );
      }
    }
  }

  void _deleteUser(BuildContext context, AppUser user) async {
    final authProvider = context.read<AuthProvider>();
    final scaffoldMessenger = ScaffoldMessenger.of(context);

    final result = await showDialog<bool>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Delete User'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('Are you sure you want to delete this user?'),
              const SizedBox(height: 8),
              Text(
                'Username: ${user.username}',
                style: const TextStyle(fontWeight: FontWeight.bold),
              ),
              Text('Email: ${user.email}'),
              Text('Role: ${user.role.displayName}'),
              const SizedBox(height: 16),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.red.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.red.withValues(alpha: 0.3)),
                ),
                child: const Row(
                  children: [
                    Icon(Icons.warning, color: Colors.red, size: 20),
                    SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        'This action cannot be undone!',
                        style: TextStyle(
                          color: Colors.red,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () => Navigator.of(context).pop(true),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.red,
                foregroundColor: Colors.white,
              ),
              child: const Text('Delete User'),
            ),
          ],
        );
      },
    );

    if (result == true) {
      final success = await authProvider.deleteUser(user);

      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(
              success ? 'User deleted successfully' : 'Failed to delete user',
            ),
            backgroundColor: success ? Colors.green : Colors.red,
          ),
        );
      }
    }
  }

  void _resetPassword(BuildContext context, AppUser user) async {
    final authProvider = context.read<AuthProvider>();
    final scaffoldMessenger = ScaffoldMessenger.of(context);

    final result = await showDialog<bool>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Reset Password'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('Send password reset email to:'),
              const SizedBox(height: 8),
              Text(
                user.email,
                style: const TextStyle(
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                ),
              ),
              const SizedBox(height: 16),
              const Text(
                'The user will receive an email with instructions to reset their password.',
                style: TextStyle(color: Colors.grey),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: const Text('Send Reset Email'),
            ),
          ],
        );
      },
    );

    if (result == true) {
      final error = await authProvider.sendPasswordResetEmail(user.email);

      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(
              error == null
                  ? 'Password reset email sent to ${user.email}'
                  : 'Failed to send password reset email: $error',
            ),
            backgroundColor: error == null ? Colors.green : Colors.red,
          ),
        );
      }
    }
  }

  void _restoreUser(BuildContext context, AppUser user) async {
    final authProvider = context.read<AuthProvider>();
    final scaffoldMessenger = ScaffoldMessenger.of(context);

    final result = await showDialog<bool>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Restore User'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('Are you sure you want to restore this user?'),
              const SizedBox(height: 8),
              Text(
                'Username: ${user.username}',
                style: const TextStyle(fontWeight: FontWeight.bold),
              ),
              Text('Email: ${user.email}'),
              Text('Role: ${user.role.displayName}'),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () => Navigator.of(context).pop(true),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.green,
                foregroundColor: Colors.white,
              ),
              child: const Text('Restore User'),
            ),
          ],
        );
      },
    );

    if (result == true) {
      final success = await authProvider.restoreUser(user);

      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(
              success ? 'User restored successfully' : 'Failed to restore user',
            ),
            backgroundColor: success ? Colors.green : Colors.red,
          ),
        );
      }
    }
  }

  void _hardDeleteUser(BuildContext context, AppUser user) async {
    final authProvider = context.read<AuthProvider>();
    final scaffoldMessenger = ScaffoldMessenger.of(context);

    final result = await showDialog<bool>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Permanently Delete User'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('Are you sure you want to PERMANENTLY delete this user?'),
              const SizedBox(height: 8),
              Text(
                'Username: ${user.username}',
                style: const TextStyle(fontWeight: FontWeight.bold),
              ),
              Text('Email: ${user.email}'),
              Text('Role: ${user.role.displayName}'),
              const SizedBox(height: 16),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.red.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.red.withValues(alpha: 0.3)),
                ),
                child: const Row(
                  children: [
                    Icon(Icons.warning, color: Colors.red, size: 20),
                    SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        'This action is IRREVERSIBLE! The user will be permanently removed from the system.',
                        style: TextStyle(
                          color: Colors.red,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () => Navigator.of(context).pop(true),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.red,
                foregroundColor: Colors.white,
              ),
              child: const Text('Delete Forever'),
            ),
          ],
        );
      },
    );

    if (result == true) {
      final success = await authProvider.hardDeleteUser(user);

      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(
              success ? 'User permanently deleted' : 'Failed to delete user',
            ),
            backgroundColor: success ? Colors.green : Colors.red,
          ),
        );
      }
    }
  }

  void _showCreateUserDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => const CreateUserDialog(),
    );
  }
}




================================================================
FILE #17: D:\flutter project\prostock\lib\services\firestore\user_service.dart
SIZE: 5.27 KB
MODIFIED: 09/12/2025 20:42:20
================================================================

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:prostock/models/app_user.dart';
import 'package:prostock/services/firestore/firestore_exception.dart';
import 'package:prostock/utils/constants.dart';
import 'package:prostock/utils/password_helper.dart';

class UserService {
  final FirebaseFirestore _firestore;
  final FirebaseAuth _auth;

  UserService(this._firestore, this._auth);

  CollectionReference get users =>
      _firestore.collection(AppConstants.usersCollection);

  User? get currentUser => _auth.currentUser;
  Stream<User?> get authStateChanges => _auth.authStateChanges();

  Future<void> initializeFirestore() async {
    try {
      // Create initial admin user if it doesn't exist
      final adminQuery = await users
          .where('username', isEqualTo: 'admin')
          .get();
      if (adminQuery.docs.isEmpty) {
        final hashedPassword = PasswordHelper.hashPassword('admin123');
        await users.add({
          'username': 'admin',
          'passwordHash': hashedPassword,
          'role': 'admin',
          'isActive': true,
          'createdAt': FieldValue.serverTimestamp(),
        });
      }

      // Create initial regular user if it doesn't exist
      final userQuery = await users.where('username', isEqualTo: 'user').get();
      if (userQuery.docs.isEmpty) {
        final hashedPassword = PasswordHelper.hashPassword('user123');
        await users.add({
          'username': 'user',
          'passwordHash': hashedPassword,
          'role': 'user',
          'isActive': true,
          'createdAt': FieldValue.serverTimestamp(),
        });
      }
    } catch (e) {
      throw FirestoreException('Failed to initialize Firestore: $e');
    }
  }

  Future<AppUser?> getUserByCredentials(
    String username,
    String password,
  ) async {
    try {
      final snapshot = await users
          .where('username', isEqualTo: username)
          .limit(1)
          .get();

      if (snapshot.docs.isNotEmpty) {
        final doc = snapshot.docs.first;
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;

        return AppUser.fromMap(data);
      }

      return null;
    } catch (e) {
      throw FirestoreException('Failed to get user by credentials: $e');
    }
  }

  Future<AppUser?> getUserByUsername(String username) async {
    try {
      final snapshot = await users
          .where('username', isEqualTo: username)
          .limit(1)
          .get();

      if (snapshot.docs.isNotEmpty) {
        final doc = snapshot.docs.first;
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;

        return AppUser.fromMap(data);
      }

      return null;
    } catch (e) {
      throw FirestoreException('Failed to get user by username: $e');
    }
  }

  Future<AppUser?> getUserByEmail(String email) async {
    try {
      final snapshot = await users
          .where('email', isEqualTo: email)
          .limit(1)
          .get();

      if (snapshot.docs.isNotEmpty) {
        final doc = snapshot.docs.first;
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;

        return AppUser.fromMap(data);
      }

      return null;
    } catch (e) {
      throw FirestoreException('Failed to get user by email: $e');
    }
  }

  Future<AppUser?> getUserById(String id) async {
    try {
      final doc = await users.doc(id).get();

      if (doc.exists) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return AppUser.fromMap(data);
      }
      return null;
    } catch (e) {
      throw FirestoreException('Failed to get user by ID: $e');
    }
  }

  Future<List<AppUser>> getAllUsers() async {
    try {
      final snapshot = await users.orderBy('username').get();
      return snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return AppUser.fromMap(data);
      }).toList();
    } catch (e) {
      throw FirestoreException('Failed to get all users: $e');
    }
  }

  Stream<List<AppUser>> getAllUsersStream() {
    try {
      return users.orderBy('username').snapshots().map((snapshot) {
        return snapshot.docs.map((doc) {
          final data = doc.data() as Map<String, dynamic>;
          data['id'] = doc.id;
          return AppUser.fromMap(data);
        }).toList();
      });
    } catch (e) {
      throw FirestoreException('Failed to get all users: $e');
    }
  }

  Future<String> insertUser(AppUser user) async {
    try {
      final userData = user.toMap();
      userData.remove('id');

      // Add isActive field for future compatibility
      userData['isActive'] = true;

      final docRef = await users.add(userData);
      return docRef.id;
    } catch (e) {
      throw FirestoreException('Failed to insert user: $e');
    }
  }

  Future<void> updateUser(AppUser user) async {
    try {
      final userData = user.toMap();
      userData.remove('id');

      await users.doc(user.id).update(userData);
    } catch (e) {
      throw FirestoreException('Failed to update user: $e');
    }
  }

  Future<void> deleteUser(String id) async {
    try {
      await users.doc(id).delete();
    } catch (e) {
      throw FirestoreException('Failed to delete user: $e');
    }
  }
}




================================================================
FILE #18: D:\flutter project\prostock\lib\services\firestore\activity_service.dart
SIZE: 6.82 KB
MODIFIED: 09/12/2025 20:22:14
================================================================

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:prostock/models/paginated_result.dart';
import 'package:prostock/models/user_activity.dart';
import 'package:prostock/services/firestore/firestore_exception.dart';
import 'package:prostock/utils/app_constants.dart';
import 'package:prostock/utils/constants.dart';

class ActivityService {
  final FirebaseFirestore _firestore;

  ActivityService(this._firestore);

  CollectionReference get activities =>
      _firestore.collection(AppConstants.activitiesCollection);
  CollectionReference get users =>
      _firestore.collection(AppConstants.usersCollection);

  Stream<List<UserActivity>> getActivitiesStream({
    String? userId,
    DateTimeRange? dateRange,
    List<String>? activityTypes,
  }) {
    Query query = activities.orderBy('timestamp', descending: true);

    if (userId != null) {
      query = query.where('user_id', isEqualTo: userId);
    }

    if (dateRange != null) {
      query = query
          .where('timestamp', isGreaterThanOrEqualTo: dateRange.start)
          .where('timestamp', isLessThanOrEqualTo: dateRange.end);
    }

    if (activityTypes != null && activityTypes.isNotEmpty) {
      query = query.where('action', whereIn: activityTypes);
    }

    return query.snapshots().map((snapshot) {
      return snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return UserActivity.fromMap(data);
      }).toList();
    });
  }

  Future<void> logActivity(
    String userId,
    String action,
    String details, {
    String? username,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final sanitizedMetadata = metadata != null
          ? Map<String, dynamic>.from(metadata)
          : <String, dynamic>{};

      await activities.add({
        'user_id': userId,
        'username': username, // Denormalized username
        'action': action,
        'details': details,
        'metadata': sanitizedMetadata,
        'timestamp': FieldValue.serverTimestamp(),
        'ipAddress': 'hidden', // Don't log actual IP for privacy
      });
    } catch (e) {
      throw FirestoreException('Failed to log activity: $e');
    }
  }

  Future<String> insertUserActivity(UserActivity activity) async {
    try {
      final activityData = activity.toMap();
      activityData.remove('id');

      final docRef = await activities.add(activityData);
      return docRef.id;
    } catch (e) {
      throw FirestoreException('Failed to insert user activity: $e');
    }
  }

  Future<List<UserActivity>> getUserActivities(
    String userId, {
    int limit = ValidationConstants.maxLocalErrors,
  }) async {
    try {
      final snapshot = await activities
          .where('user_id', isEqualTo: userId)
          .orderBy('timestamp', descending: true)
          .limit(limit)
          .get();

      return snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return UserActivity.fromMap(data);
      }).toList();
    } catch (e) {
      throw FirestoreException('Failed to get user activities: $e');
    }
  }

  Future<List<Map<String, dynamic>>> getAllUserActivitiesWithUsernames({
    int limit = ValidationConstants.maxDescriptionLength,
  }) async {
    try {
      final activitiesSnapshot = await activities
          .orderBy('timestamp', descending: true)
          .limit(limit)
          .get();

      final List<Map<String, dynamic>> result = [];

      for (final activityDoc in activitiesSnapshot.docs) {
        final activityData = activityDoc.data() as Map<String, dynamic>;
        activityData['id'] = activityDoc.id;
        // Get username
        final userId = activityData['user_id'];
        final userDoc = await users.doc(userId).get();
        if (userDoc.exists) {
          final userData = userDoc.data() as Map<String, dynamic>;
          activityData['username'] = userData['username'];
        }

        result.add(activityData);
      }

      return result;
    } catch (e) {
      throw FirestoreException(
        'Failed to get all user activities with usernames: $e',
      );
    }
  }

  Stream<List<UserActivity>> getAllUserActivitiesStream() {
    try {
      return activities.orderBy('timestamp', descending: true).snapshots().map((snapshot) {
        return snapshot.docs.map((doc) {
          final data = doc.data() as Map<String, dynamic>;
          data['id'] = doc.id;
          return UserActivity.fromMap(data);
        }).toList();
      });
    } catch (e) {
      throw FirestoreException('Failed to get all user activities: $e');
    }
  }

  Future<List<UserActivity>> getActivitiesByDateRange(
    DateTime start,
    DateTime end, {
    String? userId,
  }) async {
    try {
      Query query = activities
          .where('timestamp', isGreaterThanOrEqualTo: Timestamp.fromDate(start))
          .where('timestamp', isLessThanOrEqualTo: Timestamp.fromDate(end));

      if (userId != null) {
        query = query.where('user_id', isEqualTo: userId);
      }

      final snapshot = await query.orderBy('timestamp', descending: true).get();

      return snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return UserActivity.fromMap(data);
      }).toList();
    } catch (e) {
      throw FirestoreException('Failed to get activities by date range: $e');
    }
  }

  Future<PaginatedResult<UserActivity>> getUserActivitiesPaginated({
    String? userId,
    String? role,
    int limit = ApiConstants.productSearchLimit,
    DocumentSnapshot? lastDocument,
  }) async {
    if (userId == null && role == null) {
      throw ArgumentError('Either userId or role must be provided.');
    }

    try {
      List<String> userIds = [];
      if (role != null) {
        final usersSnapshot = await users.where('role', isEqualTo: role).get();
        userIds = usersSnapshot.docs.map((doc) => doc.id).toList();
        if (userIds.isEmpty) {
          return PaginatedResult(items: [], lastDocument: null);
        }
      } else if (userId != null) {
        userIds.add(userId);
      }

      Query query = activities
          .where('user_id', whereIn: userIds)
          .orderBy('timestamp', descending: true);

      if (lastDocument != null) {
        query = query.startAfterDocument(lastDocument);
      }

      query = query.limit(limit);

      final snapshot = await query.get();

      final activitiesList = snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return UserActivity.fromMap(data);
      }).toList();

      return PaginatedResult(
        items: activitiesList,
        lastDocument: snapshot.docs.isNotEmpty ? snapshot.docs.last : null,
      );
    } catch (e) {
      throw FirestoreException('Failed to get paginated user activities: $e');
    }
  }
}




================================================================
FILE #19: D:\flutter project\prostock\lib\providers\auth_provider.dart
SIZE: 16.45 KB
MODIFIED: 10/02/2025 17:06:21
================================================================

import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';

import 'package:prostock/models/offline_operation.dart';
import 'package:prostock/services/offline_manager.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/app_user.dart';
import '../models/user_role.dart';
import '../models/user_activity.dart';
import 'package:prostock/services/firestore/user_service.dart';
import 'package:prostock/services/firestore/activity_service.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../utils/password_helper.dart';
import '../utils/error_logger.dart'; // Added ErrorLogger import for consistent logging
import '../utils/auth_error_handler.dart';

class AuthProvider with ChangeNotifier {
  final FirebaseAuth _firebaseAuth = FirebaseAuth.instance;
  final UserService _userService = UserService(
    FirebaseFirestore.instance,
    FirebaseAuth.instance,
  );
  final ActivityService _activityService = ActivityService(
    FirebaseFirestore.instance,
  );
  final OfflineManager _offlineManager;

  bool _isAuthenticated = false;
  AppUser? _currentUser;
  User? _firebaseUser;

  AuthProvider(this._offlineManager);

  bool get isAuthenticated => _isAuthenticated;
  AppUser? get currentUser => _currentUser;
  User? get firebaseUser => _firebaseUser;
  String? get username => _currentUser?.username;
  UserRole? get userRole => _currentUser?.role;
  bool get isAdmin => _currentUser?.role == UserRole.admin;

  String? _error;
  String? get error => _error;

  Map<String, String> _fieldErrors = {};
  Map<String, String> get fieldErrors => _fieldErrors;

  void clearFieldErrors() {
    _fieldErrors.clear();
    notifyListeners();
  }

  Future<bool> login(String email, String password) async {
    try {
      // Clear previous errors
      _error = null;
      _fieldErrors.clear();

      final credential = await _firebaseAuth.signInWithEmailAndPassword(
        email: email.trim(),
        password: password,
      );

      if (credential.user != null) {
        if (!credential.user!.emailVerified) {
          await _firebaseAuth.signOut();
          _error = 'Please verify your email before logging in.';
          return false;
        }

        final user = await _userService.getUserByEmail(email.trim());
        if (user != null) {
          _isAuthenticated = true;
          _currentUser = user;
          _firebaseUser = credential.user;

          // Save to SharedPreferences
          final prefs = await SharedPreferences.getInstance();
          await prefs.setBool('isAuthenticated', true);
          await prefs.setString('userId', user.id.toString());
          await prefs.setString('username', user.username);
          await prefs.setString('userRole', user.role.name);

          await logActivity('LOGIN', details: 'User logged in');

          notifyListeners();
          return true;
        }
      }
      _error = 'Login failed. Please check your credentials.';
      return false;
    } on FirebaseAuthException catch (e) {
      _error = AuthErrorHandler.getLoginErrorMessage(e);
      _fieldErrors = AuthErrorHandler.getFieldSpecificError(e);
      ErrorLogger.logError(
        'Error during login',
        error: e,
        context: 'AuthProvider.login',
      );
      return false;
    } catch (e) {
      _error = 'An unexpected error occurred. Please try again.';
      ErrorLogger.logError(
        'Unexpected error during login',
        error: e,
        context: 'AuthProvider.login',
      );
      return false;
    }
  }

  Future<void> logout() async {
    try {
      if (_currentUser != null) {
        await logActivity('LOGOUT', details: 'User logged out');
      }

      await _firebaseAuth.signOut();

      _isAuthenticated = false;
      _currentUser = null;
      _firebaseUser = null;

      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('isAuthenticated');
      await prefs.remove('userId');
      await prefs.remove('username');
      await prefs.remove('userRole');

      notifyListeners();
    } catch (e) {
      ErrorLogger.logError(
        'Error during logout',
        error: e,
        context: 'AuthProvider.logout',
      ); // Replaced print with ErrorLogger
    }
  }

  Future<void> checkAuthStatus() async {
    try {
      final firebaseUser = _firebaseAuth.currentUser;

      if (firebaseUser != null) {
        _firebaseUser = firebaseUser;

        // Get user data from SharedPreferences or Firestore
        final prefs = await SharedPreferences.getInstance();
        final userId = prefs.getString('userId');
        final username = prefs.getString('username');
        final userRoleString = prefs.getString('userRole');

        if (userId != null && username != null && userRoleString != null) {
          _currentUser = AppUser(
            id: userId,
            username: username,
            email: firebaseUser.email!,
            passwordHash: '', // Don't store password in memory
            role: UserRole.fromString(userRoleString),
            createdAt: DateTime.now(), // Placeholder
          );
          _isAuthenticated = true;
        } else {
          // Fallback: get user data from Firestore
          try {
            final userData = await _userService.getUserByEmail(
              firebaseUser.email!,
            );

            if (userData != null) {
              _currentUser = userData;
              _isAuthenticated = true;

              // Update SharedPreferences
              await prefs.setBool('isAuthenticated', true);
              await prefs.setString('userId', userData.id.toString());
              await prefs.setString('username', userData.username);
              await prefs.setString('userRole', userData.role.name);
            }
          } catch (e) {
            ErrorLogger.logError(
              'Error getting user data from Firestore',
              error: e,
              context: 'AuthProvider.checkAuthStatus',
            ); // Replaced print with ErrorLogger
          }
        }
      } else {
        _isAuthenticated = false;
        _currentUser = null;
        _firebaseUser = null;
      }

      notifyListeners();
    } catch (e) {
      ErrorLogger.logError(
        'Error checking auth status',
        error: e,
        context: 'AuthProvider.checkAuthStatus',
      ); // Replaced print with ErrorLogger
    }
  }

  Future<void> logActivity(
    String action, {
    String? productName,
    String? productBarcode,
    int? quantity,
    double? amount,
    String? details,
  }) async {
    try {
      if (_currentUser?.id != null) {
        final activity = UserActivity(
          userId: _currentUser!.id.toString(),
          action: action,
          productName: productName,
          productBarcode: productBarcode,
          quantity: quantity,
          amount: amount,
          details: details,
          timestamp: DateTime.now(),
        );

        if (_offlineManager.isOnline) {
          await _activityService.insertUserActivity(activity);
        } else {
          await _offlineManager.queueOperation(
            OfflineOperation(
              type: OperationType.logActivity,
              collectionName: 'activities',
              data: activity.toMap(),
              timestamp: DateTime.now(),
            ),
          );
        }
      }
    } catch (e) {
      ErrorLogger.logError(
        'Error logging activity',
        error: e,
        context: 'AuthProvider.logActivity',
      ); // Replaced print with ErrorLogger
    }
  }

  Future<bool> canDeleteUser(AppUser user) async {
    try {
      // Cannot delete current user
      if (user.id == _currentUser?.id) {
        return false;
      }

      // Cannot delete last admin
      final allUsers = await getAllUsersList();
      final adminCount = allUsers.where((u) => u.role == UserRole.admin).length;
      if (user.role == UserRole.admin && adminCount <= 1) {
        return false;
      }

      return true;
    } catch (e) {
      ErrorLogger.logError(
        'Error checking if user can be deleted',
        error: e,
        context: 'AuthProvider.canDeleteUser',
      );
      return false;
    }
  }

  Future<bool> createUser(
    String username,
    String email,
    String password,
    UserRole role,
  ) async {
    AppUser? newUser;
    try {
      // Clear previous errors
      _error = null;
      _fieldErrors.clear();

      // Validate inputs
      if (username.trim().isEmpty || email.trim().isEmpty || password.isEmpty) {
        _error = 'Please fill in all required fields.';
        return false;
      }

      // Check if username already exists
      final existingUser = await _userService.getUserByUsername(
        username.trim(),
      );
      if (existingUser != null) {
        _error = 'Username already exists';
        return false;
      }

      final hashedPassword = PasswordHelper.hashPassword(password);

      // Create user in Firestore first
      newUser = AppUser(
        username: username.trim(),
        email: email.trim(),
        passwordHash: hashedPassword, // Store hashed password
        role: role,
        createdAt: DateTime.now(),
      );

      final userId = await _userService.insertUser(newUser);
      newUser.id = userId;

      // Create Firebase Auth account
      try {
        final credential = await _firebaseAuth.createUserWithEmailAndPassword(
          email: email.trim(),
          password: password,
        );

        if (credential.user != null) {
          await credential.user!.sendEmailVerification();
          await credential.user!.updateDisplayName(username.trim());
          await logActivity(
            'CREATE_USER',
            details: 'User $username created with role ${role.displayName}',
          );
          _error =
              'A verification email has been sent to your email address. Please verify your email to login.';
          return true;
        } else {
          _error = 'Failed to create Firebase Auth user';
          return false;
        }
      } catch (e) {
        // If Firebase Auth creation fails, delete the Firestore user
        if (newUser.id != null) {
          await _userService.deleteUser(newUser.id!);
        }
        rethrow;
      }
    } on FirebaseAuthException catch (e) {
      _error = AuthErrorHandler.getSignupErrorMessage(e);
      _fieldErrors = AuthErrorHandler.getFieldSpecificError(e);
      ErrorLogger.logError(
        'Error creating user',
        error: e,
        context: 'AuthProvider.createUser',
      );
      return false;
    } catch (e) {
      _error = 'An unexpected error occurred. Please try again.';
      ErrorLogger.logError(
        'Unexpected error creating user',
        error: e,
        context: 'AuthProvider.createUser',
      );
      return false;
    }
  }

  Future<String?> sendPasswordResetEmail(String email) async {
    try {
      await _firebaseAuth.sendPasswordResetEmail(email: email.trim());
      return null;
    } on FirebaseAuthException catch (e) {
      ErrorLogger.logError(
        'Error sending password reset email',
        error: e,
        context: 'AuthProvider.sendPasswordResetEmail',
      );
      return AuthErrorHandler.getPasswordResetErrorMessage(e);
    } catch (e) {
      ErrorLogger.logError(
        'Unexpected error sending password reset email',
        error: e,
        context: 'AuthProvider.sendPasswordResetEmail',
      );
      return 'An unexpected error occurred. Please try again.';
    }
  }

  Stream<List<AppUser>> getAllUsers() {
    try {
      return _userService.getAllUsersStream();
    } catch (e) {
      ErrorLogger.logError(
        'Error getting all users',
        error: e,
        context: 'AuthProvider.getAllUsers',
      );
      return Stream.value([]);
    }
  }

  Future<List<AppUser>> getAllUsersList() async {
    try {
      return await _userService.getAllUsers();
    } catch (e) {
      ErrorLogger.logError(
        'Error getting all users',
        error: e,
        context: 'AuthProvider.getAllUsersList',
      );
      return [];
    }
  }

  Future<bool> updateUserRole(AppUser user, UserRole newRole) async {
    try {
      // Clear previous error
      _error = null;

      // Validate that user exists and role change is valid
      if (user.id == null) {
        _error = 'Invalid user ID';
        return false;
      }

      // Prevent changing role of current user to non-admin if they're the last admin
      if (user.id == _currentUser?.id && newRole != UserRole.admin) {
        final allUsers = await getAllUsersList();
        final adminCount = allUsers
            .where((u) => u.role == UserRole.admin)
            .length;
        if (adminCount <= 1) {
          _error = 'Cannot remove admin role from the last admin user';
          return false;
        }
      }

      final updatedUser = user.copyWith(role: newRole);
      await _userService.updateUser(updatedUser);

      // Log the activity
      await logActivity(
        'UPDATE_USER_ROLE',
        details: 'Changed role of ${user.username} to ${newRole.displayName}',
      );

      notifyListeners();
      return true;
    } catch (e) {
      _error = 'Failed to update user role: ${e.toString()}';
      ErrorLogger.logError(
        'Error updating user role',
        error: e,
        context: 'AuthProvider.updateUserRole',
      );
      return false;
    }
  }

  Future<bool> deleteUser(AppUser user) async {
    try {
      // Clear previous error
      _error = null;

      // Validate that user exists
      if (user.id == null) {
        _error = 'Invalid user ID';
        return false;
      }

      // Prevent deleting current user
      if (user.id == _currentUser?.id) {
        _error = 'Cannot delete your own account';
        return false;
      }

      // Prevent deleting last admin
      final allUsers = await getAllUsersList();
      final adminCount = allUsers.where((u) => u.role == UserRole.admin).length;
      if (user.role == UserRole.admin && adminCount <= 1) {
        _error = 'Cannot delete the last admin user';
        return false;
      }

      // Soft delete - deactivate user instead of hard delete
      final deactivatedUser = user.copyWith(isActive: false);
      await _userService.updateUser(deactivatedUser);

      // Log the activity
      await logActivity(
        'DEACTIVATE_USER',
        details: 'Deactivated user ${user.username} (${user.email})',
      );

      notifyListeners();
      return true;
    } catch (e) {
      _error = 'Failed to deactivate user: ${e.toString()}';
      ErrorLogger.logError(
        'Error deactivating user',
        error: e,
        context: 'AuthProvider.deleteUser',
      );
      return false;
    }
  }

  Future<bool> restoreUser(AppUser user) async {
    try {
      // Clear previous error
      _error = null;

      // Validate that user exists
      if (user.id == null) {
        _error = 'Invalid user ID';
        return false;
      }

      // Restore user - reactivate user
      final restoredUser = user.copyWith(isActive: true);
      await _userService.updateUser(restoredUser);

      // Log the activity
      await logActivity(
        'RESTORE_USER',
        details: 'Restored user ${user.username} (${user.email})',
      );

      notifyListeners();
      return true;
    } catch (e) {
      _error = 'Failed to restore user: ${e.toString()}';
      ErrorLogger.logError(
        'Error restoring user',
        error: e,
        context: 'AuthProvider.restoreUser',
      );
      return false;
    }
  }

  Future<bool> hardDeleteUser(AppUser user) async {
    try {
      // Clear previous error
      _error = null;

      // Validate that user exists
      if (user.id == null) {
        _error = 'Invalid user ID';
        return false;
      }

      // Prevent deleting current user
      if (user.id == _currentUser?.id) {
        _error = 'Cannot delete your own account';
        return false;
      }

      // Prevent deleting last admin
      final allUsers = await getAllUsersList();
      final adminCount = allUsers.where((u) => u.role == UserRole.admin).length;
      if (user.role == UserRole.admin && adminCount <= 1) {
        _error = 'Cannot delete the last admin user';
        return false;
      }

      await _userService.deleteUser(user.id!);

      // Log the activity
      await logActivity(
        'HARD_DELETE_USER',
        details: 'Permanently deleted user ${user.username} (${user.email})',
      );

      notifyListeners();
      return true;
    } catch (e) {
      _error = 'Failed to delete user: ${e.toString()}';
      ErrorLogger.logError(
        'Error deleting user',
        error: e,
        context: 'AuthProvider.hardDeleteUser',
      );
      return false;
    }
  }
}




========================================
EXPORT SUMMARY
========================================
Total Admin Module Files: 19
Export Date: 11/12/2025 11:10:36
Project: ProStock Inventory Management
Module: ADMIN
========================================

