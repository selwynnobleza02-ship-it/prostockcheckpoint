========================================
PROSTOCK - COMPLETE DART SOURCE CODE
Generated: 11/11/2025 07:08:14
========================================


â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\firebase_options.dart
â•‘ SIZE: 1.12 KB
â•‘ MODIFIED: 09/05/2025 19:59:06
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, TargetPlatform;

class DefaultFirebaseOptions {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
  static FirebaseOptions get currentPlatform {
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.windows:
        return web;
      default:
        throw UnsupportedError('This app only supports Android and web platforms.');
    }
  }

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCzapltT_RItwO0lCP-S3qPkXlkIIqfKqc',
    appId: '1:717667508105:android:d9ccc389bc899998000b58',
    messagingSenderId: '717667508105',
    projectId: 'prostock-a913b',
    storageBucket: 'prostock-a913b.firebasestorage.app',
  );

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyCzapltT_RItwO0lCP-S3qPkXlkIIqfKqc',
    appId: '1:717667508105:android:d9ccc389bc899998000b58',
    messagingSenderId: '717667508105',
    projectId: 'prostock-a913b',
    storageBucket: 'prostock-a913b.firebasestorage.app',
  );
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\main.dart
â•‘ SIZE: 8.92 KB
â•‘ MODIFIED: 10/03/2025 21:36:52
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/services/credit_check_service.dart';
import 'package:prostock/services/local_database_service.dart';
import 'package:prostock/services/notification_service.dart';
import 'package:prostock/services/printing_service.dart';
import 'package:prostock/services/tax_service.dart';
import 'package:flutter/material.dart';
import 'package:prostock/providers/sync_failure_provider.dart';
import 'package:prostock/providers/stock_movement_provider.dart';
import 'package:prostock/providers/theme_provider.dart';
import 'package:prostock/screens/settings/components/change_password_screen.dart';
import 'package:prostock/screens/settings/components/printer_settings_screen.dart';
import 'package:prostock/screens/settings/settings_screen.dart';
import 'package:prostock/utils/global_error_handler.dart';
import 'package:provider/provider.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:prostock/services/background_sync_service.dart';
import 'package:prostock/services/firestore/credit_service.dart';
import 'package:prostock/services/firestore/pricing_service.dart';
import 'package:prostock/services/offline_manager.dart';
import 'firebase_options.dart';
import 'providers/inventory_provider.dart';
import 'providers/sales_provider.dart';
import 'providers/customer_provider.dart';
import 'providers/credit_provider.dart';
import 'providers/auth_provider.dart';
import 'providers/demand_provider.dart';
import 'services/demand_analysis_service.dart';
import 'screens/admin/admin_screen.dart';
import 'screens/login_signup/login_screen.dart';
import 'screens/login_signup/signup_screen.dart';
import 'screens/user/user_screen.dart';
import 'screens/splash_screen.dart'; // Added import for SplashScreen
import 'screens/inventory/demand_suggestions_screen.dart';
import 'package:background_fetch/background_fetch.dart';
import 'package:prostock/services/firestore/activity_service.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  GlobalErrorHandler.initialize();

  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);

  // Initialize TaxService
  await TaxService.initialize();

  final syncFailureProvider = SyncFailureProvider();
  final offlineManager = OfflineManager(syncFailureProvider);
  await offlineManager.initialize();

  final notificationService = NotificationService();
  await notificationService.init();
  // Request notification permissions just-in-time on startup.
  // This will prompt only on Android 13+ and on iOS; otherwise it's a no-op.
  await notificationService.requestPermission();

  final localDatabaseService = LocalDatabaseService.instance;
  final creditCheckService = CreditCheckService(
    localDatabaseService,
    notificationService,
  );

  await BackgroundSyncService.init(offlineManager, creditCheckService);

  runApp(
    MyApp(
      offlineManager: offlineManager,
      syncFailureProvider: syncFailureProvider,
    ),
  );
  BackgroundFetch.registerHeadlessTask(backgroundFetchHeadlessTask);
}

class MyApp extends StatelessWidget {
  const MyApp({
    super.key,
    required this.offlineManager,
    required this.syncFailureProvider,
  });
  final OfflineManager offlineManager;
  final SyncFailureProvider syncFailureProvider;

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        Provider<ActivityService>(
          create: (_) => ActivityService(FirebaseFirestore.instance),
        ),
        Provider<PricingService>(
          create: (_) => PricingService(FirebaseFirestore.instance),
        ),
        Provider<CreditService>(create: (_) => CreditService()),
        Provider<NotificationService>(create: (_) => NotificationService()),
        ChangeNotifierProvider.value(value: offlineManager),
        ChangeNotifierProvider.value(value: syncFailureProvider),
        ChangeNotifierProvider(
          create: (context) => AuthProvider(context.read<OfflineManager>()),
        ),
        ChangeNotifierProvider(create: (_) => ThemeProvider()),
        ChangeNotifierProvider(
          create: (context) => DemandProvider(
            DemandAnalysisService(
              LocalDatabaseService.instance,
              context.read<NotificationService>(),
            ),
          ),
        ),
        ChangeNotifierProvider(
          create: (context) => InventoryProvider(
            offlineManager: context.read<OfflineManager>(),
            authProvider: context.read<AuthProvider>(),
          ),
        ),
        ChangeNotifierProvider(
          create: (context) => CustomerProvider(context.read<OfflineManager>()),
        ),
        ChangeNotifierProxyProvider2<
          CustomerProvider,
          InventoryProvider,
          CreditProvider
        >(
          create: (context) => CreditProvider(
            customerProvider: context.read<CustomerProvider>(),
            inventoryProvider: context.read<InventoryProvider>(),
            creditService: context.read<CreditService>(),
          ),
          update:
              (
                context,
                customerProvider,
                inventoryProvider,
                previousCreditProvider,
              ) =>
                  previousCreditProvider ??
                  CreditProvider(
                    customerProvider: customerProvider,
                    inventoryProvider: inventoryProvider,
                    creditService: context.read<CreditService>(),
                  ),
        ),
        ChangeNotifierProxyProvider3<
          InventoryProvider,
          AuthProvider,
          CreditProvider,
          SalesProvider
        >(
          create: (context) => SalesProvider(
            inventoryProvider: context.read<InventoryProvider>(),
            offlineManager: context.read<OfflineManager>(),
            authProvider: context.read<AuthProvider>(),
            creditProvider: context.read<CreditProvider>(),
          ),
          update:
              (
                context,
                inventoryProvider,
                authProvider,
                creditProvider,
                previousSalesProvider,
              ) =>
                  previousSalesProvider ??
                  SalesProvider(
                    inventoryProvider: inventoryProvider,
                    offlineManager: context.read<OfflineManager>(),
                    authProvider: authProvider,
                    creditProvider: creditProvider,
                  ),
        ),
        ChangeNotifierProvider(create: (_) => StockMovementProvider()),
        ChangeNotifierProvider(create: (_) => PrintingService()),
        ChangeNotifierProvider(create: (_) => TaxService()),
      ],
      child: const RetailCreditApp(),
    );
  }
}

class RetailCreditApp extends StatefulWidget {
  const RetailCreditApp({super.key});

  @override
  State<RetailCreditApp> createState() => _RetailCreditAppState();
}

class _RetailCreditAppState extends State<RetailCreditApp> {
  @override
  Widget build(BuildContext context) {
    return Consumer<ThemeProvider>(
      builder: (context, themeProvider, child) {
        return MaterialApp(
          title: 'Retail Credit Manager',
          theme: ThemeData(
            primarySwatch: Colors.blue,
            useMaterial3: true,
            brightness: Brightness.light,
            colorScheme: ColorScheme.fromSeed(
              seedColor: Colors.blue,
              brightness: Brightness.light,
            ),
          ),
          darkTheme: ThemeData(
            brightness: Brightness.dark,
            colorScheme: ColorScheme.fromSeed(
              seedColor: Colors.blue,
              brightness: Brightness.dark,
              // Customize dark theme colors
              surface: Colors.grey[900],
              surfaceContainer: Colors.grey[850],
            ),
            cardColor: Colors.grey[800],
            useMaterial3: true,
            dialogTheme: DialogThemeData(backgroundColor: Colors.grey[800]),
          ),
          themeMode: themeProvider.themeMode,
          initialRoute: '/splash', // Changed initial route to SplashScreen
          routes: {
            '/splash': (context) =>
                const SplashScreen(), // Added SplashScreen route
            '/inventory/suggestions': (context) =>
                const DemandSuggestionsScreen(),
            '/admin': (context) => const AdminScreen(),
            '/login': (context) => const LoginScreen(),
            '/signup': (context) => const SignupScreen(),
            '/user': (context) => const UserScreen(),
            '/settings': (context) => const SettingsScreen(),
            '/change-password': (context) => const ChangePasswordScreen(),
            '/printer-settings': (context) => const PrinterSettingsScreen(),
          },
        );
      },
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\app_user.dart
â•‘ SIZE: 1.76 KB
â•‘ MODIFIED: 08/20/2025 08:10:09
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'user_role.dart';

class AppUser {
  String? id; // Changed from int to String for Firestore compatibility
  final String username;
  final String email;
  final String
  passwordHash; // Renamed from password to passwordHash for clarity
  final UserRole role;
  final DateTime createdAt;
  final bool isActive;

  AppUser({
    this.id,
    required this.username,
    required this.email,
    required this.passwordHash, // Now expects hashed password
    required this.role,
    required this.createdAt,
    this.isActive = true,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'username': username,
      'email': email,
      'password_hash': passwordHash, // Store as password_hash in database
      'role': role.name,
      'created_at': createdAt.toIso8601String(),
      'is_active': isActive,
    };
  }

  factory AppUser.fromMap(Map<String, dynamic> map) {
    return AppUser(
      id: map['id']?.toString(),
      username: map['username'],
      email: map['email'],
      passwordHash:
          map['password_hash'] ??
          map['password'], // Support both old and new field names
      role: UserRole.fromString(map['role']),
      createdAt: DateTime.parse(map['created_at']),
      isActive: map['is_active'] == true || map['is_active'] == 1,
    );
  }

  AppUser copyWith({
    String? id,
    String? username,
    String? email,
    String? passwordHash,
    UserRole? role,
    DateTime? createdAt,
    bool? isActive,
  }) {
    return AppUser(
      id: id ?? this.id,
      username: username ?? this.username,
      email: email ?? this.email,
      passwordHash: passwordHash ?? this.passwordHash,
      role: role ?? this.role,
      createdAt: createdAt ?? this.createdAt,
      isActive: isActive ?? this.isActive,
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\batch_allocation.dart
â•‘ SIZE: 1.03 KB
â•‘ MODIFIED: 10/25/2025 14:35:58
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Represents allocation of stock from a specific batch during a sale
/// Used internally by FIFO logic to track which batches contribute to a sale
class BatchAllocation {
  final String batchId;
  final String batchNumber;
  final int quantity;
  final double unitCost;
  final DateTime dateReceived;

  BatchAllocation({
    required this.batchId,
    required this.batchNumber,
    required this.quantity,
    required this.unitCost,
    required this.dateReceived,
  });

  double get totalCost => quantity * unitCost;

  @override
  String toString() {
    return 'BatchAllocation(batch: $batchNumber, qty: $quantity @ ₱$unitCost)';
  }
}

/// Exception thrown when there's insufficient stock across all batches
class InsufficientStockException implements Exception {
  final String message;
  final int requested;
  final int available;

  InsufficientStockException({
    required this.message,
    required this.requested,
    required this.available,
  });

  @override
  String toString() => message;
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\bluetooth_device.dart
â•‘ SIZE: 0.13 KB
â•‘ MODIFIED: 09/02/2025 16:39:22
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class BluetoothDevice {
  final String name;
  final String address;

  BluetoothDevice({required this.name, required this.address});
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\cost_history.dart
â•‘ SIZE: 1.35 KB
â•‘ MODIFIED: 10/04/2025 06:07:02
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:cloud_firestore/cloud_firestore.dart';

class CostHistory {
  final String id;
  final String productId;
  final double cost;
  final DateTime timestamp;

  CostHistory({
    required this.id,
    required this.productId,
    required this.cost,
    required this.timestamp,
  });

  // Factory constructor to create a CostHistory instance from a Firestore document
  factory CostHistory.fromFirestore(DocumentSnapshot doc) {
    Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
    return CostHistory(
      id: doc.id,
      productId: data['productId'] ?? '',
      cost: (data['cost'] as num?)?.toDouble() ?? 0.0,
      timestamp: (data['timestamp'] as Timestamp?)?.toDate() ?? DateTime.now(),
    );
  }

  // Method to convert a CostHistory instance to a map for Firestore
  Map<String, dynamic> toMap() {
    return {
      'productId': productId,
      'cost': cost,
      'timestamp': Timestamp.fromDate(timestamp),
    };
  }

  // Factory constructor to create a CostHistory instance from a map
  factory CostHistory.fromMap(Map<String, dynamic> data) {
    return CostHistory(
      id: data['id'] ?? '',
      productId: data['productId'] ?? '',
      cost: (data['cost'] as num?)?.toDouble() ?? 0.0,
      timestamp: (data['timestamp'] as Timestamp?)?.toDate() ?? DateTime.now(),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\credit_sale_item.dart
â•‘ SIZE: 1.55 KB
â•‘ MODIFIED: 10/25/2025 14:35:56
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/models/sale_item.dart';

class CreditSaleItem {
  final String productId;
  final String? batchId; // Batch ID for tracking
  final int quantity;
  final double unitPrice;
  final double unitCost; // Cost at time of sale (for accurate COGS)
  final double batchCost; // Original batch cost
  final double totalPrice;

  CreditSaleItem({
    required this.productId,
    this.batchId,
    required this.quantity,
    required this.unitPrice,
    required this.unitCost,
    double? batchCost,
    required this.totalPrice,
  }) : batchCost = batchCost ?? unitCost;

  factory CreditSaleItem.fromSaleItem(SaleItem saleItem) {
    return CreditSaleItem(
      productId: saleItem.productId,
      batchId: saleItem.batchId,
      quantity: saleItem.quantity,
      unitPrice: saleItem.unitPrice,
      unitCost: saleItem.unitCost,
      batchCost: saleItem.batchCost,
      totalPrice: saleItem.totalPrice,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'productId': productId,
      'batchId': batchId,
      'quantity': quantity,
      'unitPrice': unitPrice,
      'unitCost': unitCost,
      'batchCost': batchCost,
      'totalPrice': totalPrice,
    };
  }

  factory CreditSaleItem.fromMap(Map<String, dynamic> map) {
    return CreditSaleItem(
      productId: map['productId'],
      batchId: map['batchId']?.toString(),
      quantity: map['quantity'],
      unitPrice: map['unitPrice'],
      unitCost: map['unitCost'] ?? 0.0,
      batchCost: map['batchCost'] ?? map['unitCost'] ?? 0.0,
      totalPrice: map['totalPrice'],
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\credit_transaction.dart
â•‘ SIZE: 3.13 KB
â•‘ MODIFIED: 09/29/2025 07:51:45
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:cloud_firestore/cloud_firestore.dart';
import 'dart:convert';
import 'package:prostock/models/credit_sale_item.dart';

class CreditTransaction {
  final String? id;
  final String customerId;
  final double amount;
  final DateTime date;
  final String type; // e.g., 'payment', 'purchase'
  final String? notes;
  final List<CreditSaleItem> items;

  CreditTransaction({
    this.id,
    required this.customerId,
    required this.amount,
    required this.date,
    required this.type,
    this.notes,
    this.items = const [],
  });

  CreditTransaction copyWith({
    String? id,
    String? customerId,
    double? amount,
    DateTime? date,
    String? type,
    String? notes,
    List<CreditSaleItem>? items,
  }) {
    return CreditTransaction(
      id: id ?? this.id,
      customerId: customerId ?? this.customerId,
      amount: amount ?? this.amount,
      date: date ?? this.date,
      type: type ?? this.type,
      notes: notes ?? this.notes,
      items: items ?? this.items,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'customerId': customerId,
      'amount': amount,
      'date': Timestamp.fromDate(date),
      'createdAt': Timestamp.fromDate(
        date,
      ), // Add createdAt field for consistency
      'type': type,
      'notes': notes,
      'items': items.map((item) => item.toMap()).toList(),
    };
  }

  // Local-only map for SQLite/offline queue (no Firestore Timestamp types)
  Map<String, dynamic> toLocalMap() {
    return {
      'id': id,
      'customerId': customerId,
      'amount': amount,
      'date': date.toIso8601String(),
      'createdAt': date.toIso8601String(),
      'type': type,
      'notes': notes,
      // Persist as JSON string for SQLite
      'items': jsonEncode(items.map((item) => item.toMap()).toList()),
    };
  }

  factory CreditTransaction.fromMap(Map<String, dynamic> map, String id) {
    // Handle both 'date' and 'createdAt' fields for backward compatibility
    // Support both Timestamp and String formats
    DateTime? date;

    final dateValue = map['date'] ?? map['createdAt'];
    if (dateValue is Timestamp) {
      date = dateValue.toDate();
    } else if (dateValue is String) {
      try {
        date = DateTime.parse(dateValue);
      } catch (e) {
        date = DateTime.now();
      }
    } else {
      date = DateTime.now();
    }

    return CreditTransaction(
      id: id,
      customerId: map['customerId'] ?? '',
      amount: (map['amount'] ?? 0).toDouble(),
      date: date,
      type: map['type'] ?? '',
      notes: map['notes'] ?? '',
      items: _parseItems(map['items']),
    );
  }

  static List<CreditSaleItem> _parseItems(dynamic items) {
    if (items == null) return const [];

    // Handle Firestore format (List<dynamic>)
    if (items is List<dynamic>) {
      return items.map((item) => CreditSaleItem.fromMap(item)).toList();
    }

    // Handle SQLite format (JSON string)
    if (items is String) {
      try {
        final List<dynamic> itemsList = jsonDecode(items);
        return itemsList.map((item) => CreditSaleItem.fromMap(item)).toList();
      } catch (e) {
        return const [];
      }
    }

    return const [];
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\customer.dart
â•‘ SIZE: 4.2 KB
â•‘ MODIFIED: 09/19/2025 11:05:42
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/utils/app_constants.dart';
import 'package:uuid/uuid.dart';

class Customer {
  final String id;
  final String name;
  final String? phone;
  final String? email;
  final String? address;
  final String? imageUrl;
  final String? localImagePath;
  final double balance;
  final double creditLimit;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int version; // Add version field for conflict detection

  Customer({
    String? id,
    required this.name,
    this.phone,
    this.email,
    this.address,
    this.imageUrl,
    this.localImagePath,
    this.balance = 0,
    this.creditLimit = 0,
    required this.createdAt,
    required this.updatedAt,
    this.version = 1, // Default version
  }) : id = id ?? const Uuid().v4() {
    _validateCustomer();
  }

  void _validateCustomer() {
    if (name.trim().isEmpty) {
      throw ArgumentError('Customer name cannot be empty');
    }
    if (name.length > ValidationConstants.maxNameLength) {
      throw ArgumentError('Customer name cannot exceed 100 characters');
    }
    if (phone != null && phone!.isNotEmpty && !_isValidPhoneNumber(phone!)) {
      throw ArgumentError('Invalid phone number format');
    }
    if (email != null && email!.isNotEmpty && !_isValidEmail(email!)) {
      throw ArgumentError('Invalid email format');
    }
    if (address != null &&
        address!.length > ValidationConstants.maxDescriptionLength) {
      throw ArgumentError('Address cannot exceed 200 characters');
    }
    if (balance < 0) {
      throw ArgumentError('Balance cannot be negative');
    }
    if (creditLimit < 0) {
      throw ArgumentError('Credit limit cannot be negative');
    }
  }

  bool _isValidEmail(String email) {
    final emailRegex = RegExp(
      r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
    );
    return emailRegex.hasMatch(email);
  }

  bool _isValidPhoneNumber(String phone) {
    // Philippine phone number format validation
    final phoneRegex = RegExp(r'^(\+63|0)[0-9]{10}');
    return phoneRegex.hasMatch(phone.replaceAll(RegExp(r'[\s\-$]'), ''));
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'phone': phone,
      'email': email,
      'address': address,
      'imageUrl': imageUrl,
      'localImagePath': localImagePath,
      'balance': balance,
      'credit_limit': creditLimit,
      'created_at': createdAt.toIso8601String(),
      'updated_at': updatedAt.toIso8601String(),
      'version': version,
    };
  }

  factory Customer.fromMap(Map<String, dynamic> map) {
    return Customer(
      id: map['id']?.toString(),
      name: map['name'] ?? '',
      phone: map['phone']?.toString(),
      email: map['email']?.toString(),
      address: map['address']?.toString(),
      imageUrl: map['imageUrl']?.toString(),
      localImagePath: map['localImagePath']?.toString(),
      balance: (map['balance'] ?? 0).toDouble(),
      creditLimit: (map['credit_limit'] ?? 0).toDouble(),
      createdAt: DateTime.parse(
        map['created_at'] ?? DateTime.now().toIso8601String(),
      ),
      updatedAt: DateTime.parse(
        map['updated_at'] ?? DateTime.now().toIso8601String(),
      ),
      version: map['version'] ?? 1,
    );
  }

  Customer copyWith({
    String? id,
    String? name,
    String? phone,
    String? email,
    String? address,
    String? imageUrl,
    String? localImagePath,
    double? balance,
    double? creditLimit,
    DateTime? createdAt,
    DateTime? updatedAt,
    int? version,
  }) {
    return Customer(
      id: id ?? this.id,
      name: name ?? this.name,
      phone: phone ?? this.phone,
      email: email ?? this.email,
      address: address ?? this.address,
      imageUrl: imageUrl ?? this.imageUrl,
      localImagePath: localImagePath ?? this.localImagePath,
      balance: balance ?? this.balance,
      creditLimit: creditLimit ?? this.creditLimit,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      version: version ?? this.version,
    );
  }

  bool get hasUtang => balance > 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Customer && runtimeType == other.runtimeType && id == other.id;

  @override
  int get hashCode => id.hashCode;
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\inventory_batch.dart
â•‘ SIZE: 4.04 KB
â•‘ MODIFIED: 10/25/2025 14:35:58
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:uuid/uuid.dart';

class InventoryBatch {
  final String id;
  final String productId;
  final String batchNumber;
  final int quantityReceived;
  final int quantityRemaining;
  final double unitCost;
  final DateTime dateReceived;
  final String? supplierId;
  final String? notes;
  final DateTime createdAt;
  final DateTime updatedAt;

  InventoryBatch({
    String? id,
    required this.productId,
    required this.batchNumber,
    required this.quantityReceived,
    required this.quantityRemaining,
    required this.unitCost,
    required this.dateReceived,
    this.supplierId,
    this.notes,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) : id = id ?? const Uuid().v4(),
       createdAt = createdAt ?? DateTime.now(),
       updatedAt = updatedAt ?? DateTime.now() {
    _validateBatch();
  }

  void _validateBatch() {
    if (batchNumber.trim().isEmpty) {
      throw ArgumentError('Batch number cannot be empty');
    }
    if (quantityReceived <= 0) {
      throw ArgumentError('Quantity received must be greater than zero');
    }
    if (quantityRemaining < 0) {
      throw ArgumentError('Quantity remaining cannot be negative');
    }
    if (quantityRemaining > quantityReceived) {
      throw ArgumentError('Quantity remaining cannot exceed quantity received');
    }
    if (unitCost < 0) {
      throw ArgumentError('Unit cost cannot be negative');
    }
  }

  // Computed properties
  int get quantitySold => quantityReceived - quantityRemaining;
  bool get isDepleted => quantityRemaining <= 0;
  bool get hasStock => quantityRemaining > 0;
  double get totalValue => quantityRemaining * unitCost;
  double get soldValue => quantitySold * unitCost;

  // Percentage sold
  double get percentageSold {
    if (quantityReceived == 0) return 0;
    return (quantitySold / quantityReceived) * 100;
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'product_id': productId,
      'batch_number': batchNumber,
      'quantity_received': quantityReceived,
      'quantity_remaining': quantityRemaining,
      'unit_cost': unitCost,
      'date_received': dateReceived.toIso8601String(),
      'supplier_id': supplierId,
      'notes': notes,
      'created_at': createdAt.toIso8601String(),
      'updated_at': updatedAt.toIso8601String(),
    };
  }

  factory InventoryBatch.fromMap(Map<String, dynamic> map) {
    return InventoryBatch(
      id: map['id']?.toString(),
      productId: map['product_id']?.toString() ?? '',
      batchNumber: map['batch_number']?.toString() ?? '',
      quantityReceived: map['quantity_received'] ?? 0,
      quantityRemaining: map['quantity_remaining'] ?? 0,
      unitCost: (map['unit_cost'] ?? 0).toDouble(),
      dateReceived: DateTime.parse(map['date_received']),
      supplierId: map['supplier_id']?.toString(),
      notes: map['notes']?.toString(),
      createdAt: DateTime.parse(map['created_at']),
      updatedAt: DateTime.parse(map['updated_at']),
    );
  }

  InventoryBatch copyWith({
    String? id,
    String? productId,
    String? batchNumber,
    int? quantityReceived,
    int? quantityRemaining,
    double? unitCost,
    DateTime? dateReceived,
    String? supplierId,
    String? notes,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return InventoryBatch(
      id: id ?? this.id,
      productId: productId ?? this.productId,
      batchNumber: batchNumber ?? this.batchNumber,
      quantityReceived: quantityReceived ?? this.quantityReceived,
      quantityRemaining: quantityRemaining ?? this.quantityRemaining,
      unitCost: unitCost ?? this.unitCost,
      dateReceived: dateReceived ?? this.dateReceived,
      supplierId: supplierId ?? this.supplierId,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  String toString() {
    return 'InventoryBatch(id: $id, batch: $batchNumber, remaining: $quantityRemaining/$quantityReceived @ ₱$unitCost)';
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\loss.dart
â•‘ SIZE: 1.57 KB
â•‘ MODIFIED: 09/18/2025 23:56:29
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/models/loss_reason.dart';

class Loss {
  final String? id;
  final String productId;
  final int quantity;
  final double totalCost;
  final LossReason reason;
  final DateTime timestamp;
  final String? recordedBy;

  Loss({
    this.id,
    required this.productId,
    required this.quantity,
    required this.totalCost,
    required this.reason,
    required this.timestamp,
    this.recordedBy,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'productId': productId,
      'quantity': quantity,
      'totalCost': totalCost,
      'reason': reason.name, // Use enum name
      'timestamp': timestamp.toIso8601String(),
      'recordedBy': recordedBy,
    };
  }

  factory Loss.fromMap(Map<String, dynamic> map) {
    return Loss(
      id: map['id'],
      productId: map['productId'],
      quantity: map['quantity'],
      totalCost: map['totalCost'],
      reason: LossReason.values.firstWhere((e) => e.name == map['reason']), // Convert from name
      timestamp: DateTime.parse(map['timestamp']),
      recordedBy: map['recordedBy'],
    );
  }

  Loss copyWith({
    String? id,
    String? productId,
    int? quantity,
    double? totalCost,
    LossReason? reason,
    DateTime? timestamp,
    String? recordedBy,
  }) {
    return Loss(
      id: id ?? this.id,
      productId: productId ?? this.productId,
      quantity: quantity ?? this.quantity,
      totalCost: totalCost ?? this.totalCost,
      reason: reason ?? this.reason,
      timestamp: timestamp ?? this.timestamp,
      recordedBy: recordedBy ?? this.recordedBy,
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\loss_reason.dart
â•‘ SIZE: 0.38 KB
â•‘ MODIFIED: 09/18/2025 23:53:52
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

enum LossReason {
  damaged,
  expired,
  stolen,
  other,
}

extension LossReasonExtension on LossReason {
  String toDisplayString() {
    switch (this) {
      case LossReason.damaged:
        return 'Damaged';
      case LossReason.expired:
        return 'Expired';
      case LossReason.stolen:
        return 'Stolen';
      case LossReason.other:
        return 'Other';
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\offline_operation.dart
â•‘ SIZE: 2.95 KB
â•‘ MODIFIED: 10/04/2025 06:07:02
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:convert';
import 'package:uuid/uuid.dart';

/// Operation Type Enumeration - Defines all supported offline operations
enum OperationType {
  insertProduct,
  updateProduct,
  insertCustomer,
  updateCustomer,
  deleteCustomer,
  createSaleTransaction,
  insertCreditTransaction,
  updateCustomerBalance,
  insertLoss,
  insertPriceHistory,
  insertCostHistory,
  insertStockMovement,
  logActivity, // Added for offline activity logging
}

/// Offline Operation Model - Serializable operation container
///
/// OPERATION STRUCTURE:
/// - Unique ID for deduplication and tracking
/// - Operation type for proper execution routing
/// - Serialized data payload with all necessary information
/// - Timestamp for chronological processing and conflict resolution
class OfflineOperation {
  final int? dbId;
  final String id;
  final OperationType type;
  final String collectionName;
  final String? documentId;
  final Map<String, dynamic> data;
  final DateTime timestamp;
  final int retryCount;
  final int? version;

  OfflineOperation({
    this.dbId,
    String? id,
    required this.type,
    required this.collectionName,
    this.documentId,
    required this.data,
    required this.timestamp,
    this.retryCount = 0,
    this.version,
  }) : id = id ?? const Uuid().v4();

  OfflineOperation copyWith({
    int? dbId,
    String? id,
    OperationType? type,
    String? collectionName,
    String? documentId,
    Map<String, dynamic>? data,
    DateTime? timestamp,
    int? retryCount,
    int? version,
  }) {
    return OfflineOperation(
      dbId: dbId ?? this.dbId,
      id: id ?? this.id,
      type: type ?? this.type,
      collectionName: collectionName ?? this.collectionName,
      documentId: documentId ?? this.documentId,
      data: data ?? this.data,
      timestamp: timestamp ?? this.timestamp,
      retryCount: retryCount ?? this.retryCount,
      version: version ?? this.version,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'operation_id': id,
      'operation_type': type.toString().split('.').last,
      'collection_name': collectionName,
      'document_id': documentId,
      'data': jsonEncode(data),
      'timestamp': timestamp.toIso8601String(),
      'retry_count': retryCount,
      'version': version,
    };
  }

  factory OfflineOperation.fromMap(Map<String, dynamic> map) {
    return OfflineOperation(
      dbId: map['id'] as int,
      id: map['operation_id'] as String,
      type: OperationType.values.firstWhere(
        (e) => e.toString().split('.').last == map['operation_type'],
      ),
      collectionName: map['collection_name'] as String,
      documentId: map['document_id'] as String?,
      data: jsonDecode(map['data'] as String) as Map<String, dynamic>,
      timestamp: DateTime.parse(map['timestamp'] as String),
      retryCount: map['retry_count'] ?? 0,
      version: map['version'] as int?,
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\paginated_result.dart
â•‘ SIZE: 0.22 KB
â•‘ MODIFIED: 08/17/2025 13:21:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:cloud_firestore/cloud_firestore.dart';

class PaginatedResult<T> {
  final List<T> items;
  final DocumentSnapshot? lastDocument;

  PaginatedResult({
    required this.items,
    this.lastDocument,
  });
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\price_history.dart
â•‘ SIZE: 0.96 KB
â•‘ MODIFIED: 08/25/2025 10:16:46
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:cloud_firestore/cloud_firestore.dart';

class PriceHistory {
  final String id;
  final String productId;
  final double price;
  final DateTime timestamp;

  PriceHistory({
    required this.id,
    required this.productId,
    required this.price,
    required this.timestamp,
  });

  // Factory constructor to create a PriceHistory instance from a Firestore document
  factory PriceHistory.fromFirestore(DocumentSnapshot doc) {
    Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
    return PriceHistory(
      id: doc.id,
      productId: data['productId'] ?? '',
      price: (data['price'] as num?)?.toDouble() ?? 0.0,
      timestamp: (data['timestamp'] as Timestamp?)?.toDate() ?? DateTime.now(),
    );
  }

  // Method to convert a PriceHistory instance to a map for Firestore
  Map<String, dynamic> toMap() {
    return {
      'productId': productId,
      'price': price,
      'timestamp': Timestamp.fromDate(timestamp),
    };
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\product.dart
â•‘ SIZE: 4.04 KB
â•‘ MODIFIED: 10/25/2025 14:35:58
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/utils/app_constants.dart';

class Product {
  final String? id;
  final String name;
  final String? barcode;
  final double cost;
  final double?
  sellingPrice; // Fixed selling price (overrides calculated price)
  final int stock;
  final int minStock;
  final String? category;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int version;

  Product({
    this.id,
    required this.name,
    this.barcode,
    required this.cost,
    this.sellingPrice,
    required this.stock,
    this.minStock = 5,
    this.category,
    required this.createdAt,
    required this.updatedAt,
    this.version = 1,
  }) {
    _validateProduct();
  }

  // Price calculation moved to UI level using TaxService
  // This allows dynamic tax rate configuration

  void _validateProduct() {
    if (name.trim().isEmpty) {
      throw ArgumentError('Product name cannot be empty');
    }
    if (name.length > ValidationConstants.maxNameLength) {
      throw ArgumentError('Product name cannot exceed 100 characters');
    }
    if (cost < 0) {
      throw ArgumentError('Product cost cannot be negative');
    }
    if (sellingPrice != null && sellingPrice! < 0) {
      throw ArgumentError('Selling price cannot be negative');
    }
    if (stock < 0) {
      throw ArgumentError('Product stock cannot be negative');
    }
    if (minStock < 0) {
      throw ArgumentError('Minimum stock cannot be negative');
    }
    if (barcode != null && barcode!.isNotEmpty) {
      if (!_isValidBarcode(barcode!)) {
        throw ArgumentError('Invalid barcode format');
      }
    }
    if (category != null &&
        category!.length > ValidationConstants.maxCategoryLength) {
      throw ArgumentError('Category name cannot exceed 50 characters');
    }
  }

  bool _isValidBarcode(String barcode) {
    // Basic barcode validation - alphanumeric, 8-13 characters
    final barcodeRegex = RegExp(r'^[A-Za-z0-9]{8,13}');
    return barcodeRegex.hasMatch(barcode);
  }

  // Price-dependent methods moved to UI level using TaxService
  // This allows dynamic tax rate configuration

  /// Get the actual selling price to use (manual override or calculated)
  double getPriceForSale(double calculatedPrice) {
    return sellingPrice ?? calculatedPrice;
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'barcode': barcode,
      'cost': cost,
      'selling_price': sellingPrice,
      'stock': stock,
      'min_stock': minStock,
      'category': category,
      'created_at': createdAt.toIso8601String(),
      'updated_at': updatedAt.toIso8601String(),
      'version': version,
    };
  }

  factory Product.fromMap(Map<String, dynamic> map) {
    return Product(
      id: map['id']?.toString(),
      name: map['name'],
      barcode: map['barcode'],
      cost: map['cost'].toDouble(),
      sellingPrice: map['selling_price'] != null
          ? (map['selling_price'] as num).toDouble()
          : null,
      stock: map['stock'],
      minStock: map['min_stock'] ?? 5,
      category: map['category'],
      createdAt: DateTime.parse(map['created_at']),
      updatedAt: DateTime.parse(map['updated_at']),
      version: map['version'] ?? 1,
    );
  }

  Product copyWith({
    String? id,
    String? name,
    String? barcode,
    double? cost,
    double? sellingPrice,
    int? stock,
    int? minStock,
    String? category,
    DateTime? createdAt,
    DateTime? updatedAt,
    int? version,
  }) {
    return Product(
      id: id ?? this.id,
      name: name ?? this.name,
      barcode: barcode ?? this.barcode,
      cost: cost ?? this.cost,
      sellingPrice: sellingPrice ?? this.sellingPrice,
      stock: stock ?? this.stock,
      minStock: minStock ?? this.minStock,
      category: category ?? this.category,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      version: version ?? this.version,
    );
  }

  bool get isLowStock => stock <= minStock;
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\receipt.dart
â•‘ SIZE: 1.07 KB
â•‘ MODIFIED: 09/21/2025 20:52:13
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Receipt {
  final String saleId;
  final String receiptNumber;
  final DateTime timestamp;
  final String? customerName;
  final String paymentMethod;
  final List<ReceiptItem> items;
  final double subtotal;
  final double tax;
  final double total;

  Receipt({
    required this.saleId,
    required this.receiptNumber,
    required this.timestamp,
    this.customerName,
    required this.paymentMethod,
    required this.items,
    required this.subtotal,
    this.tax = 0.0,
    required this.total,
  });

  String get formattedReceiptNumber => 'RCP-${receiptNumber.padLeft(6, '0')}';
  String get formattedTimestamp =>
      '${timestamp.day}/${timestamp.month}/${timestamp.year} ${timestamp.hour.toString().padLeft(2, '0')}:${timestamp.minute.toString().padLeft(2, '0')}';
}

class ReceiptItem {
  final String productName;
  final int quantity;
  final double unitPrice;
  final double totalPrice;

  ReceiptItem({
    required this.productName,
    required this.quantity,
    required this.unitPrice,
    required this.totalPrice,
  });
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\sale.dart
â•‘ SIZE: 5.18 KB
â•‘ MODIFIED: 10/03/2025 16:44:52
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/utils/app_constants.dart';

class Sale {
  late final String? id;
  final String userId;
  final String? customerId;
  final double totalAmount;
  final String paymentMethod;
  final String status;
  final DateTime createdAt;
  final DateTime? dueDate;
  final int isSynced;

  Sale({
    this.id,
    required this.userId,
    this.customerId,
    required this.totalAmount,
    required this.paymentMethod,
    required this.status,
    required this.createdAt,
    this.dueDate,
    this.isSynced = AppDefaults.notSynced,
  }) {
    _validateSale();
  }

  void _validateSale() {
    if (totalAmount <= 0) {
      throw ArgumentError('Total amount must be greater than zero');
    }
    if (totalAmount > ValidationConstants.maxTransactionAmount) {
      throw ArgumentError('Total amount cannot exceed ₱1,000,000');
    }
    if (!_isValidPaymentMethod(paymentMethod)) {
      throw ArgumentError('Invalid payment method');
    }
    if (!_isValidStatus(status)) {
      throw ArgumentError('Invalid sale status');
    }
    if (paymentMethod == 'credit' && dueDate == null) {
      throw ArgumentError('Due date is required for credit sales');
    }
  }

  bool _isValidPaymentMethod(String method) {
    const validMethods = [
      'cash',
      'credit',
      'card',
      'gcash',
      'paymaya',
      // Special methods for customer debt settlements recorded as sales
      'credit_payment',
      'debt_payment',
      'credit payment', // backward-compat for spaced label
      'debt payment',
    ];
    return validMethods.contains(method.toLowerCase());
  }

  bool _isValidStatus(String saleStatus) {
    const validStatuses = ['pending', 'completed', 'cancelled', 'refunded'];
    return validStatuses.contains(saleStatus.toLowerCase());
  }

  bool get isCompleted => status.toLowerCase() == 'completed';
  bool get isPending => status.toLowerCase() == 'pending';
  bool get canBeModified => status.toLowerCase() == 'pending';

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'user_id': userId,
      'customer_id': customerId,
      'total_amount': totalAmount,
      'payment_method': paymentMethod,
      'status': status,
      'created_at': createdAt.toIso8601String(),
      'due_date': dueDate?.toIso8601String(),
      'is_synced': isSynced,
    };
  }

  factory Sale.fromMap(Map<String, dynamic> map) {
    // Support both snake_case (local DB) and camelCase (Firestore) field names
    final dynamic totalAmountRaw = map['total_amount'] ?? map['totalAmount'];
    if (totalAmountRaw == null) {
      throw ArgumentError('Total amount cannot be null');
    }

    final String userId = (map['user_id'] ?? map['userId'] ?? '').toString();
    final String? customerId = (map['customer_id'] ?? map['customerId'])
        ?.toString();
    final String paymentMethod =
        (map['payment_method'] ?? map['paymentMethod'] ?? '').toString();
    final String status = (map['status'] ?? 'pending').toString();

    // createdAt may be an ISO string (local) or a Firestore Timestamp
    final dynamic createdAtRaw = map['created_at'] ?? map['createdAt'];
    DateTime createdAt;
    if (createdAtRaw == null) {
      createdAt = DateTime.now();
    } else if (createdAtRaw is DateTime) {
      createdAt = createdAtRaw;
    } else if (createdAtRaw is String) {
      createdAt = DateTime.parse(createdAtRaw);
    } else {
      // Attempt to call toDate() if it's a Firestore Timestamp-like object
      try {
        createdAt = createdAtRaw.toDate();
      } catch (_) {
        createdAt = DateTime.now();
      }
    }

    // dueDate may be ISO string or Firestore Timestamp or null
    final dynamic dueDateRaw = map['due_date'] ?? map['dueDate'];
    DateTime? dueDate;
    if (dueDateRaw == null) {
      dueDate = null;
    } else if (dueDateRaw is DateTime) {
      dueDate = dueDateRaw;
    } else if (dueDateRaw is String) {
      dueDate = DateTime.parse(dueDateRaw);
    } else {
      try {
        dueDate = dueDateRaw.toDate();
      } catch (_) {
        dueDate = null;
      }
    }

    final int isSynced =
        (map['is_synced'] ?? map['isSynced'] ?? AppDefaults.notSynced) as int;

    return Sale(
      id: map['id']?.toString(),
      userId: userId,
      customerId: customerId,
      totalAmount: (totalAmountRaw as num).toDouble(),
      paymentMethod: paymentMethod,
      status: status,
      createdAt: createdAt,
      dueDate: dueDate,
      isSynced: isSynced,
    );
  }

  Sale copyWith({
    String? id,
    String? userId,
    String? customerId,
    double? totalAmount,
    String? paymentMethod,
    String? status,
    DateTime? createdAt,
    DateTime? dueDate,
    int? isSynced,
  }) {
    return Sale(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      customerId: customerId ?? this.customerId,
      totalAmount: totalAmount ?? this.totalAmount,
      paymentMethod: paymentMethod ?? this.paymentMethod,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      dueDate: dueDate ?? this.dueDate,
      isSynced: isSynced ?? this.isSynced,
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\sale_item.dart
â•‘ SIZE: 3.1 KB
â•‘ MODIFIED: 10/25/2025 14:35:56
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/utils/app_constants.dart';
import 'package:uuid/uuid.dart';

class SaleItem {
  final String id;
  late final String saleId;
  final String productId;
  final String? batchId; // NEW: Which batch this item came from
  final int quantity;
  final double unitPrice;
  final double unitCost; // Cost at time of sale (for accurate COGS)
  final double
  batchCost; // NEW: Original batch cost (same as unitCost for FIFO)
  final double totalPrice;

  SaleItem({
    String? id,
    required this.saleId,
    required this.productId,
    this.batchId,
    required this.quantity,
    required this.unitPrice,
    required this.unitCost,
    double? batchCost,
    required this.totalPrice,
  }) : id = id ?? const Uuid().v4(),
       batchCost = batchCost ?? unitCost {
    _validateSaleItem();
  }

  void _validateSaleItem() {
    if (quantity <= 0) {
      throw ArgumentError('Quantity must be greater than zero');
    }
    if (quantity > ValidationConstants.maxSaleQuantity) {
      throw ArgumentError('Quantity cannot exceed 1000 items');
    }
    if (unitPrice <= 0) {
      throw ArgumentError('Unit price must be greater than zero');
    }
    if (unitCost < 0) {
      throw ArgumentError('Unit cost cannot be negative');
    }
    if (totalPrice <= 0) {
      throw ArgumentError('Total price must be greater than zero');
    }
    // Validate that totalPrice matches quantity * unitPrice
    final expectedTotal = quantity * unitPrice;
    if ((totalPrice - expectedTotal).abs() > 0.01) {
      throw ArgumentError('Total price does not match quantity × unit price');
    }
  }

  bool get isValidCalculation =>
      (totalPrice - (quantity * unitPrice)).abs() <= 0.01;

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'saleId': saleId,
      'productId': productId,
      'batchId': batchId,
      'quantity': quantity,
      'unitPrice': unitPrice,
      'unitCost': unitCost,
      'batchCost': batchCost,
      'totalPrice': totalPrice,
    };
  }

  factory SaleItem.fromMap(Map<String, dynamic> map) {
    return SaleItem(
      id: map['id']?.toString(),
      saleId: map['saleId']?.toString() ?? '',
      productId: map['productId']?.toString() ?? '',
      batchId: map['batchId']?.toString(),
      quantity: map['quantity'] ?? 0,
      unitPrice: (map['unitPrice'] ?? 0).toDouble(),
      unitCost: (map['unitCost'] ?? 0).toDouble(),
      batchCost: (map['batchCost'] ?? map['unitCost'] ?? 0).toDouble(),
      totalPrice: (map['totalPrice'] ?? 0).toDouble(),
    );
  }

  SaleItem copyWith({
    String? id,
    String? saleId,
    String? productId,
    String? batchId,
    int? quantity,
    double? unitPrice,
    double? unitCost,
    double? batchCost,
    double? totalPrice,
  }) {
    return SaleItem(
      id: id ?? this.id,
      saleId: saleId ?? this.saleId,
      productId: productId ?? this.productId,
      batchId: batchId ?? this.batchId,
      quantity: quantity ?? this.quantity,
      unitPrice: unitPrice ?? this.unitPrice,
      unitCost: unitCost ?? this.unitCost,
      batchCost: batchCost ?? this.batchCost,
      totalPrice: totalPrice ?? this.totalPrice,
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\stock_movement.dart
â•‘ SIZE: 1.42 KB
â•‘ MODIFIED: 08/28/2025 19:08:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:cloud_firestore/cloud_firestore.dart';

class StockMovement {
  final String id;
  final String productId;
  final String productName; // Denormalized for easier display
  final String movementType; // e.g., 'sale', 'stock_in', 'adjustment'
  final int quantity; // Can be positive or negative
  final String? reason;
  final DateTime createdAt;

  StockMovement({
    required this.id,
    required this.productId,
    required this.productName,
    required this.movementType,
    required this.quantity,
    this.reason,
    required this.createdAt,
  });

  factory StockMovement.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return StockMovement(
      id: doc.id,
      productId: data['productId'] ?? '',
      productName: data['productName'] ?? 'Unknown Product',
      movementType: data['movementType'] ?? 'unknown',
      quantity: data['quantity'] ?? 0,
      reason: data['reason'],
      createdAt: (data['createdAt'] as Timestamp).toDate(),
    );
  }

  factory StockMovement.fromMap(Map<String, dynamic> data) {
    return StockMovement(
      id: data['id'] ?? '',
      productId: data['productId'] ?? '',
      productName: data['productName'] ?? 'Unknown Product',
      movementType: data['movementType'] ?? 'unknown',
      quantity: data['quantity'] ?? 0,
      reason: data['reason'],
      createdAt: (data['createdAt'] as Timestamp).toDate(),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\stock_update_result.dart
â•‘ SIZE: 0.14 KB
â•‘ MODIFIED: 08/23/2025 20:55:07
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class StockUpdateResult {
  final int quantity;
  final String reason;

  StockUpdateResult({required this.quantity, required this.reason});
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\sync_failure.dart
â•‘ SIZE: 0.2 KB
â•‘ MODIFIED: 08/31/2025 20:55:43
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/models/offline_operation.dart';

class SyncFailure {
  final OfflineOperation operation;
  final String error;

  SyncFailure({required this.operation, required this.error});
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\tax_rule.dart
â•‘ SIZE: 2.87 KB
â•‘ MODIFIED: 10/03/2025 23:26:18
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:cloud_firestore/cloud_firestore.dart';

class TaxRule {
  final String id;
  final String? categoryName; // null for global rule
  final String? productId; // null for category/global rule
  final double tubo; // Fixed tubo amount in pesos
  final bool isInclusive;
  final int priority; // Higher number = higher priority
  final DateTime createdAt;
  final DateTime updatedAt;

  TaxRule({
    required this.id,
    this.categoryName,
    this.productId,
    required this.tubo,
    required this.isInclusive,
    required this.priority,
    required this.createdAt,
    required this.updatedAt,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'categoryName': categoryName,
      'productId': productId,
      'tubo': tubo,
      'isInclusive': isInclusive,
      'priority': priority,
      'createdAt': createdAt.millisecondsSinceEpoch,
      'updatedAt': updatedAt.millisecondsSinceEpoch,
    };
  }

  factory TaxRule.fromMap(Map<String, dynamic> map) {
    DateTime parseDate(dynamic v) {
      if (v is int) return DateTime.fromMillisecondsSinceEpoch(v);
      if (v is Timestamp) return v.toDate();
      if (v is String) {
        final n = int.tryParse(v);
        if (n != null) return DateTime.fromMillisecondsSinceEpoch(n);
        return DateTime.tryParse(v) ?? DateTime.fromMillisecondsSinceEpoch(0);
      }
      return DateTime.fromMillisecondsSinceEpoch(0);
    }

    return TaxRule(
      id: map['id'] ?? '',
      categoryName: map['categoryName'],
      productId: map['productId'],
      tubo: (map['tubo'] ?? map['rate'] ?? 2.0)
          .toDouble(), // Support both old and new field names
      isInclusive: false, // Inclusive disabled, always added on top
      priority: map['priority'] ?? 0,
      createdAt: parseDate(map['createdAt']),
      updatedAt: parseDate(map['updatedAt']),
    );
  }

  TaxRule copyWith({
    String? id,
    String? categoryName,
    String? productId,
    double? tubo,
    bool? isInclusive,
    int? priority,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return TaxRule(
      id: id ?? this.id,
      categoryName: categoryName ?? this.categoryName,
      productId: productId ?? this.productId,
      tubo: tubo ?? this.tubo,
      isInclusive: isInclusive ?? this.isInclusive,
      priority: priority ?? this.priority,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  bool get isGlobal => categoryName == null && productId == null;
  bool get isCategory => categoryName != null && productId == null;
  bool get isProduct => productId != null;

  String get description {
    if (isProduct) {
      return 'Product-specific rule';
    } else if (isCategory) {
      return 'Category: $categoryName';
    } else {
      return 'Global rule';
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\tax_settings_history.dart
â•‘ SIZE: 2.16 KB
â•‘ MODIFIED: 09/29/2025 13:33:50
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class TaxSettingsHistory {
  final String id;
  final String changedByUserId;
  final String changedByUserName;
  final double? oldAmount;
  final double? newAmount;
  final bool? oldInclusive;
  final bool? newInclusive;
  final DateTime timestamp;
  final String source; // 'settings_screen', 'api', 'admin', etc.

  TaxSettingsHistory({
    required this.id,
    required this.changedByUserId,
    required this.changedByUserName,
    this.oldAmount,
    this.newAmount,
    this.oldInclusive,
    this.newInclusive,
    required this.timestamp,
    required this.source,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'changedByUserId': changedByUserId,
      'changedByUserName': changedByUserName,
      'oldAmount': oldAmount,
      'newAmount': newAmount,
      'oldInclusive': oldInclusive,
      'newInclusive': newInclusive,
      'timestamp': timestamp.millisecondsSinceEpoch,
      'source': source,
    };
  }

  factory TaxSettingsHistory.fromMap(Map<String, dynamic> map) {
    return TaxSettingsHistory(
      id: map['id'] ?? '',
      changedByUserId: map['changedByUserId'] ?? '',
      changedByUserName: map['changedByUserName'] ?? '',
      oldAmount: map['oldAmount']?.toDouble() ?? map['oldRate']?.toDouble(),
      newAmount: map['newAmount']?.toDouble() ?? map['newRate']?.toDouble(),
      oldInclusive: map['oldInclusive'],
      newInclusive: map['newInclusive'],
      timestamp: DateTime.fromMillisecondsSinceEpoch(map['timestamp'] ?? 0),
      source: map['source'] ?? '',
    );
  }

  String get changeDescription {
    final changes = <String>[];

    if (oldAmount != null && newAmount != null && oldAmount != newAmount) {
      changes.add(
        'Tubo: ₱${oldAmount!.toStringAsFixed(2)} → ₱${newAmount!.toStringAsFixed(2)}',
      );
    }

    if (oldInclusive != null &&
        newInclusive != null &&
        oldInclusive != newInclusive) {
      changes.add(
        'Method: ${oldInclusive! ? "Inclusive" : "Added on Top"} → ${newInclusive! ? "Inclusive" : "Added on Top"}',
      );
    }

    return changes.isEmpty ? 'No changes' : changes.join(', ');
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\update_result.dart
â•‘ SIZE: 0.99 KB
â•‘ MODIFIED: 09/19/2025 11:05:42
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/models/product.dart';
import 'package:prostock/models/customer.dart';

class UpdateResult {
  final bool success;
  final Conflict? conflict;

  UpdateResult({required this.success, this.conflict});
}

class Conflict {
  final dynamic localData;
  final dynamic remoteData;
  final ConflictType type;

  Conflict({
    required this.localData,
    required this.remoteData,
    required this.type,
  });

  // Factory constructors for different conflict types
  factory Conflict.product({
    required Product localProduct,
    required Product remoteProduct,
  }) {
    return Conflict(
      localData: localProduct,
      remoteData: remoteProduct,
      type: ConflictType.product,
    );
  }

  factory Conflict.customer({
    required Customer localCustomer,
    required Customer remoteCustomer,
  }) {
    return Conflict(
      localData: localCustomer,
      remoteData: remoteCustomer,
      type: ConflictType.customer,
    );
  }
}

enum ConflictType { product, customer }




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\user_activity.dart
â•‘ SIZE: 1.18 KB
â•‘ MODIFIED: 09/09/2025 22:49:15
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class UserActivity {
  final String? id;
  final String userId;
  final String action;
  final String? productName;
  final String? productBarcode;
  final int? quantity;
  final double? amount;
  final String? details;
  final DateTime timestamp;

  UserActivity({
    this.id,
    required this.userId,
    required this.action,
    this.productName,
    this.productBarcode,
    this.quantity,
    this.amount,
    this.details,
    required this.timestamp,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'user_id': userId,
      'action': action,
      'product_name': productName,
      'product_barcode': productBarcode,
      'quantity': quantity,
      'amount': amount,
      'details': details,
      'timestamp': timestamp.toIso8601String(),
    };
  }

  factory UserActivity.fromMap(Map<String, dynamic> map) {
    return UserActivity(
      id: map['id'],
      userId: map['user_id'],
      action: map['action'],
      productName: map['product_name'],
      productBarcode: map['product_barcode'],
      quantity: map['quantity'],
      amount: map['amount']?.toDouble(),
      details: map['details'],
      timestamp: DateTime.parse(map['timestamp']),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\models\user_role.dart
â•‘ SIZE: 0.44 KB
â•‘ MODIFIED: 08/14/2025 09:01:27
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

enum UserRole {
  admin,
  user;

  String get displayName {
    switch (this) {
      case UserRole.admin:
        return 'Admin';
      case UserRole.user:
        return 'User';
    }
  }

  static UserRole fromString(String role) {
    switch (role.toLowerCase()) {
      case 'admin':
        return UserRole.admin;
      case 'user':
        return UserRole.user;
      default:
        return UserRole.user;
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\providers\auth_provider.dart
â•‘ SIZE: 16.45 KB
â•‘ MODIFIED: 10/02/2025 17:06:21
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';

import 'package:prostock/models/offline_operation.dart';
import 'package:prostock/services/offline_manager.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/app_user.dart';
import '../models/user_role.dart';
import '../models/user_activity.dart';
import 'package:prostock/services/firestore/user_service.dart';
import 'package:prostock/services/firestore/activity_service.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../utils/password_helper.dart';
import '../utils/error_logger.dart'; // Added ErrorLogger import for consistent logging
import '../utils/auth_error_handler.dart';

class AuthProvider with ChangeNotifier {
  final FirebaseAuth _firebaseAuth = FirebaseAuth.instance;
  final UserService _userService = UserService(
    FirebaseFirestore.instance,
    FirebaseAuth.instance,
  );
  final ActivityService _activityService = ActivityService(
    FirebaseFirestore.instance,
  );
  final OfflineManager _offlineManager;

  bool _isAuthenticated = false;
  AppUser? _currentUser;
  User? _firebaseUser;

  AuthProvider(this._offlineManager);

  bool get isAuthenticated => _isAuthenticated;
  AppUser? get currentUser => _currentUser;
  User? get firebaseUser => _firebaseUser;
  String? get username => _currentUser?.username;
  UserRole? get userRole => _currentUser?.role;
  bool get isAdmin => _currentUser?.role == UserRole.admin;

  String? _error;
  String? get error => _error;

  Map<String, String> _fieldErrors = {};
  Map<String, String> get fieldErrors => _fieldErrors;

  void clearFieldErrors() {
    _fieldErrors.clear();
    notifyListeners();
  }

  Future<bool> login(String email, String password) async {
    try {
      // Clear previous errors
      _error = null;
      _fieldErrors.clear();

      final credential = await _firebaseAuth.signInWithEmailAndPassword(
        email: email.trim(),
        password: password,
      );

      if (credential.user != null) {
        if (!credential.user!.emailVerified) {
          await _firebaseAuth.signOut();
          _error = 'Please verify your email before logging in.';
          return false;
        }

        final user = await _userService.getUserByEmail(email.trim());
        if (user != null) {
          _isAuthenticated = true;
          _currentUser = user;
          _firebaseUser = credential.user;

          // Save to SharedPreferences
          final prefs = await SharedPreferences.getInstance();
          await prefs.setBool('isAuthenticated', true);
          await prefs.setString('userId', user.id.toString());
          await prefs.setString('username', user.username);
          await prefs.setString('userRole', user.role.name);

          await logActivity('LOGIN', details: 'User logged in');

          notifyListeners();
          return true;
        }
      }
      _error = 'Login failed. Please check your credentials.';
      return false;
    } on FirebaseAuthException catch (e) {
      _error = AuthErrorHandler.getLoginErrorMessage(e);
      _fieldErrors = AuthErrorHandler.getFieldSpecificError(e);
      ErrorLogger.logError(
        'Error during login',
        error: e,
        context: 'AuthProvider.login',
      );
      return false;
    } catch (e) {
      _error = 'An unexpected error occurred. Please try again.';
      ErrorLogger.logError(
        'Unexpected error during login',
        error: e,
        context: 'AuthProvider.login',
      );
      return false;
    }
  }

  Future<void> logout() async {
    try {
      if (_currentUser != null) {
        await logActivity('LOGOUT', details: 'User logged out');
      }

      await _firebaseAuth.signOut();

      _isAuthenticated = false;
      _currentUser = null;
      _firebaseUser = null;

      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('isAuthenticated');
      await prefs.remove('userId');
      await prefs.remove('username');
      await prefs.remove('userRole');

      notifyListeners();
    } catch (e) {
      ErrorLogger.logError(
        'Error during logout',
        error: e,
        context: 'AuthProvider.logout',
      ); // Replaced print with ErrorLogger
    }
  }

  Future<void> checkAuthStatus() async {
    try {
      final firebaseUser = _firebaseAuth.currentUser;

      if (firebaseUser != null) {
        _firebaseUser = firebaseUser;

        // Get user data from SharedPreferences or Firestore
        final prefs = await SharedPreferences.getInstance();
        final userId = prefs.getString('userId');
        final username = prefs.getString('username');
        final userRoleString = prefs.getString('userRole');

        if (userId != null && username != null && userRoleString != null) {
          _currentUser = AppUser(
            id: userId,
            username: username,
            email: firebaseUser.email!,
            passwordHash: '', // Don't store password in memory
            role: UserRole.fromString(userRoleString),
            createdAt: DateTime.now(), // Placeholder
          );
          _isAuthenticated = true;
        } else {
          // Fallback: get user data from Firestore
          try {
            final userData = await _userService.getUserByEmail(
              firebaseUser.email!,
            );

            if (userData != null) {
              _currentUser = userData;
              _isAuthenticated = true;

              // Update SharedPreferences
              await prefs.setBool('isAuthenticated', true);
              await prefs.setString('userId', userData.id.toString());
              await prefs.setString('username', userData.username);
              await prefs.setString('userRole', userData.role.name);
            }
          } catch (e) {
            ErrorLogger.logError(
              'Error getting user data from Firestore',
              error: e,
              context: 'AuthProvider.checkAuthStatus',
            ); // Replaced print with ErrorLogger
          }
        }
      } else {
        _isAuthenticated = false;
        _currentUser = null;
        _firebaseUser = null;
      }

      notifyListeners();
    } catch (e) {
      ErrorLogger.logError(
        'Error checking auth status',
        error: e,
        context: 'AuthProvider.checkAuthStatus',
      ); // Replaced print with ErrorLogger
    }
  }

  Future<void> logActivity(
    String action, {
    String? productName,
    String? productBarcode,
    int? quantity,
    double? amount,
    String? details,
  }) async {
    try {
      if (_currentUser?.id != null) {
        final activity = UserActivity(
          userId: _currentUser!.id.toString(),
          action: action,
          productName: productName,
          productBarcode: productBarcode,
          quantity: quantity,
          amount: amount,
          details: details,
          timestamp: DateTime.now(),
        );

        if (_offlineManager.isOnline) {
          await _activityService.insertUserActivity(activity);
        } else {
          await _offlineManager.queueOperation(
            OfflineOperation(
              type: OperationType.logActivity,
              collectionName: 'activities',
              data: activity.toMap(),
              timestamp: DateTime.now(),
            ),
          );
        }
      }
    } catch (e) {
      ErrorLogger.logError(
        'Error logging activity',
        error: e,
        context: 'AuthProvider.logActivity',
      ); // Replaced print with ErrorLogger
    }
  }

  Future<bool> canDeleteUser(AppUser user) async {
    try {
      // Cannot delete current user
      if (user.id == _currentUser?.id) {
        return false;
      }

      // Cannot delete last admin
      final allUsers = await getAllUsersList();
      final adminCount = allUsers.where((u) => u.role == UserRole.admin).length;
      if (user.role == UserRole.admin && adminCount <= 1) {
        return false;
      }

      return true;
    } catch (e) {
      ErrorLogger.logError(
        'Error checking if user can be deleted',
        error: e,
        context: 'AuthProvider.canDeleteUser',
      );
      return false;
    }
  }

  Future<bool> createUser(
    String username,
    String email,
    String password,
    UserRole role,
  ) async {
    AppUser? newUser;
    try {
      // Clear previous errors
      _error = null;
      _fieldErrors.clear();

      // Validate inputs
      if (username.trim().isEmpty || email.trim().isEmpty || password.isEmpty) {
        _error = 'Please fill in all required fields.';
        return false;
      }

      // Check if username already exists
      final existingUser = await _userService.getUserByUsername(
        username.trim(),
      );
      if (existingUser != null) {
        _error = 'Username already exists';
        return false;
      }

      final hashedPassword = PasswordHelper.hashPassword(password);

      // Create user in Firestore first
      newUser = AppUser(
        username: username.trim(),
        email: email.trim(),
        passwordHash: hashedPassword, // Store hashed password
        role: role,
        createdAt: DateTime.now(),
      );

      final userId = await _userService.insertUser(newUser);
      newUser.id = userId;

      // Create Firebase Auth account
      try {
        final credential = await _firebaseAuth.createUserWithEmailAndPassword(
          email: email.trim(),
          password: password,
        );

        if (credential.user != null) {
          await credential.user!.sendEmailVerification();
          await credential.user!.updateDisplayName(username.trim());
          await logActivity(
            'CREATE_USER',
            details: 'User $username created with role ${role.displayName}',
          );
          _error =
              'A verification email has been sent to your email address. Please verify your email to login.';
          return true;
        } else {
          _error = 'Failed to create Firebase Auth user';
          return false;
        }
      } catch (e) {
        // If Firebase Auth creation fails, delete the Firestore user
        if (newUser.id != null) {
          await _userService.deleteUser(newUser.id!);
        }
        rethrow;
      }
    } on FirebaseAuthException catch (e) {
      _error = AuthErrorHandler.getSignupErrorMessage(e);
      _fieldErrors = AuthErrorHandler.getFieldSpecificError(e);
      ErrorLogger.logError(
        'Error creating user',
        error: e,
        context: 'AuthProvider.createUser',
      );
      return false;
    } catch (e) {
      _error = 'An unexpected error occurred. Please try again.';
      ErrorLogger.logError(
        'Unexpected error creating user',
        error: e,
        context: 'AuthProvider.createUser',
      );
      return false;
    }
  }

  Future<String?> sendPasswordResetEmail(String email) async {
    try {
      await _firebaseAuth.sendPasswordResetEmail(email: email.trim());
      return null;
    } on FirebaseAuthException catch (e) {
      ErrorLogger.logError(
        'Error sending password reset email',
        error: e,
        context: 'AuthProvider.sendPasswordResetEmail',
      );
      return AuthErrorHandler.getPasswordResetErrorMessage(e);
    } catch (e) {
      ErrorLogger.logError(
        'Unexpected error sending password reset email',
        error: e,
        context: 'AuthProvider.sendPasswordResetEmail',
      );
      return 'An unexpected error occurred. Please try again.';
    }
  }

  Stream<List<AppUser>> getAllUsers() {
    try {
      return _userService.getAllUsersStream();
    } catch (e) {
      ErrorLogger.logError(
        'Error getting all users',
        error: e,
        context: 'AuthProvider.getAllUsers',
      );
      return Stream.value([]);
    }
  }

  Future<List<AppUser>> getAllUsersList() async {
    try {
      return await _userService.getAllUsers();
    } catch (e) {
      ErrorLogger.logError(
        'Error getting all users',
        error: e,
        context: 'AuthProvider.getAllUsersList',
      );
      return [];
    }
  }

  Future<bool> updateUserRole(AppUser user, UserRole newRole) async {
    try {
      // Clear previous error
      _error = null;

      // Validate that user exists and role change is valid
      if (user.id == null) {
        _error = 'Invalid user ID';
        return false;
      }

      // Prevent changing role of current user to non-admin if they're the last admin
      if (user.id == _currentUser?.id && newRole != UserRole.admin) {
        final allUsers = await getAllUsersList();
        final adminCount = allUsers
            .where((u) => u.role == UserRole.admin)
            .length;
        if (adminCount <= 1) {
          _error = 'Cannot remove admin role from the last admin user';
          return false;
        }
      }

      final updatedUser = user.copyWith(role: newRole);
      await _userService.updateUser(updatedUser);

      // Log the activity
      await logActivity(
        'UPDATE_USER_ROLE',
        details: 'Changed role of ${user.username} to ${newRole.displayName}',
      );

      notifyListeners();
      return true;
    } catch (e) {
      _error = 'Failed to update user role: ${e.toString()}';
      ErrorLogger.logError(
        'Error updating user role',
        error: e,
        context: 'AuthProvider.updateUserRole',
      );
      return false;
    }
  }

  Future<bool> deleteUser(AppUser user) async {
    try {
      // Clear previous error
      _error = null;

      // Validate that user exists
      if (user.id == null) {
        _error = 'Invalid user ID';
        return false;
      }

      // Prevent deleting current user
      if (user.id == _currentUser?.id) {
        _error = 'Cannot delete your own account';
        return false;
      }

      // Prevent deleting last admin
      final allUsers = await getAllUsersList();
      final adminCount = allUsers.where((u) => u.role == UserRole.admin).length;
      if (user.role == UserRole.admin && adminCount <= 1) {
        _error = 'Cannot delete the last admin user';
        return false;
      }

      // Soft delete - deactivate user instead of hard delete
      final deactivatedUser = user.copyWith(isActive: false);
      await _userService.updateUser(deactivatedUser);

      // Log the activity
      await logActivity(
        'DEACTIVATE_USER',
        details: 'Deactivated user ${user.username} (${user.email})',
      );

      notifyListeners();
      return true;
    } catch (e) {
      _error = 'Failed to deactivate user: ${e.toString()}';
      ErrorLogger.logError(
        'Error deactivating user',
        error: e,
        context: 'AuthProvider.deleteUser',
      );
      return false;
    }
  }

  Future<bool> restoreUser(AppUser user) async {
    try {
      // Clear previous error
      _error = null;

      // Validate that user exists
      if (user.id == null) {
        _error = 'Invalid user ID';
        return false;
      }

      // Restore user - reactivate user
      final restoredUser = user.copyWith(isActive: true);
      await _userService.updateUser(restoredUser);

      // Log the activity
      await logActivity(
        'RESTORE_USER',
        details: 'Restored user ${user.username} (${user.email})',
      );

      notifyListeners();
      return true;
    } catch (e) {
      _error = 'Failed to restore user: ${e.toString()}';
      ErrorLogger.logError(
        'Error restoring user',
        error: e,
        context: 'AuthProvider.restoreUser',
      );
      return false;
    }
  }

  Future<bool> hardDeleteUser(AppUser user) async {
    try {
      // Clear previous error
      _error = null;

      // Validate that user exists
      if (user.id == null) {
        _error = 'Invalid user ID';
        return false;
      }

      // Prevent deleting current user
      if (user.id == _currentUser?.id) {
        _error = 'Cannot delete your own account';
        return false;
      }

      // Prevent deleting last admin
      final allUsers = await getAllUsersList();
      final adminCount = allUsers.where((u) => u.role == UserRole.admin).length;
      if (user.role == UserRole.admin && adminCount <= 1) {
        _error = 'Cannot delete the last admin user';
        return false;
      }

      await _userService.deleteUser(user.id!);

      // Log the activity
      await logActivity(
        'HARD_DELETE_USER',
        details: 'Permanently deleted user ${user.username} (${user.email})',
      );

      notifyListeners();
      return true;
    } catch (e) {
      _error = 'Failed to delete user: ${e.toString()}';
      ErrorLogger.logError(
        'Error deleting user',
        error: e,
        context: 'AuthProvider.hardDeleteUser',
      );
      return false;
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\providers\credit_provider.dart
â•‘ SIZE: 12.61 KB
â•‘ MODIFIED: 10/21/2025 07:26:57
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/models/credit_sale_item.dart';
import 'package:prostock/models/credit_transaction.dart';
import 'package:prostock/models/customer.dart';
import 'package:prostock/models/receipt.dart';
import 'package:prostock/models/sale_item.dart';
import 'package:prostock/providers/customer_provider.dart';
import 'package:prostock/providers/inventory_provider.dart';
import 'package:prostock/providers/sales_provider.dart';
import 'package:prostock/services/firestore/credit_service.dart';
import 'package:prostock/models/offline_operation.dart';
import 'package:prostock/services/demand_analysis_service.dart';
import 'package:prostock/services/notification_service.dart';
import 'package:prostock/services/local_database_service.dart';
import 'package:prostock/utils/error_logger.dart';
import 'package:provider/provider.dart';
import 'package:uuid/uuid.dart';

class CreditProvider with ChangeNotifier {
  final CustomerProvider _customerProvider;
  final InventoryProvider _inventoryProvider;
  final CreditService _creditService;
  late final DemandAnalysisService _demandAnalysisService;

  List<Customer> _overdueCustomers = [];
  List<Customer> get overdueCustomers => _overdueCustomers;

  List<CreditTransaction> _transactions = [];
  List<CreditTransaction> get transactions => _transactions;

  bool _isLoading = false;
  bool get isLoading => _isLoading;
  bool _isInitialized = false;
  String? _error;
  String? get error => _error;

  CreditProvider({
    required CustomerProvider customerProvider,
    required InventoryProvider inventoryProvider, // Added
    required CreditService creditService,
  }) : _customerProvider = customerProvider,
       _inventoryProvider = inventoryProvider, // Added
       _creditService = creditService {
    _demandAnalysisService = DemandAnalysisService(
      LocalDatabaseService.instance,
      NotificationService(),
    );
  }

  Future<void> fetchOverdueCustomers(BuildContext context) async {
    if (_isInitialized) return;

    _isLoading = true;
    notifyListeners();

    final salesProvider = Provider.of<SalesProvider>(context, listen: false);
    final today = DateTime.now();
    final overdueSales = salesProvider.sales.where((sale) {
      return sale.dueDate != null && sale.dueDate!.isBefore(today);
    }).toList();

    final customerIds = overdueSales.map((sale) => sale.customerId).toSet();

    _overdueCustomers = _customerProvider.customers
        .where((customer) => customerIds.contains(customer.id))
        .toList();

    _isLoading = false;
    _isInitialized = true;
    notifyListeners();
  }

  Future<Receipt?> recordCreditSale({
    required String customerId,
    required List<SaleItem> items,
    required double total,
    DateTime? dueDate,
    required String userId,
  }) async {
    final customer = await _customerProvider.getCustomerById(customerId);
    if (customer == null) {
      _error = 'Customer not found';
      notifyListeners();
      return null;
    }

    if (customer.balance + total > customer.creditLimit) {
      _error = 'Credit limit exceeded';
      notifyListeners();
      return null;
    }

    final transaction = CreditTransaction(
      customerId: customerId,
      amount: total,
      date: DateTime.now(),
      type: 'purchase',
      items: items.map((item) => CreditSaleItem.fromSaleItem(item)).toList(),
    );

    try {
      // Local-first: write transaction locally and queue for sync
      final localId = const Uuid().v4();
      try {
        final localMap = transaction.toLocalMap();
        localMap['id'] = localId;
        await LocalDatabaseService.instance.insertCreditTransaction(localMap);
      } catch (_) {}

      // Update balance locally (will queue remote update if offline)
      await _customerProvider.updateCustomerBalance(customerId, total);

      // Reduce stock and record stock movement (online inserts immediately, offline queues)
      for (final item in items) {
        await _inventoryProvider.reduceStock(
          item.productId,
          item.quantity,
          reason: 'Credit sale',
          offline: !_inventoryProvider.isOnline,
        );
      }

      // Queue remote insert of the credit transaction
      final opTx = OfflineOperation(
        type: OperationType.insertCreditTransaction,
        collectionName: 'credit_transactions',
        documentId: localId,
        data: {...transaction.toLocalMap(), 'id': localId},
        timestamp: DateTime.now(),
      );
      await _inventoryProvider.queueOperation(opTx);

      // Trigger immediate demand analysis after credit sale
      _triggerDemandAnalysis();

      // Schedule due-date notifications without creating a Sale record
      if (dueDate != null) {
        try {
          final notifier = NotificationService();
          await notifier.init();
          await notifier.requestPermission();

          final dueStart = DateTime(dueDate.year, dueDate.month, dueDate.day);
          final dayOf = dueStart.add(const Duration(hours: 9));
          final dayBefore = dayOf.subtract(const Duration(days: 1));

          if (dayBefore.isAfter(DateTime.now())) {
            await notifier.scheduleNotification(
              id: localId.hashCode & 0x7fffffff,
              title: 'Payment Due Tomorrow',
              body: 'Payment for customer $customerId is due tomorrow.',
              scheduledDate: dayBefore,
              payload: 'credit_due_tomorrow',
            );
          }

          if (dayOf.isAfter(DateTime.now())) {
            await notifier.scheduleNotification(
              id: (localId.hashCode + 1) & 0x7fffffff,
              title: 'Payment Due Today',
              body: 'Payment for customer $customerId is due today.',
              scheduledDate: dayOf,
              payload: 'credit_due_today',
            );
          }
        } catch (e) {
          ErrorLogger.logError(
            'Error scheduling notifications for credit due date',
            error: e,
            context: 'CreditProvider.recordCreditSale',
          );
        }
      }

      // Group items by product to avoid duplicates
      final groupedItems = _groupItemsByProduct(items);

      return Receipt(
        saleId: localId,
        receiptNumber: localId,
        timestamp: transaction.date,
        customerName: customer.name,
        paymentMethod: 'credit',
        items: groupedItems
            .map(
              (groupedItem) => ReceiptItem(
                productName:
                    _inventoryProvider
                        .getProductById(groupedItem['productId'] as String)
                        ?.name ??
                    'N/A',
                quantity: groupedItem['totalQuantity'] as int,
                unitPrice: groupedItem['unitPrice'] as double,
                totalPrice: groupedItem['totalPrice'] as double,
              ),
            )
            .toList(),
        subtotal: total,
        tax: 0.0,
        total: total,
      );
    } catch (e) {
      _error = 'Failed to record credit sale: $e';
      notifyListeners();
      return null;
    }
  }

  Future<bool> recordPayment({
    required BuildContext context,
    required String customerId,
    required double amount,
    required String notes,
  }) async {
    // Obtain provider before any async gaps to avoid using BuildContext after awaits
    try {
      ErrorLogger.logInfo(
        'Starting payment recording',
        context: 'CreditProvider.recordPayment',
        metadata: {'customerId': customerId, 'amount': amount},
      );

      final transaction = CreditTransaction(
        customerId: customerId,
        amount: amount,
        date: DateTime.now(),
        type: 'payment',
        notes: notes,
      );

      // Basic validations
      if (amount <= 0) {
        _error = 'Payment amount must be greater than zero';
        notifyListeners();
        return false;
      }

      // Generate a local ID for mirroring in SQLite (Firestore add() doesn't return ID here)
      final localId = const Uuid().v4();

      // Local-first for payments: write locally, queue for sync, update balance
      try {
        final localMap = transaction.toLocalMap();
        localMap['id'] = localId;
        await LocalDatabaseService.instance.insertCreditTransaction(localMap);
      } catch (_) {}

      final balanceUpdated = await _customerProvider.updateCustomerBalance(
        customerId,
        -amount,
      );
      if (!balanceUpdated) {
        _error = _customerProvider.error ?? 'Failed to update customer balance';
        notifyListeners();
        return false;
      }

      final opTx = OfflineOperation(
        type: OperationType.insertCreditTransaction,
        collectionName: 'credit_transactions',
        documentId: localId,
        // Store plain JSON without Firestore Timestamp for offline queue
        data: {...transaction.toLocalMap(), 'id': localId},
        timestamp: DateTime.now(),
      );
      await _inventoryProvider.queueOperation(opTx);

      // Do not create a Sale record for payments; treat as collection only
      ErrorLogger.logInfo(
        'Skipping sale record creation for payment (collection only)',
        context: 'CreditProvider.recordPayment',
      );

      ErrorLogger.logInfo(
        'Payment recording completed successfully',
        context: 'CreditProvider.recordPayment',
      );
      return true;
    } catch (e) {
      ErrorLogger.logError(
        'Error recording payment',
        error: e,
        context: 'CreditProvider.recordPayment',
      );
      _error = 'Failed to record payment: $e';
      notifyListeners();
      return false;
    }
  }

  Future<void> getTransactionsByCustomer(String customerId) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      ErrorLogger.logInfo(
        'Fetching transactions for customer',
        context: 'CreditProvider.getTransactionsByCustomer',
        metadata: {'customerId': customerId},
      );

      // Check if there are any transactions at all
      final hasTransactions = await _creditService.hasAnyTransactions();
      ErrorLogger.logInfo(
        'Database transactions presence checked',
        context: 'CreditProvider.getTransactionsByCustomer',
        metadata: {'hasTransactions': hasTransactions},
      );

      _transactions = await _creditService.getTransactionsByCustomer(
        customerId,
      );
      ErrorLogger.logInfo(
        'Transactions loaded',
        context: 'CreditProvider.getTransactionsByCustomer',
        metadata: {'count': _transactions.length},
      );

      _isLoading = false;
      notifyListeners();
    } catch (e) {
      ErrorLogger.logError(
        'Error fetching transactions',
        error: e,
        context: 'CreditProvider.getTransactionsByCustomer',
      );
      _error = 'Failed to load transactions: $e';
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Triggers immediate demand analysis after a credit sale to check for threshold suggestions
  void _triggerDemandAnalysis() {
    // Run in background without blocking the UI
    Future.microtask(() async {
      try {
        final suggestions = await _demandAnalysisService.computeSuggestions();
        if (suggestions.isNotEmpty) {
          await _demandAnalysisService.markSuggestedNow(
            suggestions.map((s) => s.product.id!).toList(),
          );
          await _demandAnalysisService.runDailyAndNotify();
        }
      } catch (e) {
        ErrorLogger.logError(
          'Error in immediate demand analysis',
          error: e,
          context: 'CreditProvider._triggerDemandAnalysis',
        );
      }
    });
  }

  List<Map<String, dynamic>> _groupItemsByProduct(List<SaleItem> items) {
    final Map<String, Map<String, dynamic>> grouped = {};

    for (final item in items) {
      if (grouped.containsKey(item.productId)) {
        // Add to existing group
        final existing = grouped[item.productId]!;
        existing['totalQuantity'] =
            (existing['totalQuantity'] as int) + item.quantity;
        existing['totalPrice'] =
            (existing['totalPrice'] as double) + item.totalPrice;
      } else {
        // Create new group
        grouped[item.productId] = {
          'productId': item.productId,
          'unitPrice': item.unitPrice,
          'totalQuantity': item.quantity,
          'totalPrice': item.totalPrice,
        };
      }
    }

    return grouped.values.toList();
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\providers\customer_provider.dart
â•‘ SIZE: 21.3 KB
â•‘ MODIFIED: 10/04/2025 05:06:57
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:io';

import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:prostock/models/offline_operation.dart';
import 'package:prostock/models/update_result.dart';
import 'package:prostock/services/firestore/customer_service.dart';
import 'package:prostock/services/offline_manager.dart';
import '../models/customer.dart';
import '../services/cloudinary_service.dart';
import '../utils/error_logger.dart';
import 'package:prostock/services/local_database_service.dart';
import '../widgets/delete_confirmation_dialog.dart';
import '../widgets/dialog_helpers.dart';
import '../services/customer_status_monitor.dart';

class CustomerProvider with ChangeNotifier {
  List<Customer> _customers = [];
  bool _isLoading = false;
  String? _error;

  final LocalDatabaseService _localDatabaseService =
      LocalDatabaseService.instance;
  final OfflineManager _offlineManager;
  final Map<String, List<Customer>> _cache = {};
  final Map<String, DateTime> _cacheTimestamps = {};
  static const Duration _cacheExpiry = Duration(minutes: 5);
  static const int _pageSize = 50;
  DocumentSnapshot? _lastDocument;
  bool _hasMoreData = true;
  String? _currentSearchQuery;
  final CustomerStatusMonitor _statusMonitor = CustomerStatusMonitor();

  CustomerProvider(this._offlineManager) {
    _initializeStatusMonitor();
  }

  /// Initialize the customer status monitor
  void _initializeStatusMonitor() {
    _statusMonitor.initialize().catchError((e) {
      ErrorLogger.logError('Failed to initialize status monitor', error: e);
    });
  }

  List<Customer> get customers => _customers;
  bool get isLoading => _isLoading;
  String? get error => _error;
  bool get hasMoreData => _hasMoreData;
  OfflineManager get offlineManager => _offlineManager;

  List<Customer> get overdueCustomers {
    // This should be based on actual due dates from sales, not just balance
    // For now, return customers with positive balance as a fallback
    return _customers.where((customer) => customer.balance > 0).toList();
  }

  void clearError() {
    _error = null;
    notifyListeners();
  }

  Future<void> loadCustomers({
    bool refresh = false,
    String? searchQuery,
  }) async {
    if (_isLoading) return;

    // Clear cache when search query changes to ensure fresh results
    if (_currentSearchQuery != searchQuery) {
      clearCache();
    }

    if (!refresh && !_offlineManager.isOnline) {
      await _loadCustomersFromLocalDB(searchQuery: searchQuery);
      return;
    }

    if (!refresh && !_shouldRefreshCache('customers_${searchQuery ?? 'all'}')) {
      final cachedData = _getCachedData('customers_${searchQuery ?? 'all'}');
      if (cachedData != null) {
        _customers = cachedData;
        notifyListeners();
        return;
      }
    }

    _isLoading = true;
    _error = null;
    _lastDocument = null;
    _hasMoreData = true;
    _currentSearchQuery = searchQuery;
    notifyListeners();

    try {
      final customerService = CustomerService(FirebaseFirestore.instance);
      final result = await customerService.getCustomersPaginated(
        limit: _pageSize,
        lastDocument: null,
        searchQuery: searchQuery,
      );

      _customers = result.items;
      _lastDocument = result.lastDocument;
      _hasMoreData = result.items.length == _pageSize;

      await _cacheCustomersToLocalDB(_customers);
      _setCachedData('customers_${searchQuery ?? 'all'}', _customers);
    } catch (e) {
      _error = 'Failed to load customers: ${e.toString()}';
      ErrorLogger.logError(
        'Error loading customers',
        error: e,
        context: 'CustomerProvider.loadCustomers',
      );
      await _loadCustomersFromLocalDB(searchQuery: searchQuery);

      // Check for customer status changes and send notifications
      try {
        await _statusMonitor.checkStatusChanges(_customers);
      } catch (e) {
        // Don't fail the main operation if status monitoring fails
        ErrorLogger.logError('Status monitoring failed', error: e);
      }
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> _loadCustomersFromLocalDB({String? searchQuery}) async {
    try {
      final db = await _localDatabaseService.database;
      final maps = await db.query('customers', orderBy: 'name ASC');
      final allCustomers = maps.map((map) => Customer.fromMap(map)).toList();

      if (searchQuery != null && searchQuery.isNotEmpty) {
        // Apply case-insensitive search filtering
        _customers = _filterCustomersLocally(allCustomers, searchQuery);
      } else {
        _customers = allCustomers;
      }
    } catch (e) {
      _error = 'Failed to load customers from local database: ${e.toString()}';
      ErrorLogger.logError(
        'Error loading customers from local DB',
        error: e,
        context: 'CustomerProvider._loadCustomersFromLocalDB',
      );
    } finally {
      notifyListeners();
    }
  }

  List<Customer> _filterCustomersLocally(
    List<Customer> customers,
    String searchQuery,
  ) {
    final query = searchQuery.toLowerCase().trim();
    if (query.isEmpty) return customers;

    return customers.where((customer) {
      return customer.name.toLowerCase().contains(query) ||
          (customer.phone?.toLowerCase().contains(query) ?? false) ||
          (customer.email?.toLowerCase().contains(query) ?? false);
    }).toList();
  }

  Future<void> _cacheCustomersToLocalDB(List<Customer> customers) async {
    try {
      final db = await _localDatabaseService.database;

      // Use transaction to ensure atomicity
      await db.transaction((txn) async {
        // Delete existing customers
        await txn.delete('customers');

        // Insert new customers
        for (final customer in customers) {
          await txn.insert('customers', customer.toMap());
        }
      });
    } catch (e) {
      ErrorLogger.logError(
        'Error caching customers to local DB',
        error: e,
        context: 'CustomerProvider._cacheCustomersToLocalDB',
      );
      // Don't rethrow to prevent breaking the main operation
    }
  }

  Future<void> loadMoreCustomers() async {
    if (_isLoading || !_hasMoreData) return;

    _isLoading = true;
    notifyListeners();

    try {
      final customerService = CustomerService(FirebaseFirestore.instance);
      final result = await customerService.getCustomersPaginated(
        limit: _pageSize,
        lastDocument: _lastDocument,
        searchQuery: _currentSearchQuery,
      );

      _customers.addAll(result.items);
      _lastDocument = result.lastDocument;
      _hasMoreData = result.items.length == _pageSize;

      _setCachedData('customers_${_currentSearchQuery ?? 'all'}', _customers);
    } catch (e) {
      _error = 'Failed to load more customers: ${e.toString()}';
      ErrorLogger.logError(
        'Error loading more customers',
        error: e,
        context: 'CustomerProvider.loadMoreCustomers',
      );
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  bool _shouldRefreshCache(String key) {
    final timestamp = _cacheTimestamps[key];
    if (timestamp == null) return true;
    return DateTime.now().difference(timestamp) > _cacheExpiry;
  }

  List<Customer>? _getCachedData(String key) {
    return _cache[key];
  }

  void _setCachedData(String key, List<Customer> data) {
    _cache[key] = List.from(data);
    _cacheTimestamps[key] = DateTime.now();
  }

  void clearCache() {
    _cache.clear();
    _cacheTimestamps.clear();
  }

  Future<Customer?> addCustomer(Customer customer) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final db = await _localDatabaseService.database;

      // Use transaction to ensure atomicity
      await db.transaction((txn) async {
        await txn.insert('customers', customer.toMap());
      });

      _customers.add(customer);

      if (_offlineManager.isOnline) {
        try {
          final customerService = CustomerService(FirebaseFirestore.instance);
          final firestoreId = await customerService.insertCustomer(customer);
          final finalCustomer = customer.copyWith(id: firestoreId);

          // Update local database with Firestore ID
          await db.transaction((txn) async {
            await txn.update(
              'customers',
              finalCustomer.toMap(),
              where: 'id = ?',
              whereArgs: [customer.id],
            );
          });

          final index = _customers.indexWhere((c) => c.id == customer.id);
          if (index != -1) {
            _customers[index] = finalCustomer;
          }
        } catch (firestoreError) {
          // If Firestore fails, rollback local changes
          await db.transaction((txn) async {
            await txn.delete(
              'customers',
              where: 'id = ?',
              whereArgs: [customer.id],
            );
          });
          _customers.removeWhere((c) => c.id == customer.id);
          rethrow;
        }
      } else {
        await _offlineManager.queueOperation(
          OfflineOperation(
            id: customer.id,
            type: OperationType.insertCustomer,
            collectionName: 'customers',
            documentId: customer.id,
            data: customer.toMap(),
            timestamp: DateTime.now(),
          ),
        );
      }

      _isLoading = false;
      notifyListeners();
      return customer;
    } catch (e) {
      _error = 'Failed to add customer: ${e.toString()}';
      _isLoading = false;
      notifyListeners();
      ErrorLogger.logError(
        'Error adding customer',
        error: e,
        context: 'CustomerProvider.addCustomer',
      );
      return null;
    }
  }

  Future<UpdateResult> updateCustomer(Customer customer) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final db = await _localDatabaseService.database;
      await db.update(
        'customers',
        customer.toMap(),
        where: 'id = ?',
        whereArgs: [customer.id],
      );

      final index = _customers.indexWhere((c) => c.id == customer.id);
      if (index != -1) {
        _customers[index] = customer;
      }

      if (_offlineManager.isOnline) {
        final customerService = CustomerService(FirebaseFirestore.instance);
        final existingCustomer = await customerService.getCustomerById(
          customer.id,
        );

        if (existingCustomer != null &&
            existingCustomer.version > customer.version) {
          ErrorLogger.logInfo(
            'Conflict detected for customer ${customer.id}',
            context: 'CustomerProvider.updateCustomer',
          );
          return UpdateResult(
            success: false,
            conflict: Conflict.customer(
              localCustomer: customer,
              remoteCustomer: existingCustomer,
            ),
          );
        }

        final customerToUpdate = customer.copyWith(
          version: customer.version + 1,
        );

        final oldCustomer = await getCustomerById(customer.id);
        if (oldCustomer?.localImagePath != null &&
            oldCustomer!.localImagePath! != customer.localImagePath) {
          final imageFile = File(oldCustomer.localImagePath!);
          if (await imageFile.exists()) {
            await imageFile.delete();
          }
        }
        if (oldCustomer?.imageUrl != null &&
            oldCustomer!.imageUrl! != customer.imageUrl) {
          final publicId = CloudinaryService.instance.getPublicIdFromUrl(
            oldCustomer.imageUrl!,
          );
          if (publicId != null) {
            await CloudinaryService.instance.deleteImage(publicId);
          }
        }

        await customerService.updateCustomer(customerToUpdate);

        // Update local data with the versioned customer
        await db.update(
          'customers',
          customerToUpdate.toMap(),
          where: 'id = ?',
          whereArgs: [customer.id],
        );
        final updatedIndex = _customers.indexWhere(
          (c) => c.id == customerToUpdate.id,
        );
        if (updatedIndex != -1) {
          _customers[updatedIndex] = customerToUpdate;
        }
      } else {
        final updatedCustomer = customer.copyWith(
          version: customer.version + 1,
        );
        await _offlineManager.queueOperation(
          OfflineOperation(
            id: updatedCustomer.id,
            type: OperationType.updateCustomer,
            collectionName: 'customers',
            documentId: updatedCustomer.id,
            data: updatedCustomer.toMap(),
            timestamp: DateTime.now(),
          ),
        );
      }

      _isLoading = false;
      notifyListeners();
      return UpdateResult(success: true);
    } catch (e) {
      _error = 'Failed to update customer: ${e.toString()}';
      _isLoading = false;
      notifyListeners();
      ErrorLogger.logError(
        'Error updating customer',
        error: e,
        context: 'CustomerProvider.updateCustomer',
      );
      return UpdateResult(success: false);
    }
  }

  Future<bool> deleteCustomer(String customerId) async {
    try {
      final customer = await getCustomerById(customerId);
      if (customer?.balance != 0) {
        _error = 'Cannot delete customer with an outstanding balance.';
        notifyListeners();
        return false;
      }

      final db = await _localDatabaseService.database;
      await db.delete('customers', where: 'id = ?', whereArgs: [customerId]);

      _customers.removeWhere((c) => c.id == customerId);

      if (_offlineManager.isOnline) {
        if (customer?.localImagePath != null) {
          final imageFile = File(customer!.localImagePath!);
          if (await imageFile.exists()) {
            await imageFile.delete();
          }
        }
        if (customer?.imageUrl != null) {
          final publicId = CloudinaryService.instance.getPublicIdFromUrl(
            customer!.imageUrl!,
          );
          if (publicId != null) {
            await CloudinaryService.instance.deleteImage(publicId);
          }
        }
        final customerService = CustomerService(FirebaseFirestore.instance);
        await customerService.deleteCustomer(customerId);
      } else {
        await _offlineManager.queueOperation(
          OfflineOperation(
            id: customerId,
            type: OperationType.deleteCustomer,
            collectionName: 'customers',
            documentId: customerId,
            data: {}, // No data needed for delete
            timestamp: DateTime.now(),
          ),
        );
      }

      notifyListeners();
      return true;
    } catch (e) {
      _error = 'Failed to delete customer: ${e.toString()}';
      notifyListeners();
      ErrorLogger.logError(
        'Error deleting customer',
        error: e,
        context: 'CustomerProvider.deleteCustomer',
      );
      return false;
    }
  }

  /// Delete customer with confirmation dialog
  Future<bool> deleteCustomerWithConfirmation(
    BuildContext context,
    String customerId,
  ) async {
    final navigator = Navigator.of(context);
    final customer = await getCustomerById(customerId);
    if (customer == null) {
      _error = 'Customer not found';
      notifyListeners();
      return false;
    }

    if (customer.balance != 0) {
      _error =
          'Cannot delete customer with an outstanding balance of ₱${customer.balance.toStringAsFixed(2)}';
      notifyListeners();
      return false;
    }

    if (!navigator.mounted) return false;
    final confirmed = await DeleteConfirmationDialog.show(
      context: navigator.context,
      title: 'Delete Customer',
      message:
          'Are you sure you want to delete this customer? This action cannot be undone.',
      itemName: customer.name,
      onConfirm: () async {
        await deleteCustomer(customerId);
      },
    );

    return confirmed ?? false;
  }

  Future<bool> updateCustomerBalance(String customerId, double amount) async {
    try {
      final customerIndex = _customers.indexWhere((c) => c.id == customerId);
      if (customerIndex == -1) {
        _error = 'Customer not found';
        notifyListeners();
        return false;
      }

      final customer = _customers[customerIndex];
      final newBalance = customer.balance + amount;

      // Validate business rules
      if (newBalance < 0) {
        _error = 'Customer balance cannot be negative';
        notifyListeners();
        return false;
      }

      if (newBalance > customer.creditLimit && customer.creditLimit > 0) {
        _error =
            'Customer balance exceeds credit limit of ${customer.creditLimit}';
        notifyListeners();
        return false;
      }

      final updatedCustomer = customer.copyWith(
        balance: newBalance,
        updatedAt: DateTime.now(),
      );

      if (_offlineManager.isOnline) {
        final customerService = CustomerService(FirebaseFirestore.instance);
        await customerService.updateCustomer(updatedCustomer);
      } else {
        await _offlineManager.queueOperation(
          OfflineOperation(
            id: updatedCustomer.id,
            type: OperationType.updateCustomerBalance,
            collectionName: 'customers',
            documentId: updatedCustomer.id,
            data: {
              'balance_increment':
                  amount, // Store increment instead of absolute value
              'updated_at': updatedCustomer.updatedAt.toIso8601String(),
            },
            timestamp: DateTime.now(),
          ),
        );
      }

      final db = await _localDatabaseService.database;
      await db.update(
        'customers',
        {
          'balance': updatedCustomer.balance,
          'updated_at': updatedCustomer.updatedAt.toIso8601String(),
        },
        where: 'id = ?',
        whereArgs: [customerId],
      );

      _customers[customerIndex] = updatedCustomer;

      // Check for customer status changes after balance update
      try {
        await _statusMonitor.checkStatusChanges(_customers);
      } catch (e) {
        // Don't fail the main operation if status monitoring fails
        ErrorLogger.logError('Status monitoring failed', error: e);
      }

      notifyListeners();
      return true;
    } catch (e) {
      _error = 'Failed to update customer balance: ${e.toString()}';
      notifyListeners();
      ErrorLogger.logError(
        'Error updating customer balance',
        error: e,
        context: 'CustomerProvider.updateCustomerBalance',
      );
      return false;
    }
  }

  void updateLocalCustomerBalance(String customerId, double amount) {
    final index = _customers.indexWhere((c) => c.id == customerId);
    if (index != -1) {
      final oldCustomer = _customers[index];
      _customers[index] = oldCustomer.copyWith(
        balance: oldCustomer.balance + amount,
        updatedAt: DateTime.now(),
      );
      notifyListeners();
    }
  }

  /// Show manage balance dialog for a customer
  Future<void> showManageBalanceDialog(
    BuildContext context,
    String customerId,
  ) async {
    final navigator = Navigator.of(context);
    final customer = await getCustomerById(customerId);
    if (customer == null) {
      _error = 'Customer not found';
      notifyListeners();
      return;
    }

    if (!navigator.mounted) return;
    await DialogHelpers.showManageBalanceDialog(
      context: navigator.context,
      customer: customer,
      onUpdateBalance: updateCustomerBalance,
    );
  }

  Future<Customer?> getCustomerById(String id) async {
    try {
      Customer? localCustomer;
      try {
        localCustomer = _customers.firstWhere((customer) => customer.id == id);
      } catch (e) {
        localCustomer = null;
      }

      if (localCustomer != null) {
        return localCustomer;
      }

      final customerService = CustomerService(FirebaseFirestore.instance);
      final customer = await customerService.getCustomerById(id);
      return customer;
    } catch (e) {
      ErrorLogger.logError(
        'Error getting customer by id',
        error: e,
        context: 'CustomerProvider.getCustomerById',
      );
      return null;
    }
  }

  Future<Customer?> getCustomerByName(String name) async {
    try {
      Customer? localCustomer;
      for (final customer in _customers) {
        if (customer.name.toLowerCase() == name.toLowerCase()) {
          localCustomer = customer;
          break;
        }
      }

      if (localCustomer != null) {
        return localCustomer;
      }

      final customerService = CustomerService(FirebaseFirestore.instance);
      final customer = await customerService.getCustomerByName(name);
      return customer;
    } catch (e) {
      ErrorLogger.logError(
        'Error getting customer by name',
        error: e,
        context: 'CustomerProvider.getCustomerByName',
      );
      return null;
    }
  }

  Future<void> refreshCustomers() async {
    await loadCustomers(refresh: true);
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\providers\demand_provider.dart
â•‘ SIZE: 0.89 KB
â•‘ MODIFIED: 09/19/2025 19:41:10
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/foundation.dart';
import 'package:prostock/services/demand_analysis_service.dart';

class DemandProvider extends ChangeNotifier {
  final DemandAnalysisService _service;
  bool _loading = false;
  List<DemandSuggestion> _suggestions = [];

  DemandProvider(this._service);

  bool get isLoading => _loading;
  List<DemandSuggestion> get suggestions => _suggestions;

  Future<void> refresh() async {
    _loading = true;
    notifyListeners();
    try {
      _suggestions = await _service.computeSuggestions();
    } finally {
      _loading = false;
      notifyListeners();
    }
  }

  Future<void> snooze(String productId) async {
    await _service.snooze(productId);
    await refresh();
  }

  Future<void> accept(String productId, int threshold) async {
    await _service.acceptSuggestion(productId, threshold);
    await refresh();
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\providers\inventory_provider.dart
â•‘ SIZE: 47.56 KB
â•‘ MODIFIED: 10/25/2025 14:35:55
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/models/offline_operation.dart';
import 'dart:async';
import 'package:prostock/models/update_result.dart';
import 'package:flutter/material.dart';
import 'package:prostock/models/loss.dart';
import 'package:prostock/models/loss_reason.dart';
import 'package:prostock/models/price_history.dart';
import 'package:prostock/models/cost_history.dart';
import 'package:prostock/models/inventory_batch.dart';
import 'package:prostock/services/batch_service.dart';
import 'package:prostock/services/firestore/inventory_service.dart';
import 'package:prostock/services/firestore/product_service.dart';
import 'package:prostock/services/cost_history_service.dart';
import 'package:prostock/services/offline_manager.dart';
import 'package:sqflite/sqflite.dart';
import 'package:uuid/uuid.dart';
import '../models/product.dart';
import '../services/local_database_service.dart';
import '../utils/error_logger.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:prostock/providers/auth_provider.dart'; // New import
import 'package:prostock/services/notification_service.dart';
import 'package:prostock/services/tax_service.dart';
import 'package:prostock/utils/constants.dart';

class InventoryProvider with ChangeNotifier {
  List<Product> _products = [];
  // Keep a cache of all products for lookup by ID, regardless of current filter
  final Map<String, Product> _productCache = {};
  bool _isLoading = false;
  String? _error;
  final Map<String, int> _reservedStock = {};
  final Map<String, int> _reorderPoints = {};
  final Map<String, int> _visualStock = {};
  final Map<String, _StockAlertState> _lastAlertStates = {};

  final LocalDatabaseService _localDatabaseService =
      LocalDatabaseService.instance;
  final BatchService _batchService = BatchService();
  final OfflineManager _offlineManager;
  final AuthProvider _authProvider; // New field
  StreamSubscription<QuerySnapshot>? _productsSubscription;

  InventoryProvider({
    required OfflineManager offlineManager,
    required AuthProvider authProvider,
  }) : _offlineManager = offlineManager,
       _authProvider = authProvider {
    _startProductsListener();
  } // Initialize new field

  List<Product> get products => _products;
  bool get isLoading => _isLoading;
  String? get error => _error;
  Map<String, int> get visualStock => _visualStock;
  bool get isOnline => _offlineManager.isOnline;
  OfflineManager get offlineManager => _offlineManager;

  Future<void> queueOperation(OfflineOperation operation) async {
    await _offlineManager.queueOperation(operation);
  }

  List<Product> get lowStockProducts =>
      _products.where((product) => product.isLowStock).toList();

  List<Product> get criticalStockProducts => _products
      .where(
        (product) =>
            product.stock <= (_reorderPoints[product.id.toString()] ?? 5),
      )
      .toList();

  void clearError() {
    _error = null;
    notifyListeners();
  }

  void initializeVisualStock() {
    _visualStock.clear();
    for (var product in _products) {
      if (product.id != null) {
        _visualStock[product.id!] = product.stock;
      }
    }
    notifyListeners();
  }

  void decreaseVisualStock(String productId, int quantity) {
    if (_visualStock.containsKey(productId)) {
      _visualStock[productId] = (_visualStock[productId]! - quantity).clamp(
        0,
        _visualStock[productId]!,
      );
      notifyListeners();
    }
  }

  void increaseVisualStock(String productId, int quantity) {
    final product = getProductById(productId);
    if (product != null && _visualStock.containsKey(productId)) {
      _visualStock[productId] = (_visualStock[productId]! + quantity).clamp(
        0,
        product.stock,
      );
      notifyListeners();
    }
  }

  int getVisualStock(String productId) {
    return _visualStock[productId] ?? getProductById(productId)?.stock ?? 0;
  }

  Future<void> loadProducts({bool refresh = false, String? searchQuery}) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final db = await _localDatabaseService.database;
      final List<Product> localProducts = (await db.query(
        'products',
      )).map((json) => Product.fromMap(json)).toList();

      // Always update the product cache with all products
      _updateProductCache(localProducts);

      // Apply local search filtering if searchQuery is provided
      if (searchQuery != null && searchQuery.isNotEmpty) {
        _products = _filterProductsLocally(localProducts, searchQuery);
      } else {
        _products = localProducts;
      }

      initializeVisualStock();
      notifyListeners();

      // Only fetch from Firestore if online and no search query (or refresh requested)
      if ((refresh || localProducts.isEmpty || _offlineManager.isOnline) &&
          (searchQuery == null || searchQuery.isEmpty)) {
        final productService = ProductService(FirebaseFirestore.instance);
        final result = await productService.getProductsPaginated(
          limit: 50,
          lastDocument: null,
          searchQuery: null, // Don't search on Firestore for general loading
        );

        final List<Product> firestoreProducts = result.items;

        final Map<String, Product> mergedProductsMap = {
          for (var p in firestoreProducts)
            if (p.id != null) p.id!: p,
        };
        for (var p in localProducts) {
          if (p.id != null) {
            mergedProductsMap[p.id!] = p;
          }
        }

        _products = mergedProductsMap.values.toList();

        // Update product cache with merged products
        _updateProductCache(_products);
        await _saveProductsToLocalDB(_products);
        initializeVisualStock();
      } else if (searchQuery != null &&
          searchQuery.isNotEmpty &&
          _offlineManager.isOnline) {
        // If online and searching, try Firestore search first, fallback to local
        try {
          final productService = ProductService(FirebaseFirestore.instance);
          final result = await productService.getProductsPaginated(
            limit: 50,
            lastDocument: null,
            searchQuery: searchQuery,
          );

          if (result.items.isNotEmpty) {
            _products = result.items;
            // Update product cache with fetched products
            _updateProductCache(result.items);
            initializeVisualStock();
          }
        } catch (e) {
          // Fallback to local search if Firestore search fails
          _products = _filterProductsLocally(localProducts, searchQuery);
          initializeVisualStock();
        }
      }
    } catch (e) {
      _error = 'Failed to load products: ${e.toString()}';
      ErrorLogger.logError(
        'Error loading products',
        error: e,
        context: 'InventoryProvider.loadProducts',
      );
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  List<Product> _filterProductsLocally(
    List<Product> products,
    String searchQuery,
  ) {
    final query = searchQuery.toLowerCase().trim();
    if (query.isEmpty) return products;

    return products.where((product) {
      return product.name.toLowerCase().contains(query) ||
          (product.barcode?.toLowerCase().contains(query) ?? false);
    }).toList();
  }

  Future<void> _saveProductsToLocalDB(List<Product> products) async {
    final db = await _localDatabaseService.database;
    final batch = db.batch();

    for (var product in products) {
      batch.insert(
        'products',
        product.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
    }

    await batch.commit(noResult: true);
  }

  Future<Product?> addProduct(Product product) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    // Optimistic: add locally first, rollback if both remote and queue fail
    try {
      final productId = const Uuid().v4();
      final newProduct = product.copyWith(id: productId);

      final db = await _localDatabaseService.database;
      await db.insert(
        'products',
        newProduct.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );

      _products.add(newProduct);
      // Add to product cache as well
      _productCache[newProduct.id!] = newProduct;
      _reorderPoints[newProduct.id!] = (newProduct.stock * 0.1).ceil().clamp(
        5,
        50,
      );

      if (_offlineManager.isOnline) {
        try {
          final productService = ProductService(FirebaseFirestore.instance);
          final inventoryService = InventoryService(FirebaseFirestore.instance);
          final costHistoryService = CostHistoryService(
            FirebaseFirestore.instance,
          );

          await productService.addProductWithPriceHistory(newProduct);
          await inventoryService.insertStockMovement(
            newProduct.id!,
            newProduct.name,
            'stock_in',
            newProduct.stock,
            'Initial stock',
          );

          // Record initial cost history
          await costHistoryService.insertCostHistory(
            newProduct.id!,
            newProduct.cost,
          );
        } catch (e) {
          // Fallback to offline queue if online write fails
          await _offlineManager.queueOperation(
            OfflineOperation(
              id: newProduct.id!,
              type: OperationType.insertProduct,
              collectionName: 'products',
              documentId: newProduct.id,
              data: newProduct.toMap(),
              timestamp: DateTime.now(),
            ),
          );
          final sellingPrice = await TaxService.calculateSellingPrice(
            newProduct.cost,
          );
          final priceHistory = PriceHistory(
            id: const Uuid().v4(),
            productId: newProduct.id!,
            price: sellingPrice,
            timestamp: DateTime.now(),
          );
          await _offlineManager.queueOperation(
            OfflineOperation(
              id: priceHistory.id,
              type: OperationType.insertPriceHistory,
              collectionName: 'priceHistory',
              documentId: priceHistory.id,
              data: priceHistory.toMap(),
              timestamp: DateTime.now(),
            ),
          );

          // Queue initial cost history
          final costHistory = CostHistory(
            id: const Uuid().v4(),
            productId: newProduct.id!,
            cost: newProduct.cost,
            timestamp: DateTime.now(),
          );
          await _offlineManager.queueOperation(
            OfflineOperation(
              id: costHistory.id,
              type: OperationType.insertCostHistory,
              collectionName: 'costHistory',
              documentId: costHistory.id,
              data: costHistory.toMap(),
              timestamp: DateTime.now(),
            ),
          );
        }
      } else {
        await _offlineManager.queueOperation(
          OfflineOperation(
            id: newProduct.id!,
            type: OperationType.insertProduct,
            collectionName: 'products',
            documentId: newProduct.id,
            data: newProduct.toMap(),
            timestamp: DateTime.now(),
          ),
        );
        final sellingPrice = await TaxService.calculateSellingPrice(
          newProduct.cost,
        );
        final priceHistory = PriceHistory(
          id: const Uuid().v4(),
          productId: newProduct.id!,
          price: sellingPrice,
          timestamp: DateTime.now(),
        );
        await _offlineManager.queueOperation(
          OfflineOperation(
            id: priceHistory.id,
            type: OperationType.insertPriceHistory,
            collectionName: 'priceHistory',
            documentId: priceHistory.id,
            data: priceHistory.toMap(),
            timestamp: DateTime.now(),
          ),
        );

        // Queue initial cost history
        final costHistory = CostHistory(
          id: const Uuid().v4(),
          productId: newProduct.id!,
          cost: newProduct.cost,
          timestamp: DateTime.now(),
        );
        await _offlineManager.queueOperation(
          OfflineOperation(
            id: costHistory.id,
            type: OperationType.insertCostHistory,
            collectionName: 'costHistory',
            documentId: costHistory.id,
            data: costHistory.toMap(),
            timestamp: DateTime.now(),
          ),
        );
      }

      _isLoading = false;
      initializeVisualStock();
      notifyListeners();
      return newProduct;
    } catch (e) {
      // Rollback: remove local product and DB row if present
      try {
        final db = await _localDatabaseService.database;
        await db.delete('products', where: 'id = ?', whereArgs: [product.id]);
      } catch (_) {}
      _products.removeWhere((p) => p.id == product.id);
      // Also remove from product cache
      _productCache.remove(product.id);
      initializeVisualStock();
      _error = 'Failed to add product: ${e.toString()}';
      _isLoading = false;
      notifyListeners();
      ErrorLogger.logError(
        'Error adding product',
        error: e,
        context: 'InventoryProvider.addProduct',
      );
      return null;
    }
  }

  Future<UpdateResult> updateProduct(Product product) async {
    try {
      final db = await _localDatabaseService.database;
      final originalProductIndex = _products.indexWhere(
        (p) => p.id == product.id,
      );
      Product? originalProduct = originalProductIndex != -1
          ? _products[originalProductIndex]
          : null;

      if (_offlineManager.isOnline) {
        final productService = ProductService(FirebaseFirestore.instance);
        final costHistoryService = CostHistoryService(
          FirebaseFirestore.instance,
        );
        final existingProduct = await productService.getProductById(
          product.id!,
        );

        if (existingProduct != null &&
            existingProduct.version > product.version) {
          ErrorLogger.logInfo(
            'Conflict detected for product ${product.id}',
            context: 'InventoryProvider.updateProduct',
          );
          return UpdateResult(
            success: false,
            conflict: Conflict.product(
              localProduct: product,
              remoteProduct: existingProduct,
            ),
          );
        }

        final productToUpdate = product.copyWith(version: product.version + 1);

        final bool costChanged =
            originalProduct != null &&
            originalProduct.cost != productToUpdate.cost;

        await productService.updateProductWithPriceHistory(
          productToUpdate,
          costChanged,
        );

        // Record cost history when cost changes in online mode
        if (costChanged) {
          await costHistoryService.insertCostHistory(
            productToUpdate.id!,
            productToUpdate.cost,
          );
        }

        await db.update(
          'products',
          productToUpdate.toMap(),
          where: 'id = ?',
          whereArgs: [productToUpdate.id],
        );
        final index = _products.indexWhere((p) => p.id == productToUpdate.id);
        if (index != -1) {
          _products[index] = productToUpdate;
          // Update product cache as well
          _productCache[productToUpdate.id!] = productToUpdate;
          initializeVisualStock();
          notifyListeners();
        }
      } else {
        final updatedProduct = product.copyWith(version: product.version + 1);
        await db.update(
          'products',
          updatedProduct.toMap(),
          where: 'id = ?',
          whereArgs: [updatedProduct.id],
        );

        // Update product in products list and cache
        final indexInList = _products.indexWhere(
          (p) => p.id == updatedProduct.id,
        );
        if (indexInList != -1) {
          _products[indexInList] = updatedProduct;
        }
        // Always update cache
        _productCache[updatedProduct.id!] = updatedProduct;
        await _offlineManager.queueOperation(
          OfflineOperation(
            id: updatedProduct.id!,
            type: OperationType.updateProduct,
            collectionName: 'products',
            documentId: updatedProduct.id,
            data: updatedProduct.toMap(),
            timestamp: DateTime.now(),
            version: updatedProduct.version,
          ),
        );

        if (originalProduct != null &&
            originalProduct.cost != updatedProduct.cost) {
          // Track price history
          final sellingPrice = await TaxService.calculateSellingPrice(
            updatedProduct.cost,
          );
          final priceHistory = PriceHistory(
            id: const Uuid().v4(),
            productId: updatedProduct.id!,
            price: sellingPrice,
            timestamp: DateTime.now(),
          );
          await _offlineManager.queueOperation(
            OfflineOperation(
              id: priceHistory.id,
              type: OperationType.insertPriceHistory,
              collectionName: 'priceHistory',
              documentId: priceHistory.id,
              data: priceHistory.toMap(),
              timestamp: DateTime.now(),
            ),
          );

          // Track cost history
          final costHistory = CostHistory(
            id: const Uuid().v4(),
            productId: updatedProduct.id!,
            cost: updatedProduct.cost,
            timestamp: DateTime.now(),
          );
          await _offlineManager.queueOperation(
            OfflineOperation(
              id: costHistory.id,
              type: OperationType.insertCostHistory,
              collectionName: 'costHistory',
              documentId: costHistory.id,
              data: costHistory.toMap(),
              timestamp: DateTime.now(),
            ),
          );
        }

        final index = _products.indexWhere((p) => p.id == updatedProduct.id);
        if (index != -1) {
          _products[index] = updatedProduct;
          initializeVisualStock();
          notifyListeners();
        }
      }

      return UpdateResult(success: true);
    } catch (e) {
      _error = 'Error updating product: ${e.toString()}';
      notifyListeners();
      ErrorLogger.logError(
        'Error updating product',
        error: e,
        context: 'InventoryProvider.updateProduct',
      );
      return UpdateResult(success: false);
    }
  }

  Future<UpdateResult> updateStock(
    String productId,
    int newStock, {
    String? reason,
  }) async {
    // Optimistic: update memory and DB first, rollback on failure of both remote and queue
    try {
      final index = _products.indexWhere((p) => p.id == productId);
      if (index == -1) return UpdateResult(success: false);

      final product = _products[index];
      final oldStock = product.stock;
      final stockChange = newStock - oldStock;

      final updatedProduct = product.copyWith(
        stock: newStock,
        updatedAt: DateTime.now(),
      );

      final db = await _localDatabaseService.database;
      await db.update(
        'products',
        updatedProduct.toMap(),
        where: 'id = ?',
        whereArgs: [productId],
      );

      if (_offlineManager.isOnline) {
        try {
          final productService = ProductService(FirebaseFirestore.instance);
          final inventoryService = InventoryService(FirebaseFirestore.instance);
          await productService.updateProduct(updatedProduct);

          final movementType = stockChange > 0 ? 'stock_in' : 'stock_out';
          await inventoryService.insertStockMovement(
            productId,
            product.name,
            movementType,
            stockChange.abs(),
            reason ?? 'Manual adjustment',
          );
        } catch (e) {
          // Fallback to queue on failure
          await _offlineManager.queueOperation(
            OfflineOperation(
              id: updatedProduct.id!,
              type: OperationType.updateProduct,
              collectionName: 'products',
              documentId: updatedProduct.id,
              data: updatedProduct.toMap(),
              timestamp: DateTime.now(),
            ),
          );
        }
      } else {
        await _offlineManager.queueOperation(
          OfflineOperation(
            id: updatedProduct.id!,
            type: OperationType.updateProduct,
            collectionName: 'products',
            documentId: updatedProduct.id,
            data: updatedProduct.toMap(),
            timestamp: DateTime.now(),
          ),
        );
      }

      _products[index] = updatedProduct;
      initializeVisualStock();

      _checkStockAlerts(updatedProduct);

      notifyListeners();
      return UpdateResult(success: true);
    } catch (e) {
      // Rollback local DB/memory to previous stock
      try {
        final db = await _localDatabaseService.database;
        final original = getProductById(productId);
        if (original != null) {
          await db.update(
            'products',
            original.copyWith(stock: original.stock).toMap(),
            where: 'id = ?',
            whereArgs: [productId],
          );
        }
      } catch (_) {}
      _error = 'Error updating stock: ${e.toString()}';
      notifyListeners();
      ErrorLogger.logError(
        'Error updating stock',
        error: e,
        context: 'InventoryProvider.updateStock',
      );
      return UpdateResult(success: false);
    }
  }

  Future<Product?> getProductByBarcode(String barcode) async {
    try {
      final db = await _localDatabaseService.database;
      final maps = await db.query(
        'products',
        where: 'barcode = ?',
        whereArgs: [barcode],
      );

      if (maps.isNotEmpty) {
        return Product.fromMap(maps.first);
      } else {
        if (_offlineManager.isOnline) {
          final productService = ProductService(FirebaseFirestore.instance);
          final product = await productService.getProductByBarcode(barcode);
          if (product != null) {
            await _saveProductsToLocalDB([product]);
          }
          return product;
        }
      }
      return null;
    } catch (e) {
      _error = 'Error getting product by barcode: ${e.toString()}';
      notifyListeners();
      ErrorLogger.logError(
        'Error getting product by barcode',
        error: e,
        context: 'InventoryProvider.getProductByBarcode',
      );
      return null;
    }
  }

  bool isStockAvailable(String productId, int requestedQuantity) {
    final product = getProductById(productId);
    if (product == null) return false;

    final reservedQuantity = _reservedStock[productId] ?? 0;
    final availableStock = product.stock - reservedQuantity;

    return availableStock >= requestedQuantity;
  }

  bool reserveStock(String productId, int quantity) {
    if (!isStockAvailable(productId, quantity)) {
      _error = 'Insufficient stock available for reservation';
      notifyListeners();
      return false;
    }

    _reservedStock[productId] = (_reservedStock[productId] ?? 0) + quantity;
    notifyListeners();
    return true;
  }

  void releaseReservedStock(String productId, int quantity) {
    final currentReserved = _reservedStock[productId] ?? 0;
    final newReserved = (currentReserved - quantity).clamp(0, currentReserved);

    if (newReserved == 0) {
      _reservedStock.remove(productId);
    } else {
      _reservedStock[productId] = newReserved;
    }
    notifyListeners();
  }

  int getAvailableStock(String productId) {
    final product = getProductById(productId);
    if (product == null) return 0;

    final reservedQuantity = _reservedStock[productId] ?? 0;
    return (product.stock - reservedQuantity).clamp(0, product.stock);
  }

  Future<bool> receiveStock(String productId, int quantity) async {
    try {
      final index = _products.indexWhere((p) => p.id == productId);
      if (index == -1) {
        _error = 'Product not found';
        notifyListeners();
        return false;
      }

      if (quantity <= 0) {
        _error = 'Quantity must be greater than zero';
        notifyListeners();
        return false;
      }

      final product = _products[index];
      final newStock = product.stock + quantity;
      final result = await updateStock(
        productId,
        newStock,
        reason: 'Stock received via barcode scan',
      );

      if (!result.success) {
        _error = 'Failed to update stock';
        notifyListeners();
      }

      return result.success;
    } catch (e) {
      _error = 'Error receiving stock: ${e.toString()}';
      notifyListeners();
      ErrorLogger.logError(
        'Error receiving stock',
        error: e,
        context: 'InventoryProvider.receiveStock',
      );
      return false;
    }
  }

  /// Receive stock with FIFO batch tracking
  /// This creates a new batch and updates product stock
  Future<bool> receiveStockWithCost(
    String productId,
    int quantity,
    double newCost, {
    String? supplierId,
    String? notes,
  }) async {
    try {
      final index = _products.indexWhere((p) => p.id == productId);
      if (index == -1) {
        _error = 'Product not found';
        notifyListeners();
        return false;
      }

      if (quantity <= 0) {
        _error = 'Quantity must be greater than zero';
        notifyListeners();
        return false;
      }

      if (newCost < 0) {
        _error = 'Cost cannot be negative';
        notifyListeners();
        return false;
      }

      final product = _products[index];

      // Create new batch
      final batch = await _batchService.createBatch(
        productId: productId,
        quantity: quantity,
        unitCost: newCost,
        supplierId: supplierId,
        notes: notes,
      );

      // Calculate new totals from all batches
      final totalStock = await _batchService.getTotalAvailableStock(productId);
      final averageCost = await _batchService.calculateAverageCost(productId);

      // Update product with new stock and average cost (for reference)
      final updatedProduct = product.copyWith(
        stock: totalStock,
        cost: averageCost,
        updatedAt: DateTime.now(),
        version: product.version + 1,
      );

      // Update in local database
      final db = await _localDatabaseService.database;
      await db.update(
        'products',
        updatedProduct.toMap(),
        where: 'id = ?',
        whereArgs: [productId],
      );

      // Update in memory
      _products[index] = updatedProduct;
      _productCache[productId] = updatedProduct;

      // Sync to Firestore or queue for offline
      if (_offlineManager.isOnline) {
        try {
          final productService = ProductService(FirebaseFirestore.instance);
          final inventoryService = InventoryService(FirebaseFirestore.instance);
          final costHistoryService = CostHistoryService(
            FirebaseFirestore.instance,
          );

          // Update product
          await productService.updateProduct(updatedProduct);

          // Record stock movement
          await inventoryService.insertStockMovement(
            productId,
            product.name,
            'stock_in',
            quantity,
            'Batch ${batch.batchNumber}: $quantity units @ ₱${newCost.toStringAsFixed(2)}',
          );

          // Record cost history with the batch cost
          await costHistoryService.insertCostHistory(productId, newCost);

          // Record price history if needed
          if (product.sellingPrice == null) {
            final sellingPrice = await TaxService.calculateSellingPriceWithRule(
              averageCost,
              productId: productId,
              categoryName: product.category,
            );
            final priceHistory = PriceHistory(
              id: const Uuid().v4(),
              productId: productId,
              price: sellingPrice,
              timestamp: DateTime.now(),
            );
            await FirebaseFirestore.instance
                .collection(AppConstants.priceHistoryCollection)
                .doc(priceHistory.id)
                .set(priceHistory.toMap());
          }
        } catch (e) {
          // Fallback to offline queue
          await _offlineManager.queueOperation(
            OfflineOperation(
              id: updatedProduct.id!,
              type: OperationType.updateProduct,
              collectionName: 'products',
              documentId: updatedProduct.id,
              data: updatedProduct.toMap(),
              timestamp: DateTime.now(),
              version: updatedProduct.version,
            ),
          );

          // Queue cost history
          final costHistory = CostHistory(
            id: const Uuid().v4(),
            productId: productId,
            cost: newCost,
            timestamp: DateTime.now(),
          );
          await _offlineManager.queueOperation(
            OfflineOperation(
              id: costHistory.id,
              type: OperationType.insertCostHistory,
              collectionName: 'costHistory',
              documentId: costHistory.id,
              data: costHistory.toMap(),
              timestamp: DateTime.now(),
            ),
          );
        }
      } else {
        // Offline mode - queue all operations
        await _offlineManager.queueOperation(
          OfflineOperation(
            id: updatedProduct.id!,
            type: OperationType.updateProduct,
            collectionName: 'products',
            documentId: updatedProduct.id,
            data: updatedProduct.toMap(),
            timestamp: DateTime.now(),
            version: updatedProduct.version,
          ),
        );

        // Queue cost history
        final costHistory = CostHistory(
          id: const Uuid().v4(),
          productId: productId,
          cost: newCost,
          timestamp: DateTime.now(),
        );
        await _offlineManager.queueOperation(
          OfflineOperation(
            id: costHistory.id,
            type: OperationType.insertCostHistory,
            collectionName: 'costHistory',
            documentId: costHistory.id,
            data: costHistory.toMap(),
            timestamp: DateTime.now(),
          ),
        );
      }

      initializeVisualStock();
      _checkStockAlerts(updatedProduct);
      notifyListeners();

      ErrorLogger.logInfo(
        'Batch created: ${batch.batchNumber} for ${product.name}, Qty: $quantity @ ₱${newCost.toStringAsFixed(2)}, Avg Cost: ₱${averageCost.toStringAsFixed(2)}',
        context: 'InventoryProvider.receiveStockWithCost',
      );

      return true;
    } catch (e) {
      _error = 'Error receiving stock with cost: ${e.toString()}';
      notifyListeners();
      ErrorLogger.logError(
        'Error receiving stock with cost',
        error: e,
        context: 'InventoryProvider.receiveStockWithCost',
      );
      return false;
    }
  }

  /// Get all batches for a product (ordered by FIFO)
  Future<List<InventoryBatch>> getBatchesForProduct(String productId) async {
    try {
      return await _batchService.getBatchesByFIFO(productId);
    } catch (e) {
      ErrorLogger.logError(
        'Error getting batches for product',
        error: e,
        context: 'InventoryProvider.getBatchesForProduct',
      );
      return [];
    }
  }

  /// Get all batches including depleted ones
  Future<List<InventoryBatch>> getAllBatchesForProduct(String productId) async {
    try {
      return await _batchService.getAllBatches(productId);
    } catch (e) {
      ErrorLogger.logError(
        'Error getting all batches for product',
        error: e,
        context: 'InventoryProvider.getAllBatchesForProduct',
      );
      return [];
    }
  }

  Future<bool> reduceStock(
    String productId,
    int quantity, {
    String? reason,
    bool offline = false,
  }) async {
    // Optimistic: update locally, rollback if queue also fails
    try {
      final index = _products.indexWhere((p) => p.id == productId);
      if (index == -1) {
        _error = 'Product not found';
        notifyListeners();
        return false;
      }

      final product = _products[index];
      if (product.stock < quantity) {
        _error = 'Insufficient stock for ${product.name}';
        notifyListeners();
        return false;
      }

      final newStock = product.stock - quantity;
      final updatedProduct = product.copyWith(
        stock: newStock,
        updatedAt: DateTime.now(),
      );

      final db = await _localDatabaseService.database;
      await db.update(
        'products',
        updatedProduct.toMap(),
        where: 'id = ?',
        whereArgs: [productId],
      );

      if (!offline && _offlineManager.isOnline) {
        try {
          final productService = ProductService(FirebaseFirestore.instance);
          final inventoryService = InventoryService(FirebaseFirestore.instance);
          await productService.updateProduct(updatedProduct);

          final movementType = 'stock_out';
          await inventoryService.insertStockMovement(
            productId,
            product.name,
            movementType,
            quantity,
            reason ?? 'Sale',
          );
        } catch (e) {
          // Fallback to queue if online write fails
          await _offlineManager.queueOperation(
            OfflineOperation(
              id: updatedProduct.id!,
              type: OperationType.updateProduct,
              collectionName: 'products',
              documentId: updatedProduct.id,
              data: updatedProduct.toMap(),
              timestamp: DateTime.now(),
            ),
          );
          // Also queue stock movement so it appears in reports after sync
          await _offlineManager.queueOperation(
            OfflineOperation(
              type: OperationType.insertStockMovement,
              collectionName: AppConstants.stockMovementsCollection,
              data: {
                'productId': productId,
                'productName': product.name,
                'movementType': 'stock_out',
                'quantity': quantity,
                'reason': reason ?? 'Sale',
                'createdAt': FieldValue.serverTimestamp(),
              },
              timestamp: DateTime.now(),
            ),
          );
        }
      } else {
        // If explicitly offline mode or connectivity is offline, queue the update
        await _offlineManager.queueOperation(
          OfflineOperation(
            id: updatedProduct.id!,
            type: OperationType.updateProduct,
            collectionName: 'products',
            documentId: updatedProduct.id,
            data: updatedProduct.toMap(),
            timestamp: DateTime.now(),
          ),
        );
        // Queue stock movement for offline reduce stock (e.g., sales/credit)
        await _offlineManager.queueOperation(
          OfflineOperation(
            type: OperationType.insertStockMovement,
            collectionName: AppConstants.stockMovementsCollection,
            data: {
              'productId': productId,
              'productName': product.name,
              'movementType': 'stock_out',
              'quantity': quantity,
              'reason': reason ?? 'Sale',
              'createdAt': FieldValue.serverTimestamp(),
            },
            timestamp: DateTime.now(),
          ),
        );
      }

      _products[index] = updatedProduct;
      initializeVisualStock();

      releaseReservedStock(productId, quantity);

      _checkStockAlerts(updatedProduct);

      notifyListeners();
      return true;
    } catch (e) {
      // Rollback local DB/memory to previous stock
      try {
        final db = await _localDatabaseService.database;
        final product = getProductById(productId);
        if (product != null) {
          await db.update(
            'products',
            product.copyWith(stock: product.stock + quantity).toMap(),
            where: 'id = ?',
            whereArgs: [productId],
          );
          final index = _products.indexWhere((p) => p.id == productId);
          if (index != -1) {
            _products[index] = product.copyWith(
              stock: product.stock + quantity,
            );
            initializeVisualStock();
          }
        }
      } catch (_) {}
      _error = 'Error reducing stock: ${e.toString()}';
      notifyListeners();
      ErrorLogger.logError(
        'Error reducing stock',
        error: e,
        context: 'InventoryProvider.reduceStock',
      );
      return false;
    }
  }

  Future<bool> addLoss({
    required String productId,
    required int quantity,
    required LossReason reason,
  }) async {
    try {
      final product = getProductById(productId);
      if (product == null) {
        _error = 'Product not found';
        notifyListeners();
        return false;
      }

      if (product.stock < quantity) {
        _error = 'Insufficient stock for ${product.name}';
        notifyListeners();
        return false;
      }

      final totalCost = product.cost * quantity;
      final lossId = const Uuid().v4();
      final currentUserId = _authProvider.currentUser?.id;

      final newLoss = Loss(
        id: lossId,
        productId: productId,
        quantity: quantity,
        totalCost: totalCost,
        reason: reason,
        timestamp: DateTime.now(),
        recordedBy: currentUserId,
      );

      // Reduce stock first
      final stockReduced = await reduceStock(
        productId,
        quantity,
        reason: reason.toDisplayString(), // Pass the display string of the enum
      );

      if (!stockReduced) {
        _error = 'Failed to reduce stock for loss';
        notifyListeners();
        return false;
      }

      // Then record the loss
      final db = await _localDatabaseService.database;
      await db.insert(
        'losses',
        newLoss.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );

      if (_offlineManager.isOnline) {
        try {
          final inventoryService = InventoryService(FirebaseFirestore.instance);
          await inventoryService.insertLoss(newLoss);
        } catch (e) {
          await _offlineManager.queueOperation(
            OfflineOperation(
              id: newLoss.id!,
              type: OperationType.insertLoss,
              collectionName: 'losses',
              documentId: newLoss.id,
              data: newLoss.toMap(),
              timestamp: DateTime.now(),
            ),
          );
        }
      } else {
        await _offlineManager.queueOperation(
          OfflineOperation(
            id: newLoss.id!,
            type: OperationType.insertLoss,
            collectionName: 'losses',
            documentId: newLoss.id,
            data: newLoss.toMap(),
            timestamp: DateTime.now(),
          ),
        );
      }
      notifyListeners();
      return true;
    } catch (e) {
      _error = 'Error adding loss: ${e.toString()}';
      ErrorLogger.logError(
        'Error adding loss',
        error: e,
        context: 'InventoryProvider.addLoss',
      );
      notifyListeners();
      return false;
    }
  }

  Future<bool> batchUpdateStock(
    Map<String, int> stockUpdates, {
    String? reason,
  }) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      for (final entry in stockUpdates.entries) {
        final result = await updateStock(
          entry.key,
          entry.value,
          reason: reason,
        );
        if (!result.success) {
          _error = 'Failed to update stock for product ID: ${entry.key}';
          _isLoading = false;
          notifyListeners();
          return false;
        }
      }

      _isLoading = false;
      notifyListeners();
      return true;
    } catch (e) {
      _error = 'Error in batch stock update: ${e.toString()}';
      _isLoading = false;
      notifyListeners();
      ErrorLogger.logError(
        'Error in batch stock update',
        error: e,
        context: 'InventoryProvider.batchUpdateStock',
      );
      return false;
    }
  }

  Future<bool> reconcileStock(Map<String, int> physicalCounts) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final discrepancies = <String, Map<String, int>>{};

      for (final entry in physicalCounts.entries) {
        final productId = entry.key;
        final physicalCount = entry.value;
        final product = getProductById(productId);

        if (product != null && product.stock != physicalCount) {
          discrepancies[productId] = {
            'system': product.stock,
            'physical': physicalCount,
            'difference': (physicalCount - product.stock).toInt(),
          };

          final result = await updateStock(
            productId,
            physicalCount,
            reason: 'Stock reconciliation',
          );
          if (!result.success) {
            _error = 'Failed to reconcile stock for product ID: $productId';
            _isLoading = false;
            notifyListeners();
            return false;
          }
        }
      }

      if (discrepancies.isNotEmpty) {
        ErrorLogger.logInfo(
          'Stock reconciliation completed with ${discrepancies.length} discrepancies',
          context: 'InventoryProvider.reconcileStock',
        );
      }

      _isLoading = false;
      notifyListeners();
      return true;
    } catch (e) {
      _error = 'Error in stock reconciliation: ${e.toString()}';
      _isLoading = false;
      notifyListeners();
      ErrorLogger.logError(
        'Error in stock reconciliation',
        error: e,
        context: 'InventoryProvider.reconcileStock',
      );
      return false;
    }
  }

  void setReorderPoint(String productId, int reorderPoint) {
    _reorderPoints[productId] = reorderPoint;
    notifyListeners();
  }

  int getReorderPoint(String productId) {
    return _reorderPoints[productId] ?? 5;
  }

  List<Product> getProductsNeedingReorder() {
    return _products.where((product) {
      if (product.id == null) return false;
      final reorderPoint = _reorderPoints[product.id!] ?? 5;
      return product.stock <= reorderPoint;
    }).toList();
  }

  // Helper method to update product cache
  void _updateProductCache(List<Product> products) {
    for (var product in products) {
      if (product.id != null) {
        _productCache[product.id!] = product;
      }
    }
  }

  Product? getProductById(String id) {
    try {
      // First try to find it in the current filtered products list
      return _products.firstWhere((product) => product.id == id);
    } catch (e) {
      // If not found in filtered list, try to get it from the product cache
      return _productCache[id];
    }
  }

  Future<void> refreshProducts() async {
    await loadProducts(refresh: true);
  }

  void _startProductsListener() {
    // Cancel previous listener if any
    _productsSubscription?.cancel();

    // Only listen when online
    if (!_offlineManager.isOnline) {
      return;
    }

    final productsCol = FirebaseFirestore.instance.collection(
      AppConstants.productsCollection,
    );

    _productsSubscription = productsCol.snapshots().listen(
      (snapshot) async {
        try {
          final db = await _localDatabaseService.database;
          final batch = db.batch();

          bool changed = false;

          for (final change in snapshot.docChanges) {
            final data = change.doc.data();
            final String id = change.doc.id;

            if (change.type == DocumentChangeType.removed) {
              // Remove locally
              batch.delete('products', where: 'id = ?', whereArgs: [id]);
              _products.removeWhere((p) => p.id == id);
              changed = true;
              continue;
            }

            if (data == null) {
              continue;
            }

            data['id'] = id;
            final remoteProduct = Product.fromMap(data);

            // Upsert into local DB
            batch.insert(
              'products',
              remoteProduct.toMap(),
              conflictAlgorithm: ConflictAlgorithm.replace,
            );

            // Merge into memory list
            final idx = _products.indexWhere((p) => p.id == id);
            if (idx == -1) {
              _products.add(remoteProduct);
            } else {
              // Prefer highest version if available
              final local = _products[idx];
              if (remoteProduct.version >= local.version) {
                _products[idx] = remoteProduct;
              }
            }
            changed = true;
          }

          if (changed) {
            await batch.commit(noResult: true);
            initializeVisualStock();
            notifyListeners();
          }
        } catch (e) {
          ErrorLogger.logError(
            'Error merging product snapshot changes',
            error: e,
            context: 'InventoryProvider._startProductsListener',
          );
        }
      },
      onError: (e) {
        ErrorLogger.logError(
          'Products listener error',
          error: e,
          context: 'InventoryProvider._startProductsListener',
        );
      },
    );
  }

  @override
  void dispose() {
    _productsSubscription?.cancel();
    super.dispose();
  }

  void _checkStockAlerts(Product product) {
    if (product.id == null) return;

    final String productId = product.id!;
    final int currentStock = product.stock;
    final int lowThreshold = product.minStock;

    final _StockAlertState currentState = currentStock == 0
        ? _StockAlertState.out
        : (currentStock <= lowThreshold
              ? _StockAlertState.low
              : _StockAlertState.normal);

    final _StockAlertState? previousState = _lastAlertStates[productId];
    _lastAlertStates[productId] = currentState;

    // Only notify on state transitions to avoid spamming
    if (previousState == currentState) return;

    final notificationService = NotificationService();

    if (currentState == _StockAlertState.out) {
      notificationService.showNotification(
        productId.hashCode,
        'Out of stock',
        '${product.name} is out of stock',
        'out_of_stock:$productId',
      );
      return;
    }

    if (currentState == _StockAlertState.low) {
      notificationService.showNotification(
        productId.hashCode ^ 1,
        'Low stock',
        '${product.name} is low on stock ($currentStock left)',
        'low_stock:$productId',
      );
      return;
    }

    if (currentState == _StockAlertState.normal &&
        (previousState == _StockAlertState.low ||
            previousState == _StockAlertState.out)) {
      // Optional: notify restock
      notificationService.showNotification(
        productId.hashCode ^ 2,
        'Restocked',
        '${product.name} has been restocked',
        'restocked:$productId',
      );
    }
  }
}

enum _StockAlertState { normal, low, out }




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\providers\sales_provider.dart
â•‘ SIZE: 22.35 KB
â•‘ MODIFIED: 10/26/2025 12:52:00
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:developer';

import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:prostock/models/offline_operation.dart';
import 'package:prostock/models/batch_allocation.dart';
import 'package:prostock/providers/auth_provider.dart';
import 'package:prostock/services/batch_service.dart';
import 'package:prostock/services/firestore/sale_service.dart';
import 'package:prostock/services/local_database_service.dart';
import 'package:prostock/services/offline_manager.dart';
import 'package:uuid/uuid.dart';
import '../models/sale.dart';
import '../models/sale_item.dart';
import '../models/product.dart';
import '../models/receipt.dart';
import '../utils/currency_utils.dart';
import '../utils/error_logger.dart';
import 'inventory_provider.dart';

import 'package:prostock/providers/credit_provider.dart';
import 'package:prostock/services/demand_analysis_service.dart';
import 'package:prostock/services/notification_service.dart';
import 'package:prostock/services/tax_service.dart';

class SalesProvider with ChangeNotifier {
  List<Sale> _sales = [];
  List<SaleItem> _saleItems = [];
  final List<SaleItem> _currentSaleItems = [];
  bool _isLoading = false;
  String? _error;
  DocumentSnapshot? _lastDocument;

  final InventoryProvider _inventoryProvider;
  final OfflineManager _offlineManager;
  final AuthProvider _authProvider;
  final CreditProvider _creditProvider;
  final BatchService _batchService = BatchService();
  late final DemandAnalysisService _demandAnalysisService;

  final Map<String, List<Sale>> _cache = {};
  final Map<String, DateTime> _cacheTimestamps = {};
  static const Duration _cacheExpiry = Duration(minutes: 3);
  static const int _pageSize = 30;
  bool _hasMoreData = true;

  SalesProvider({
    required InventoryProvider inventoryProvider,
    required OfflineManager offlineManager,
    required AuthProvider authProvider,
    required CreditProvider creditProvider,
  }) : _inventoryProvider = inventoryProvider,
       _offlineManager = offlineManager,
       _authProvider = authProvider,
       _creditProvider = creditProvider {
    _demandAnalysisService = DemandAnalysisService(
      LocalDatabaseService.instance,
      NotificationService(),
    );
  }

  List<Sale> get sales => _sales
      .where((s) => !_isPaymentSale(s.paymentMethod))
      .toList(growable: false);
  List<SaleItem> get saleItems => _saleItems;
  List<SaleItem> get currentSaleItems => _currentSaleItems;
  bool get isLoading => _isLoading;
  String? get error => _error;
  bool get hasMoreData => _hasMoreData;

  void clearError() {
    _error = null;
    notifyListeners();
  }

  double get currentSaleTotal =>
      _currentSaleItems.fold(0.0, (total, item) => total + item.totalPrice);

  String get formattedCurrentSaleTotal =>
      CurrencyUtils.formatCurrency(currentSaleTotal);

  Future<void> loadSales({
    bool refresh = false,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    final cacheKey =
        'sales_${startDate?.millisecondsSinceEpoch ?? 'all'}_${endDate?.millisecondsSinceEpoch ?? 'all'}';

    if (!refresh && !_shouldRefreshCache(cacheKey)) {
      final cachedData = _getCachedData(cacheKey);
      if (cachedData != null) {
        _sales = cachedData;
        notifyListeners();
        return;
      }
    }

    _isLoading = true;
    _error = null;
    if (refresh) {
      _hasMoreData = true;
      _lastDocument = null;
    }
    notifyListeners();

    try {
      List<Sale> onlineSales = [];
      if (_offlineManager.isOnline) {
        final saleService = SaleService(FirebaseFirestore.instance);
        final result = await saleService.getSalesPaginated(
          limit: _pageSize,
          lastDocument: _lastDocument,
          startDate: startDate,
          endDate: endDate,
        );
        onlineSales = result.items;
        _lastDocument = result.lastDocument;
        _hasMoreData = result.items.length == _pageSize;
        log('SalesProvider: Fetched ${onlineSales.length} online sales.');
      }

      final localSalesData = await LocalDatabaseService.instance.getSales();
      final localSales = localSalesData.map((e) => Sale.fromMap(e)).toList();
      final pendingSales = await _offlineManager.getPendingSales();
      log('SalesProvider: Fetched ${localSales.length} local sales.');
      log('SalesProvider: Fetched ${pendingSales.length} pending sales.');

      final Map<String, Sale> mergedSalesMap = {
        for (var s in onlineSales) s.id!: s,
        for (var s in localSales) s.id!: s,
        for (var s in pendingSales) s.id!: s,
      };

      _sales = mergedSalesMap.values
          .where((s) => !_isPaymentSale(s.paymentMethod))
          .toList();
      _sales.sort((a, b) => b.createdAt.compareTo(a.createdAt));
      log('SalesProvider: Merged ${_sales.length} total sales.');

      if (_sales.isNotEmpty) {
        final saleIds = _sales.map((s) => s.id!).toList();
        if (_offlineManager.isOnline) {
          final saleService = SaleService(FirebaseFirestore.instance);
          _saleItems = await saleService.getSaleItemsBySaleIds(saleIds);
        } else {
          final localSaleItems = await LocalDatabaseService.instance
              .getSaleItemsBySaleIds(saleIds);
          _saleItems = localSaleItems
              .map((item) => SaleItem.fromMap(item))
              .toList();
        }
      }

      _setCachedData(cacheKey, _sales);
    } catch (e) {
      _error = 'Failed to load sales: ${e.toString()}';
      ErrorLogger.logError(
        'Error loading sales',
        error: e,
        context: 'SalesProvider.loadSales',
      );
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> loadMoreSales({DateTime? startDate, DateTime? endDate}) async {
    if (_isLoading || !_hasMoreData) return;

    _isLoading = true;
    notifyListeners();

    try {
      final saleService = SaleService(FirebaseFirestore.instance);
      final result = await saleService.getSalesPaginated(
        limit: _pageSize,
        lastDocument: _lastDocument,
        startDate: startDate,
        endDate: endDate,
      );

      _sales.addAll(result.items);
      _lastDocument = result.lastDocument;
      _hasMoreData = result.items.length == _pageSize;

      final cacheKey =
          'sales_${startDate?.millisecondsSinceEpoch ?? 'all'}_${endDate?.millisecondsSinceEpoch ?? 'all'}';
      _setCachedData(cacheKey, _sales);
    } catch (e) {
      _error = 'Failed to load more sales: ${e.toString()}';
      ErrorLogger.logError(
        'Error loading more sales',
        error: e,
        context: 'SalesProvider.loadMoreSales',
      );
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  bool _shouldRefreshCache(String key) {
    final timestamp = _cacheTimestamps[key];
    if (timestamp == null) return true;
    return DateTime.now().difference(timestamp) > _cacheExpiry;
  }

  List<Sale>? _getCachedData(String key) {
    return _cache[key];
  }

  void _setCachedData(String key, List<Sale> data) {
    _cache[key] = List.from(
      data.where((s) => !_isPaymentSale(s.paymentMethod)),
    );
    _cacheTimestamps[key] = DateTime.now();
  }

  void clearCache() {
    _cache.clear();
    _cacheTimestamps.clear();
  }

  Future<void> addItemToCurrentSale(Product product, int quantity) async {
    if (quantity <= 0) {
      _error = 'Invalid quantity';
      notifyListeners();
      return;
    }

    if (product.id == null) {
      _error = 'Product ID cannot be null when adding to sale';
      ErrorLogger.logError(
        'Product ID is null',
        context: 'SalesProvider.addItemToCurrentSale',
        error: 'Product: ${product.name}',
      );
      notifyListeners();
      return;
    }

    try {
      // Use fixed selling price if set, otherwise calculate
      final calculatedPrice = await TaxService.calculateSellingPriceWithRule(
        product.cost,
        productId: product.id,
        categoryName: product.category,
      );
      final price = product.getPriceForSale(calculatedPrice);

      // Check if this product already exists in cart
      final existingItems = _currentSaleItems
          .where((item) => item.productId == product.id)
          .toList();

      int totalQuantityInCart = existingItems.fold(
        0,
        (total, item) => total + item.quantity,
      );
      int totalQuantityNeeded = totalQuantityInCart + quantity;

      // Allocate stock using FIFO
      final allocations = await _batchService.allocateStockFIFO(
        product.id!,
        totalQuantityNeeded,
      );

      // Remove existing items for this product
      _currentSaleItems.removeWhere((item) => item.productId == product.id);

      // Add new items based on FIFO allocations
      for (final allocation in allocations) {
        _currentSaleItems.add(
          SaleItem(
            saleId: '',
            productId: product.id!,
            batchId: allocation.batchId,
            quantity: allocation.quantity,
            unitPrice: price,
            unitCost: allocation.unitCost,
            batchCost: allocation.unitCost,
            totalPrice: price * allocation.quantity,
          ),
        );
      }

      // Update visual stock
      _inventoryProvider.decreaseVisualStock(product.id!, quantity);
      _error = null;
      notifyListeners();
    } catch (e) {
      if (e is InsufficientStockException) {
        _error =
            'Insufficient stock. Available: ${e.available}, Requested: ${e.requested}';
      } else {
        _error = 'Error adding item to sale: ${e.toString()}';
      }
      notifyListeners();
      ErrorLogger.logError(
        'Error adding item to current sale',
        error: e,
        context: 'SalesProvider.addItemToCurrentSale',
      );
    }
  }

  void removeItemFromCurrentSale(int index) {
    if (index >= 0 && index < _currentSaleItems.length) {
      final item = _currentSaleItems[index];
      _inventoryProvider.increaseVisualStock(item.productId, item.quantity);
      _currentSaleItems.removeAt(index);
      notifyListeners();
    }
  }

  Future<void> updateItemQuantity(int index, int newQuantity) async {
    if (index < 0 || index >= _currentSaleItems.length) {
      _error = 'Invalid item index';
      notifyListeners();
      return;
    }

    if (newQuantity < 0) {
      _error = 'Quantity cannot be negative';
      notifyListeners();
      return;
    }

    final currentItem = _currentSaleItems[index];
    final product = _inventoryProvider.getProductById(currentItem.productId);

    if (product == null) {
      _error = 'Product not found';
      notifyListeners();
      return;
    }

    // Get all items for this product in cart
    final productItems = _currentSaleItems
        .where((item) => item.productId == product.id)
        .toList();
    final currentTotalQty = productItems.fold(
      0,
      (total, item) => total + item.quantity,
    );

    if (newQuantity == 0) {
      // Remove this specific item
      _inventoryProvider.increaseVisualStock(product.id!, currentItem.quantity);
      _currentSaleItems.removeAt(index);
    } else {
      // Calculate the difference
      final quantityDifference = newQuantity - currentItem.quantity;

      if (quantityDifference > 0) {
        // Increasing quantity - need more stock
        final availableStock = _inventoryProvider.getVisualStock(product.id!);
        if (quantityDifference > availableStock) {
          _error =
              'Insufficient stock for ${product.name}. Available: $availableStock';
          notifyListeners();
          return;
        }
        _inventoryProvider.decreaseVisualStock(product.id!, quantityDifference);
      } else if (quantityDifference < 0) {
        // Decreasing quantity - free up stock
        _inventoryProvider.increaseVisualStock(
          product.id!,
          -quantityDifference,
        );
      }

      // Recalculate total needed quantity
      final newTotalQty = currentTotalQty + quantityDifference;

      try {
        // Re-allocate using FIFO
        final allocations = await _batchService.allocateStockFIFO(
          product.id!,
          newTotalQty,
        );

        // Use fixed price if set
        final calculatedPrice = await TaxService.calculateSellingPriceWithRule(
          product.cost,
          productId: product.id,
          categoryName: product.category,
        );
        final price = product.getPriceForSale(calculatedPrice);

        // Remove all items for this product
        _currentSaleItems.removeWhere((item) => item.productId == product.id);

        // Add re-allocated items
        for (final allocation in allocations) {
          _currentSaleItems.add(
            SaleItem(
              saleId: '',
              productId: product.id!,
              batchId: allocation.batchId,
              quantity: allocation.quantity,
              unitPrice: price,
              unitCost: allocation.unitCost,
              batchCost: allocation.unitCost,
              totalPrice: price * allocation.quantity,
            ),
          );
        }
      } catch (e) {
        _error = 'Error updating quantity: ${e.toString()}';
        notifyListeners();
        return;
      }
    }

    _error = null;
    notifyListeners();
  }

  Future<Receipt?> completeSale({
    String? customerId,
    required String paymentMethod,
    DateTime? dueDate,
  }) async {
    if (_currentSaleItems.isEmpty) {
      _error = 'No items in cart';
      notifyListeners();
      return null;
    }

    if (paymentMethod == 'credit' && customerId == null) {
      _error = 'Please select a customer for credit transactions.';
      notifyListeners();
      return null;
    }

    _isLoading = true;
    _error = null;
    notifyListeners();

    Receipt? receipt;

    try {
      log('Completing sale...');
      final List<Product> productsInSale = [];
      for (final item in _currentSaleItems) {
        final product = _inventoryProvider.getProductById(item.productId);
        if (product == null) {
          _error = 'Product not found: \${item.productId}';
          return null;
        }
        if (product.stock < item.quantity) {
          _error = 'Insufficient stock for product: \${product.name}';
          return null;
        }
        productsInSale.add(product);
      }

      final currentUser = _authProvider.currentUser;
      if (currentUser == null || currentUser.id == null) {
        throw Exception('User not authenticated or user ID is null');
      }
      if (paymentMethod == 'credit') {
        // Delegate to CreditProvider for credit sales (no Sale record creation)
        receipt = await _creditProvider.recordCreditSale(
          customerId: customerId!,
          items: _currentSaleItems,
          total: currentSaleTotal,
          dueDate: dueDate,
          userId: currentUser.id!,
        );
        if (receipt == null) {
          _error = _creditProvider.error;
          return null;
        }
      } else {
        final sale = Sale(
          customerId: customerId,
          totalAmount: currentSaleTotal,
          paymentMethod: paymentMethod,
          status: 'completed',
          createdAt: DateTime.now(),
          dueDate: dueDate,
          userId: currentUser.id!,
        );

        // Local-first for all connectivity states
        final saleId = const Uuid().v4();
        final offlineSale = sale.copyWith(id: saleId);

        final List<Map<String, dynamic>> saleItems = [];
        for (final item in _currentSaleItems) {
          saleItems.add(item.copyWith(saleId: saleId).toMap());
        }

        await _offlineManager.queueOperation(
          OfflineOperation(
            id: offlineSale.id!,
            type: OperationType.createSaleTransaction,
            collectionName: 'sales',
            documentId: offlineSale.id,
            data: {'sale': offlineSale.toMap(), 'saleItems': saleItems},
            timestamp: DateTime.now(),
          ),
        );

        // Reduce batch quantities for each sale item
        for (final item in _currentSaleItems) {
          if (item.batchId != null) {
            // Reduce from specific batch
            await _batchService.reduceBatchQuantity(
              item.batchId!,
              item.quantity,
            );
          }
          // Also reduce product stock total
          await _inventoryProvider.reduceStock(
            item.productId,
            item.quantity,
            offline: !_inventoryProvider.isOnline,
          );
        }

        receipt = _createReceipt(saleId, customerId, paymentMethod);
      }

      // Don't await these, let them run in the background
      _authProvider.logActivity(
        'COMPLETE_SALE',
        details: 'Sale completed with total: ${receipt.total}',
        amount: receipt.total,
      );
      loadSales(); // No await

      // Trigger immediate demand analysis after sale
      _triggerDemandAnalysis();

      _currentSaleItems.clear();
      return receipt;
    } catch (e) {
      _error = 'Error completing sale: \${e.toString()}';
      ErrorLogger.logError(
        'Error completing sale',
        error: e,
        context: 'SalesProvider.completeSale',
      );
      return null;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> createSaleFromPayment(String customerId, double amount) async {
    final currentUser = _authProvider.currentUser;
    if (currentUser == null || currentUser.id == null) {
      throw Exception('User not authenticated or user ID is null');
    }

    final sale = Sale(
      customerId: customerId,
      totalAmount: amount,
      paymentMethod: 'credit_payment',
      status: 'completed',
      createdAt: DateTime.now(),
      userId: currentUser.id!,
    );

    // Local-first for payment-created sales as well
    final saleId = const Uuid().v4();
    final offlineSale = sale.copyWith(id: saleId);
    await _offlineManager.queueOperation(
      OfflineOperation(
        id: offlineSale.id!,
        type: OperationType.createSaleTransaction,
        collectionName: 'sales',
        documentId: offlineSale.id,
        data: {'sale': offlineSale.toMap(), 'saleItems': []},
        timestamp: DateTime.now(),
      ),
    );
    loadSales();
  }

  Receipt _createReceipt(
    String saleId,
    String? customerId,
    String paymentMethod,
  ) {
    // Group items by product to avoid duplicates
    final groupedItems = _groupItemsByProduct(_currentSaleItems);

    final List<ReceiptItem> receiptItems = [];
    for (final groupedItem in groupedItems) {
      final product = _inventoryProvider.getProductById(
        groupedItem['productId'] as String,
      );
      receiptItems.add(
        ReceiptItem(
          productName: product?.name ?? 'Unknown Product',
          quantity: groupedItem['totalQuantity'] as int,
          unitPrice: groupedItem['unitPrice'] as double,
          totalPrice: groupedItem['totalPrice'] as double,
        ),
      );
    }

    String? customerName;
    if (customerId != null) {
      customerName = 'Customer #\$customerId';
    }

    return Receipt(
      saleId: saleId,
      receiptNumber: saleId,
      timestamp: DateTime.now(),
      customerName: customerName,
      paymentMethod: paymentMethod,
      items: receiptItems,
      subtotal: currentSaleTotal,
      tax: 0.0,
      total: currentSaleTotal,
    );
  }

  void clearCurrentSale() {
    for (var item in _currentSaleItems) {
      _inventoryProvider.increaseVisualStock(item.productId, item.quantity);
    }
    _currentSaleItems.clear();
    _error = null;
    notifyListeners();
  }

  List<Map<String, dynamic>> _groupItemsByProduct(List<SaleItem> items) {
    final Map<String, Map<String, dynamic>> grouped = {};

    for (final item in items) {
      if (grouped.containsKey(item.productId)) {
        // Add to existing group
        final existing = grouped[item.productId]!;
        existing['totalQuantity'] =
            (existing['totalQuantity'] as int) + item.quantity;
        existing['totalPrice'] =
            (existing['totalPrice'] as double) + item.totalPrice;
      } else {
        // Create new group
        grouped[item.productId] = {
          'productId': item.productId,
          'unitPrice': item.unitPrice,
          'totalQuantity': item.quantity,
          'totalPrice': item.totalPrice,
        };
      }
    }

    return grouped.values.toList();
  }

  bool _isPaymentSale(String method) {
    final m = method.toLowerCase();
    return m == 'credit_payment' ||
        m == 'debt_payment' ||
        m == 'credit payment' ||
        m == 'debt payment';
  }

  Future<Map<String, dynamic>?> getSalesAnalytics({
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      final saleService = SaleService(FirebaseFirestore.instance);
      return await saleService.getSalesAnalytics(
        startDate: startDate,
        endDate: endDate,
      );
    } catch (e) {
      _error = 'Failed to get sales analytics: ${e.toString()}';
      notifyListeners();
      ErrorLogger.logError(
        'Error getting sales analytics',
        error: e,
        context: 'SalesProvider.getSalesAnalytics',
      );
      return null;
    }
  }

  /// Triggers immediate demand analysis after a sale to check for threshold suggestions
  void _triggerDemandAnalysis() {
    // Run in background without blocking the UI
    Future.microtask(() async {
      try {
        final suggestions = await _demandAnalysisService.computeSuggestions(
          highDemandThresholdPerDay: 20.0,
          minDeltaUnits: 5,
          minDeltaPercent: 0.2,
        );
        if (suggestions.isNotEmpty) {
          await _demandAnalysisService.markSuggestedNow(
            suggestions.map((s) => s.product.id!).toList(),
          );
          await _demandAnalysisService.runDailyAndNotify();
        }
      } catch (e) {
        ErrorLogger.logError(
          'Error in immediate demand analysis',
          error: e,
          context: 'SalesProvider._triggerDemandAnalysis',
        );
      }
    });
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\providers\stock_movement_provider.dart
â•‘ SIZE: 2.66 KB
â•‘ MODIFIED: 09/13/2025 12:27:46
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:prostock/services/firestore/inventory_service.dart';
import '../models/stock_movement.dart';
import '../utils/error_logger.dart';

class StockMovementProvider with ChangeNotifier {
  List<StockMovement> _movements = [];
  List<StockMovement> _allMovements = []; // For reports
  bool _isLoading = false;
  String? _error;
  DocumentSnapshot? _lastDocument;
  bool _hasMoreData = true;

  static const int _pageSize = 20;

  List<StockMovement> get movements => _movements;
  List<StockMovement> get allMovements => _allMovements; // Getter for reports
  bool get isLoading => _isLoading;
  String? get error => _error;
  bool get hasMoreData => _hasMoreData;

  void clearError() {
    _error = null;
    notifyListeners();
  }

  Future<void> loadAllMovements({
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final inventoryService = InventoryService(FirebaseFirestore.instance);
      _allMovements = await inventoryService.getAllStockMovements(
        startDate: startDate,
        endDate: endDate,
      );
    } catch (e) {
      _error = 'Failed to load all stock movements: ${e.toString()}';
      ErrorLogger.logError(
        'Error loading all stock movements',
        error: e,
        context: 'StockMovementProvider.loadAllMovements',
      );
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> loadMovements({
    bool refresh = false,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    if (_isLoading) return;

    _isLoading = true;
    if (refresh || startDate != null || endDate != null) {
      _movements = [];
      _lastDocument = null;
      _hasMoreData = true;
    }
    _error = null;
    notifyListeners();

    try {
      final inventoryService = InventoryService(FirebaseFirestore.instance);
      final result = await inventoryService.getStockMovements(
        limit: _pageSize,
        lastDocument: _lastDocument,
        startDate: startDate,
        endDate: endDate,
      );

      if (refresh) {
        _movements = result.items;
      } else {
        _movements.addAll(result.items);
      }
      
      _lastDocument = result.lastDocument;
      _hasMoreData = result.items.length == _pageSize;
    } catch (e) {
      _error = 'Failed to load stock movements: ${e.toString()}';
      ErrorLogger.logError(
        'Error loading stock movements',
        error: e,
        context: 'StockMovementProvider.loadMovements',
      );
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\providers\sync_failure_provider.dart
â•‘ SIZE: 0.43 KB
â•‘ MODIFIED: 09/02/2025 06:48:23
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/models/sync_failure.dart';

class SyncFailureProvider with ChangeNotifier {
  

  SyncFailureProvider();

  final List<SyncFailure> _failures = [];

  List<SyncFailure> get failures => _failures;

  void addFailure(SyncFailure failure) {
    _failures.add(failure);
    notifyListeners();
  }

  void clearFailures() {
    _failures.clear();
    notifyListeners();
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\providers\theme_provider.dart
â•‘ SIZE: 1.17 KB
â•‘ MODIFIED: 08/25/2025 21:20:44
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

class ThemeProvider with ChangeNotifier {
  ThemeMode _themeMode = ThemeMode.system;

  ThemeMode get themeMode => _themeMode;

  ThemeProvider() {
    _loadThemeMode();
  }

  void _loadThemeMode() async {
    final prefs = await SharedPreferences.getInstance();
    final theme = prefs.getString('themeMode') ?? 'system';
    switch (theme) {
      case 'light':
        _themeMode = ThemeMode.light;
        break;
      case 'dark':
        _themeMode = ThemeMode.dark;
        break;
      default:
        _themeMode = ThemeMode.system;
        break;
    }
    notifyListeners();
  }

  void setThemeMode(ThemeMode mode) async {
    if (_themeMode == mode) return;
    _themeMode = mode;
    final prefs = await SharedPreferences.getInstance();
    switch (mode) {
      case ThemeMode.light:
        await prefs.setString('themeMode', 'light');
        break;
      case ThemeMode.dark:
        await prefs.setString('themeMode', 'dark');
        break;
      case ThemeMode.system:
        await prefs.setString('themeMode', 'system');
        break;
    }
    notifyListeners();
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\splash_screen.dart
â•‘ SIZE: 2.86 KB
â•‘ MODIFIED: 10/02/2025 12:09:41
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../models/user_role.dart';
import '../providers/inventory_provider.dart';
import '../providers/customer_provider.dart';
import '../providers/sales_provider.dart';

class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen> {
  @override
  void initState() {
    super.initState();
    _initializeApp();
  }

  Future<void> _initializeApp() async {
    // Using a short delay to ensure the splash screen is visible briefly.
    await Future.delayed(const Duration(seconds: 2));

    if (mounted) {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final inventoryProvider = Provider.of<InventoryProvider>(
        context,
        listen: false,
      );
      final customerProvider = Provider.of<CustomerProvider>(
        context,
        listen: false,
      );
      final salesProvider = Provider.of<SalesProvider>(context, listen: false);

      // Perform all initialization tasks in parallel.
      await Future.wait([
        authProvider.checkAuthStatus(),
        inventoryProvider.loadProducts(),
        customerProvider.loadCustomers(),
        salesProvider.loadSales(),
      ]);

      if (!mounted) return;

      if (authProvider.isAuthenticated && authProvider.currentUser != null) {
        final userRole = authProvider.userRole;
        if (userRole == UserRole.admin) {
          Navigator.of(context).pushReplacementNamed('/admin');
        } else {
          Navigator.of(context).pushReplacementNamed('/user');
        }
      } else {
        Navigator.of(context).pushReplacementNamed('/login');
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Theme.of(context).primaryColor,
      body: const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.store, size: 100, color: Colors.white),
            SizedBox(height: 20),
            Text(
              'Retail Credit Manager',
              style: TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                color: Colors.white,
              ),
            ),
            SizedBox(height: 10),
            Text(
              'Managing your business made easy',
              style: TextStyle(fontSize: 16, color: Colors.white70),
            ),
            SizedBox(height: 40),
            CircularProgressIndicator(
              valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
            ),
          ],
        ),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\admin\activity_screen.dart
â•‘ SIZE: 3.32 KB
â•‘ MODIFIED: 10/04/2025 04:57:01
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/screens/admin/system_monitoring_screen.dart';
import 'package:provider/provider.dart';
import 'package:prostock/providers/auth_provider.dart';
import 'package:prostock/services/firestore/activity_service.dart';
import 'package:prostock/models/user_activity.dart';
import 'package:prostock/models/app_user.dart';
import 'package:prostock/models/user_role.dart';
import 'package:prostock/widgets/sync_status_indicator.dart';

class ActivityScreen extends StatelessWidget {
  const ActivityScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 4,
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Activity & Monitoring'),
          actions: const [SyncStatusIndicator()],
          bottom: const TabBar(
            tabs: [
              Tab(text: 'Activity'),
              Tab(text: 'Status'),
              Tab(text: 'Pending'),
              Tab(text: 'Failures'),
            ],
          ),
        ),
        body: const TabBarView(
          children: [
            UserActivityList(),
            SyncStatusWidget(),
            PendingOperationsWidget(),
            SyncFailuresWidget(),
          ],
        ),
      ),
    );
  }
}

class UserActivityList extends StatefulWidget {
  const UserActivityList({super.key});

  @override
  State<UserActivityList> createState() => _UserActivityListState();
}

class _UserActivityListState extends State<UserActivityList> {
  late Stream<List<UserActivity>> _activityStream;
  Map<String, AppUser> _usersMap = {};
  final AppUser _unknownUser = AppUser(
    id: '',
    username: 'Unknown',
    email: '',
    passwordHash: '',
    role: UserRole.user,
    createdAt: DateTime.now(),
  );

  @override
  void initState() {
    super.initState();
    _activityStream = context
        .read<ActivityService>()
        .getAllUserActivitiesStream();
    _fetchUsers();
  }

  Future<void> _fetchUsers() async {
    final users = await context.read<AuthProvider>().getAllUsersList();
    if (mounted) {
      setState(() {
        _usersMap = {for (var user in users) user.id!: user};
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<List<UserActivity>>(
      stream: _activityStream,
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting ||
            _usersMap.isEmpty) {
          return const Center(child: CircularProgressIndicator());
        }
        if (snapshot.hasError) {
          return Center(child: Text('Error: ${snapshot.error}'));
        }
        if (!snapshot.hasData || snapshot.data!.isEmpty) {
          return const Center(child: Text('No activities found.'));
        }

        final activities = snapshot.data!;

        return ListView.builder(
          itemCount: activities.length,
          itemBuilder: (context, index) {
            final activity = activities[index];
            final username =
                _usersMap[activity.userId]?.username ?? _unknownUser.username;
            return ListTile(
              title: Text('${activity.action} by $username'),
              subtitle: Text(activity.details ?? ''),
              trailing: Text('${activity.timestamp.toLocal()}'.split(' ')[0]),
            );
          },
        );
      },
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\admin\admin_screen.dart
â•‘ SIZE: 9.78 KB
â•‘ MODIFIED: 10/02/2025 15:42:18
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/screens/admin/activity_screen.dart';
import 'package:prostock/screens/settings/settings_screen.dart';
import 'package:provider/provider.dart';
import '../../providers/auth_provider.dart';
import '../pos/pos_screen.dart';
import '../inventory/inventory_screen.dart';
import '../report_tabs/reports_screen.dart';
import '../customers/customers_screen.dart';
import '../../services/offline_manager.dart';

class AdminScreen extends StatefulWidget {
  const AdminScreen({super.key});

  @override
  State<AdminScreen> createState() => _AdminScreenState();
}

class _AdminScreenState extends State<AdminScreen>
    with TickerProviderStateMixin {
  int _selectedIndex = 0;
  late List<AnimationController> _animationControllers;
  late List<Animation<double>> _scaleAnimations;

  final List<Widget> _screens = [
    const ActivityScreen(),
    const POSScreen(),
    const InventoryScreen(),
    const CustomersScreen(),
    const ReportsScreen(),
  ];

  final List<IconData> _icons = [
    Icons.admin_panel_settings,
    Icons.point_of_sale,
    Icons.inventory,
    Icons.people,
    Icons.assessment,
  ];

  final List<String> _labels = [
    'Activity & Monitoring',
    'POS',
    'Items',
    'Clients',
    'Reports',
  ];

  @override
  void initState() {
    super.initState();
    _animationControllers = List.generate(
      _screens.length,
      (index) => AnimationController(
        duration: const Duration(milliseconds: 200),
        vsync: this,
      ),
    );

    _scaleAnimations = _animationControllers.map((controller) {
      return Tween<double>(
        begin: 1.0,
        end: 0.95,
      ).animate(CurvedAnimation(parent: controller, curve: Curves.easeInOut));
    }).toList();
  }

  @override
  void dispose() {
    for (var controller in _animationControllers) {
      controller.dispose();
    }
    super.dispose();
  }

  void _onNavTap(int index) async {
    if (index == _selectedIndex) return;

    // Animate the pressed button
    await _animationControllers[index].forward();
    await _animationControllers[index].reverse();

    setState(() => _selectedIndex = index);
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = context.watch<AuthProvider>();

    return Scaffold(
      backgroundColor: Colors.grey[50],
      appBar: AppBar(
        title: Text('Admin - ${authProvider.username}'),
        backgroundColor: Colors.indigo[600],
        foregroundColor: Colors.white,
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.delete_forever),
            onPressed: () async {
              await context.read<OfflineManager>().clearCache();
              if (!context.mounted) return;
              ScaffoldMessenger.of(
                context,
              ).showSnackBar(const SnackBar(content: Text('Cache cleared')));
            },
          ),
          IconButton(
            icon: const Icon(Icons.settings),
            onPressed: () {
              Navigator.of(context).push(
                MaterialPageRoute(builder: (context) => const SettingsScreen()),
              );
            },
          ),
        ],
      ),
      body: AnimatedSwitcher(
        duration: const Duration(milliseconds: 250),
        transitionBuilder: (Widget child, Animation<double> animation) {
          return SlideTransition(
            position:
                Tween<Offset>(
                  begin: const Offset(0.3, 0.0),
                  end: Offset.zero,
                ).animate(
                  CurvedAnimation(
                    parent: animation,
                    curve: Curves.easeInOutCubic,
                  ),
                ),
            child: FadeTransition(opacity: animation, child: child),
          );
        },
        child: Container(
          key: ValueKey(_selectedIndex),
          child: _screens[_selectedIndex],
        ),
      ),
      bottomNavigationBar: Container(
        decoration: BoxDecoration(
          color: Theme.of(context).colorScheme.surface,
          boxShadow: [
            BoxShadow(
              color: Theme.of(context).colorScheme.shadow.withAlpha(26),
              blurRadius: 10,
              offset: const Offset(0, -2),
            ),
          ],
        ),
        child: SafeArea(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: List.generate(_screens.length, (index) {
                final isSelected = index == _selectedIndex;
                return Expanded(
                  child: AnimatedBuilder(
                    animation: _scaleAnimations[index],
                    builder: (context, child) {
                      return Transform.scale(
                        scale: _scaleAnimations[index].value,
                        child: Material(
                          color: Colors.transparent,
                          child: InkWell(
                            borderRadius: BorderRadius.circular(12),
                            splashColor: Theme.of(
                              context,
                            ).colorScheme.primary.withAlpha(77),
                            highlightColor: Theme.of(
                              context,
                            ).colorScheme.primary.withAlpha(26),
                            onTap: () => _onNavTap(index),
                            child: AnimatedContainer(
                              duration: const Duration(milliseconds: 100),
                              curve: Curves.easeInOutCubic,
                              padding: const EdgeInsets.symmetric(
                                vertical: 8.0,
                                horizontal: 12.0,
                              ),
                              decoration: BoxDecoration(
                                borderRadius: BorderRadius.circular(12),
                                color: isSelected
                                    ? Theme.of(context).colorScheme.primary
                                          .withValues(alpha: .1)
                                    : Colors.transparent,
                              ),
                              child: Column(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  AnimatedContainer(
                                    duration: const Duration(milliseconds: 100),
                                    curve: Curves.easeInOutCubic,
                                    padding: const EdgeInsets.all(4),
                                    decoration: BoxDecoration(
                                      borderRadius: BorderRadius.circular(8),
                                      color: isSelected
                                          ? Theme.of(
                                              context,
                                            ).colorScheme.primary
                                          : Colors.transparent,
                                    ),
                                    child: AnimatedScale(
                                      scale: isSelected ? 1.1 : 1.0,
                                      duration: const Duration(
                                        milliseconds: 100,
                                      ),
                                      curve: Curves.easeInOutBack,
                                      child: Icon(
                                        _icons[index],
                                        color: isSelected
                                            ? Theme.of(
                                                context,
                                              ).colorScheme.onPrimary
                                            : Theme.of(
                                                context,
                                              ).colorScheme.onSurfaceVariant,
                                        size: 24,
                                      ),
                                    ),
                                  ),
                                  const SizedBox(height: 4),
                                  AnimatedDefaultTextStyle(
                                    duration: const Duration(milliseconds: 100),
                                    curve: Curves.easeInOutCubic,
                                    style: TextStyle(
                                      fontSize: isSelected ? 11 : 10,
                                      fontWeight: isSelected
                                          ? FontWeight.w600
                                          : FontWeight.w500,
                                      color: isSelected
                                          ? Theme.of(
                                              context,
                                            ).colorScheme.primary
                                          : Theme.of(
                                              context,
                                            ).colorScheme.onSurfaceVariant,
                                    ),
                                    child: Text(
                                      _labels[index],
                                      textAlign: TextAlign.center,
                                      overflow: TextOverflow.ellipsis,
                                      maxLines: 1,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ),
                        ),
                      );
                    },
                  ),
                );
              }),
            ),
          ),
        ),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\admin\system_monitoring_screen.dart
â•‘ SIZE: 3.6 KB
â•‘ MODIFIED: 09/15/2025 23:04:40
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/services/offline_manager.dart';
import 'package:provider/provider.dart';
import 'package:prostock/providers/sync_failure_provider.dart';

class SystemMonitoringScreen extends StatelessWidget {
  const SystemMonitoringScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 3,
      child: Scaffold(
        appBar: AppBar(
          title: const Text('System Monitoring'),
          bottom: const TabBar(
            tabs: [
              Tab(text: 'Status'),
              Tab(text: 'Pending'),
              Tab(text: 'Failures'),
            ],
          ),
        ),
        body: const TabBarView(
          children: [
            SyncStatusWidget(),
            PendingOperationsWidget(),
            SyncFailuresWidget(),
          ],
        ),
      ),
    );
  }
}

class SyncStatusWidget extends StatelessWidget {
  const SyncStatusWidget({super.key});

  @override
  Widget build(BuildContext context) {
    final offlineManager = Provider.of<OfflineManager>(context);

    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('Sync Status', style: Theme.of(context).textTheme.headlineSmall),
          const SizedBox(height: 16),
          ListTile(
            title: const Text('Connectivity'),
            trailing: Text(offlineManager.isOnline ? 'Online' : 'Offline'),
          ),
          ListTile(
            title: const Text('Syncing'),
            trailing: Text(offlineManager.isSyncing ? 'In Progress' : 'Idle'),
          ),
          ListTile(
            title: const Text('Last Sync Time'),
            trailing: Text(
              offlineManager.lastSyncTime?.toLocal().toString() ?? 'Never',
            ),
          ),
          ListTile(
            title: const Text('Pending Operations'),
            trailing: Text(offlineManager.pendingOperationsCount.toString()),
          ),
        ],
      ),
    );
  }
}

class PendingOperationsWidget extends StatelessWidget {
  const PendingOperationsWidget({super.key});

  @override
  Widget build(BuildContext context) {
    final offlineManager = Provider.of<OfflineManager>(context);
    final pendingOperations = offlineManager.pendingOperations;

    if (pendingOperations.isEmpty) {
      return const Center(child: Text('No pending operations.'));
    }

    return ListView.builder(
      itemCount: pendingOperations.length,
      itemBuilder: (context, index) {
        final operation = pendingOperations[index];
        return ListTile(
          title: Text(operation.type.toString().split('.').last),
          subtitle: Text('ID: ${operation.id}'),
          trailing: Text('Retries: ${operation.retryCount}'),
        );
      },
    );
  }
}

class SyncFailuresWidget extends StatelessWidget {
  const SyncFailuresWidget({super.key});

  @override
  Widget build(BuildContext context) {
    final syncFailureProvider = Provider.of<SyncFailureProvider>(context);
    final failures = syncFailureProvider.failures;

    if (failures.isEmpty) {
      return const Center(child: Text('No sync failures.'));
    }

    return ListView.builder(
      itemCount: failures.length,
      itemBuilder: (context, index) {
        final failure = failures[index];
        return ListTile(
          title: Text(failure.operation.type.toString().split('.').last),
          subtitle: Text(failure.error),
          trailing: Text(
            failure.operation.timestamp.toLocal().toString().split(' ')[0],
          ),
        );
      },
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\admin\components\stat_card.dart
â•‘ SIZE: 1.25 KB
â•‘ MODIFIED: 10/04/2025 06:10:33
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';

class StatCard extends StatelessWidget {
  final String title;
  final String value;
  final IconData icon;
  final Color color;

  const StatCard({
    super.key,
    required this.title,
    required this.value,
    required this.icon,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface.withAlpha(51),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        children: [
          Icon(icon, color: Theme.of(context).colorScheme.onSurface, size: 24),
          const SizedBox(height: 8),
          Text(
            value,
            style: TextStyle(
              color: Theme.of(context).colorScheme.onSurface,
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
          Text(
            title,
            style: TextStyle(
              color: Theme.of(
                context,
              ).colorScheme.onSurface.withValues(alpha: 0.7),
              fontSize: 12,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\customers\customers_screen.dart
â•‘ SIZE: 6.19 KB
â•‘ MODIFIED: 10/04/2025 04:57:01
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/screens/customers/dialogs/overdue_customers_list_dialog.dart';
import 'package:flutter/material.dart';
import 'package:prostock/screens/customers/dialogs/customer_options_dialog.dart';
import 'package:provider/provider.dart';
import 'package:prostock/models/customer.dart';
import 'package:prostock/providers/credit_provider.dart';
import 'package:prostock/providers/customer_provider.dart';
import 'package:prostock/screens/customers/components/customer_list.dart';
import 'package:prostock/screens/customers/components/customer_qr_scanner.dart';
import 'package:prostock/widgets/add_customer_dialog.dart';
import 'package:prostock/widgets/sync_status_indicator.dart';
import 'dart:async';

class CustomersScreen extends StatefulWidget {
  const CustomersScreen({super.key});

  @override
  State<CustomersScreen> createState() => _CustomersScreenState();
}

class _CustomersScreenState extends State<CustomersScreen> {
  final TextEditingController _searchController = TextEditingController();
  Timer? _debounce;
  String _searchQuery = '';
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      Provider.of<CustomerProvider>(context, listen: false).loadCustomers();
      Provider.of<CreditProvider>(
        context,
        listen: false,
      ).fetchOverdueCustomers(context);
    });

    _scrollController.addListener(() {
      if (_scrollController.position.pixels ==
          _scrollController.position.maxScrollExtent) {
        Provider.of<CustomerProvider>(
          context,
          listen: false,
        ).loadMoreCustomers();
      }
    });

    _searchController.addListener(_onSearchChanged);
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _searchController.removeListener(_onSearchChanged);
    _searchController.dispose();
    _debounce?.cancel();
    super.dispose();
  }

  void _onSearchChanged() {
    if (_debounce?.isActive ?? false) _debounce!.cancel();
    _debounce = Timer(const Duration(milliseconds: 300), () {
      if (_searchQuery != _searchController.text.toLowerCase()) {
        setState(() {
          _searchQuery = _searchController.text.toLowerCase();
        });
        Provider.of<CustomerProvider>(
          context,
          listen: false,
        ).loadCustomers(searchQuery: _searchQuery);
      }
    });
  }

  Future<void> _scanCustomerQRCode() async {
    final customerName = await Navigator.push<String>(
      context,
      MaterialPageRoute(builder: (context) => const CustomerQRScanner()),
    );

    if (customerName != null && customerName.isNotEmpty) {
      if (!mounted) return;
      final customerProvider = Provider.of<CustomerProvider>(
        context,
        listen: false,
      );
      final Customer? customer = await customerProvider.getCustomerByName(
        customerName,
      );

      if (customer != null) {
        if (!mounted) return;
        showDialog(
          context: context,
          builder: (context) => CustomerOptionsDialog(customer: customer),
        );
      } else {
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('This customer does not exist.'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Customers'),
        actions: [
          const SyncStatusIndicator(),
          IconButton(
            icon: const Icon(Icons.qr_code_scanner),
            onPressed: _scanCustomerQRCode,
          ),
          IconButton(
            icon: const Icon(Icons.filter_list),
            onPressed: () {
              // Show filter options
            },
          ),
        ],
      ),
      body: Consumer<CreditProvider>(
        builder: (context, creditProvider, child) {
          final overdueCustomers = creditProvider.overdueCustomers;
          return Column(
            children: [
              if (overdueCustomers.isNotEmpty)
                GestureDetector(
                  onTap: () {
                    showDialog(
                      context: context,
                      builder: (context) => OverdueCustomersListDialog(
                        overdueCustomers: overdueCustomers,
                      ),
                    );
                  },
                  child: Container(
                    color: Colors.red,
                    padding: const EdgeInsets.all(8.0),
                    child: Row(
                      children: [
                        const Icon(Icons.warning, color: Colors.white),
                        const SizedBox(width: 8.0),
                        Text(
                          '${overdueCustomers.length} customer(s) with overdue balance',
                          style: const TextStyle(color: Colors.white),
                        ),
                      ],
                    ),
                  ),
                ),
              Padding(
                padding: const EdgeInsets.all(16),
                child: TextField(
                  controller: _searchController,
                  decoration: const InputDecoration(
                    hintText: 'Search customers...',
                    prefixIcon: Icon(Icons.search),
                    border: OutlineInputBorder(),
                  ),
                ),
              ),
              Expanded(
                child: CustomerList(scrollController: _scrollController),
              ),
            ],
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          showDialog(
            context: context,
            builder: (context) => AddCustomerDialog(
              offlineManager: Provider.of<CustomerProvider>(
                context,
                listen: false,
              ).offlineManager,
            ),
          );
        },
        child: const Icon(Icons.add),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\customers\components\customer_list.dart
â•‘ SIZE: 2.38 KB
â•‘ MODIFIED: 08/29/2025 20:53:06
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/providers/customer_provider.dart';
import 'package:prostock/screens/customers/components/customer_list_item.dart';

class CustomerList extends StatelessWidget {
  final ScrollController scrollController;

  const CustomerList({super.key, required this.scrollController});

  @override
  Widget build(BuildContext context) {
    return Consumer<CustomerProvider>(
      builder: (context, provider, child) {
        if (provider.isLoading && provider.customers.isEmpty) {
          return const Center(child: CircularProgressIndicator());
        }

        if (provider.error != null) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(provider.error!),
                backgroundColor: Colors.red,
              ),
            );
            provider.clearError();
          });
        }

        if (provider.customers.isEmpty && !provider.isLoading) {
          return const Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.people_outline,
                  size: 64,
                  color: Colors.grey,
                ),
                SizedBox(height: 16),
                Text(
                  'No customers found',
                  style: TextStyle(fontSize: 18, color: Colors.grey),
                ),
                SizedBox(height: 8),
                Text(
                  'Add your first customer to get started',
                  style: TextStyle(color: Colors.grey),
                ),
              ],
            ),
          );
        }

        return RefreshIndicator(
          onRefresh: () => provider.loadCustomers(refresh: true),
          child: ListView.builder(
            controller: scrollController,
            itemCount: provider.customers.length + (provider.hasMoreData ? 1 : 0),
            itemBuilder: (context, index) {
              if (index == provider.customers.length) {
                return const Center(child: CircularProgressIndicator());
              }
              final customer = provider.customers[index];
              return CustomerListItem(customer: customer);
            },
          ),
        );
      },
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\customers\components\customer_list_item.dart
â•‘ SIZE: 5.94 KB
â•‘ MODIFIED: 10/21/2025 07:26:57
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/models/customer.dart';
import 'package:prostock/providers/customer_provider.dart';
import 'package:prostock/providers/credit_provider.dart';
import 'package:prostock/screens/customers/dialogs/balance_management_dialog.dart';
import 'package:prostock/screens/customers/dialogs/customer_details_dialog.dart';
import 'package:prostock/screens/customers/dialogs/transaction_history_dialog.dart';
import 'package:prostock/utils/currency_utils.dart';
import 'package:prostock/widgets/add_customer_dialog.dart';
import 'package:provider/provider.dart';
import 'package:prostock/screens/pos/pos_screen.dart';

class CustomerListItem extends StatelessWidget {
  final Customer customer;

  const CustomerListItem({super.key, required this.customer});

  @override
  Widget build(BuildContext context) {
    final creditProvider = Provider.of<CreditProvider>(context, listen: true);
    final isOverdue = creditProvider.overdueCustomers.any(
      (c) => c.id == customer.id,
    );

    // Determine customer status for UI display
    Color statusColor;
    String statusText = '';
    IconData? statusIcon;

    if (isOverdue) {
      statusColor = Colors.red;
      statusText = 'Overdue';
      statusIcon = Icons.warning;
    } else if (customer.balance > 0) {
      statusColor = Colors.orange;
      // Removed statusText for "Has Balance" to prevent overflow
    } else {
      statusColor = Colors.green;
    }

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: statusColor,
          child: Text(
            customer.name.substring(0, 1).toUpperCase(),
            style: const TextStyle(
              color: Colors.white,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
        title: Row(
          children: [
            Expanded(
              child: Text(
                customer.name,
                overflow: TextOverflow.ellipsis,
                style: const TextStyle(fontWeight: FontWeight.w500),
              ),
            ),
            if (statusIcon != null)
              Padding(
                padding: const EdgeInsets.only(left: 8.0),
                child: Icon(statusIcon, color: statusColor, size: 16),
              ),
            if (statusText.isNotEmpty)
              Padding(
                padding: const EdgeInsets.only(left: 4.0),
                child: Text(
                  statusText,
                  style: TextStyle(
                    color: statusColor,
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                  ),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
          ],
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (customer.phone != null)
              Text('Phone: ${customer.phone}', overflow: TextOverflow.ellipsis),
            if (customer.email != null)
              Text('Email: ${customer.email}', overflow: TextOverflow.ellipsis),
            Text(
              'Balance: ${CurrencyUtils.formatCurrency(customer.balance)}',
              style: TextStyle(
                color: isOverdue
                    ? Colors.red
                    : (customer.balance > 0 ? Colors.orange : Colors.green),
                fontWeight: FontWeight.bold,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ],
        ),
        trailing: PopupMenuButton(
          itemBuilder: (context) => [
            const PopupMenuItem(value: 'view', child: Text('View Details')),
            const PopupMenuItem(value: 'edit', child: Text('Edit')),
            const PopupMenuItem(value: 'utang', child: Text('Manage Balance')),
            const PopupMenuItem(
              value: 'history',
              child: Text('Transaction History'),
            ),
            // Replaced Delete with Utang (POS Credit)
            const PopupMenuItem(value: 'utang_pos', child: Text('Utang')),
          ],
          onSelected: (value) async {
            // Check context.mounted before any async operations that use context
            if (!context.mounted) return;

            switch (value) {
              case 'view':
                showDialog(
                  context: context,
                  builder: (context) =>
                      CustomerDetailsDialog(customer: customer),
                );
                break;
              case 'edit':
                showDialog(
                  context: context,
                  builder: (context) => AddCustomerDialog(
                    customer: customer,
                    offlineManager: Provider.of<CustomerProvider>(
                      context,
                      listen: false,
                    ).offlineManager,
                  ),
                );
                break;
              case 'utang':
                showDialog(
                  context: context,
                  builder: (context) =>
                      BalanceManagementDialog(customer: customer),
                );
                break;
              case 'history':
                showDialog(
                  context: context,
                  builder: (context) =>
                      TransactionHistoryDialog(customer: customer),
                );
                break;
              case 'utang_pos':
                if (!context.mounted) return;
                Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (context) =>
                        POSScreen(customer: customer, paymentMethod: 'credit'),
                  ),
                );
                break;
            }
          },
        ),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\customers\components\customer_qr_scanner.dart
â•‘ SIZE: 2.42 KB
â•‘ MODIFIED: 09/03/2025 10:57:35
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:developer';
import 'package:flutter/material.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:prostock/utils/error_logger.dart';

class CustomerQRScanner extends StatefulWidget {
  const CustomerQRScanner({super.key});

  @override
  State<CustomerQRScanner> createState() => _CustomerQRScannerState();
}

class _CustomerQRScannerState extends State<CustomerQRScanner> {
  final MobileScannerController _cameraController = MobileScannerController();
  bool _isProcessing = false;

  @override
  void dispose() {
    _cameraController.dispose();
    super.dispose();
  }

  void _onBarcodeDetected(BarcodeCapture capture) {
    if (_isProcessing) return;

    final List<Barcode> barcodes = capture.barcodes;
    if (barcodes.isEmpty) return;

    final barcode = barcodes.first;
    if (barcode.rawValue == null) return;

    if (mounted) {
      setState(() {
        _isProcessing = true;
      });
      log('Scanned QR code with value: \${barcode.rawValue}');
      Navigator.of(context).pop(barcode.rawValue);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Scan Customer QR Code'),
        actions: [
          IconButton(
            icon: const Icon(Icons.flash_on),
            onPressed: () => _cameraController.toggleTorch(),
          ),
          IconButton(
            icon: const Icon(Icons.flip_camera_ios),
            onPressed: () => _cameraController.switchCamera(),
          ),
        ],
      ),
      body: FutureBuilder<PermissionStatus>(
        future: Permission.camera.request(),
        builder: (context, snapshot) {
          if (snapshot.hasData) {
            if (snapshot.data!.isGranted) {
              return MobileScanner(
                controller: _cameraController,
                onDetect: _onBarcodeDetected,
                errorBuilder: (context, error) {
                  ErrorLogger.logError('Error with QR scanner', error: error);
                  return Center(child: Text('An error occurred: $error'));
                },
              );
            } else {
              return const Center(
                child: Text('Camera permission is required to scan QR codes.'),
              );
            }
          } else {
            return const Center(child: CircularProgressIndicator());
          }
        },
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\customers\dialogs\balance_management_dialog.dart
â•‘ SIZE: 5.66 KB
â•‘ MODIFIED: 10/02/2025 12:23:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/models/customer.dart';
import 'package:prostock/providers/credit_provider.dart';
import 'package:prostock/utils/currency_utils.dart';
import 'package:prostock/widgets/confirmation_dialog.dart';

class BalanceManagementDialog extends StatefulWidget {
  final Customer customer;

  const BalanceManagementDialog({super.key, required this.customer});

  @override
  State<BalanceManagementDialog> createState() =>
      _BalanceManagementDialogState();
}

class _BalanceManagementDialogState extends State<BalanceManagementDialog> {
  final _paymentController = TextEditingController();

  @override
  void dispose() {
    _paymentController.dispose();
    super.dispose();
  }

  void _showErrorSnackBar(String message) {
    if (context.mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(message), backgroundColor: Colors.red),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final creditProvider = Provider.of<CreditProvider>(context, listen: false);
    final bool canPay = widget.customer.balance > 0;

    return AlertDialog(
      title: Text('Manage Balance - ${widget.customer.name}'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.grey.shade100,
              borderRadius: BorderRadius.circular(8),
            ),
            child: Column(
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    const Text('Current Balance:'),
                    Text(
                      CurrencyUtils.formatCurrency(widget.customer.balance),
                      style: TextStyle(
                        color: widget.customer.balance > 0
                            ? Colors.red
                            : Colors.green,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
          const SizedBox(height: 16),
          TextField(
            controller: _paymentController,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            decoration: const InputDecoration(
              labelText: 'Payment Amount',
              prefixText: '₱ ',
              border: OutlineInputBorder(),
              helperText: 'Enter amount customer is paying',
            ),
            enabled: canPay,
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('Cancel'),
        ),
        ElevatedButton(
          onPressed: canPay
              ? () async {
                  final amount = double.tryParse(_paymentController.text);
                  if (amount == null || amount <= 0) {
                    _showErrorSnackBar(
                      'Payment amount must be a valid number greater than zero.',
                    );
                    return;
                  }

                  if (amount > widget.customer.balance) {
                    _showErrorSnackBar(
                      'Payment amount cannot exceed the current balance.',
                    );
                    return;
                  }

                  final confirmed = await showConfirmationDialog(
                    context: context,
                    title: 'Confirm Record Payment',
                    content:
                        'Are you sure you want to record a payment of ₱${amount.toStringAsFixed(2)} for ${widget.customer.name}?\n\nCurrent Balance: ${CurrencyUtils.formatCurrency(widget.customer.balance)}\nNew Balance: ${CurrencyUtils.formatCurrency(widget.customer.balance - amount)}',
                    confirmText: 'Confirm',
                    cancelText: 'Cancel',
                  );
                  if (confirmed != true) {
                    return;
                  }

                  if (!context.mounted) return;

                  final success = await creditProvider.recordPayment(
                    context: context,
                    customerId: widget.customer.id,
                    amount: amount,
                    notes: 'Payment received from ${widget.customer.name}',
                  );

                  if (success) {
                    if (context.mounted) {
                      // Close dialog immediately after successful payment
                      Navigator.pop(context);
                      // Show success message after dialog is closed
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text(
                            'Payment of ₱${amount.toStringAsFixed(2)} recorded successfully',
                          ),
                          backgroundColor: Colors.green,
                        ),
                      );
                    }
                  } else {
                    // Show the specific error message from CreditProvider
                    final errorMessage =
                        creditProvider.error ?? 'Failed to record payment.';
                    _showErrorSnackBar(errorMessage);
                  }
                }
              : null,
          child: const Text('Record Payment'),
        ),
      ],
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\customers\dialogs\customer_details_dialog.dart
â•‘ SIZE: 4.48 KB
â•‘ MODIFIED: 10/04/2025 06:54:14
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:prostock/models/customer.dart';
import 'package:prostock/providers/customer_provider.dart';
import 'package:prostock/utils/currency_utils.dart';
import 'package:prostock/widgets/add_customer_dialog.dart';
import 'package:provider/provider.dart';

class CustomerDetailsDialog extends StatelessWidget {
  final Customer customer;

  const CustomerDetailsDialog({super.key, required this.customer});

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(customer.name),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (customer.localImagePath != null)
            Container(
              width: double.infinity,
              height: 200,
              decoration: BoxDecoration(
                border: Border.all(color: Colors.grey),
                borderRadius: BorderRadius.circular(8),
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(8),
                child: Image.file(
                  File(customer.localImagePath!),
                  fit: BoxFit.cover,
                  errorBuilder: (context, error, stackTrace) {
                    return const Icon(Icons.error, size: 50);
                  },
                ),
              ),
            )
          else if (customer.imageUrl != null)
            Container(
              width: double.infinity,
              height: 200,
              decoration: BoxDecoration(
                border: Border.all(color: Colors.grey),
                borderRadius: BorderRadius.circular(8),
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(8),
                child: Image.network(
                  customer.imageUrl!,
                  fit: BoxFit.cover,
                  loadingBuilder: (context, child, loadingProgress) {
                    if (loadingProgress == null) return child;
                    return const Center(child: CircularProgressIndicator());
                  },
                  errorBuilder: (context, error, stackTrace) {
                    return const Icon(Icons.error, size: 50);
                  },
                ),
              ),
            )
          else
            Container(
              width: double.infinity,
              height: 200,
              decoration: BoxDecoration(
                border: Border.all(color: Colors.grey),
                borderRadius: BorderRadius.circular(8),
              ),
              child: const Icon(Icons.person, size: 100, color: Colors.grey),
            ),
          const SizedBox(height: 16),
          if (customer.phone != null) _buildDetailRow('Phone', customer.phone!),
          if (customer.email != null) _buildDetailRow('Email', customer.email!),
          if (customer.address != null)
            _buildDetailRow('Address', customer.address!),
          _buildDetailRow(
            'Balance',
            CurrencyUtils.formatCurrency(customer.balance),
          ),
          _buildDetailRow(
            'Credit Limit',
            CurrencyUtils.formatCurrency(customer.creditLimit),
          ),
          _buildDetailRow(
            'Member Since',
            '${customer.createdAt.day}/${customer.createdAt.month}/${customer.createdAt.year}',
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () {
            Navigator.of(context).pop();
            showDialog(
              context: context,
              builder: (context) => AddCustomerDialog(
                customer: customer,
                offlineManager: Provider.of<CustomerProvider>(
                  context,
                  listen: false,
                ).offlineManager,
              ),
            );
          },
          child: const Text('Edit'),
        ),
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('Close'),
        ),
      ],
    );
  }

  Widget _buildDetailRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 100,
            child: Text(
              '$label:',
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ),
          Expanded(child: Text(value)),
        ],
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\customers\dialogs\customer_options_dialog.dart
â•‘ SIZE: 3.33 KB
â•‘ MODIFIED: 10/21/2025 07:26:57
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/models/customer.dart';
import 'package:prostock/providers/customer_provider.dart';
import 'package:prostock/screens/customers/dialogs/customer_details_dialog.dart';
import 'package:prostock/screens/customers/dialogs/transaction_history_dialog.dart';
import 'package:prostock/screens/pos/pos_screen.dart';
import 'package:prostock/widgets/add_customer_dialog.dart';

class CustomerOptionsDialog extends StatelessWidget {
  final Customer customer;

  const CustomerOptionsDialog({super.key, required this.customer});

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(customer.name),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
              showDialog(
                context: context,
                builder: (context) => CustomerDetailsDialog(customer: customer),
              );
            },
            child: const Text('View Details'),
          ),
          const SizedBox(height: 8),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
              Provider.of<CustomerProvider>(
                context,
                listen: false,
              ).showManageBalanceDialog(context, customer.id);
            },
            child: const Text('Manage Balance'),
          ),
          const SizedBox(height: 8),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
              showDialog(
                context: context,
                builder: (context) =>
                    TransactionHistoryDialog(customer: customer),
              );
            },
            child: const Text('Transaction History'),
          ),
          const SizedBox(height: 8),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) =>
                      POSScreen(customer: customer, paymentMethod: 'credit'),
                ),
              );
            },
            child: const Text('Utang'),
          ),
          const SizedBox(height: 8),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
              showDialog(
                context: context,
                builder: (context) => AddCustomerDialog(
                  customer: customer,
                  offlineManager: Provider.of<CustomerProvider>(
                    context,
                    listen: false,
                  ).offlineManager,
                ),
              );
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.blue[600],
              foregroundColor: Colors.white,
            ),
            child: const Text('Edit Customer'),
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Close'),
        ),
      ],
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\customers\dialogs\delete_confirmation_dialog.dart
â•‘ SIZE: 1.8 KB
â•‘ MODIFIED: 09/16/2025 23:11:43
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/models/customer.dart';
import 'package:prostock/providers/customer_provider.dart';

class DeleteConfirmationDialog extends StatelessWidget {
  final Customer customer;

  const DeleteConfirmationDialog({super.key, required this.customer});

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Delete Customer'),
      content: Text(
        'Are you sure you want to delete ${customer.name}? This action cannot be undone.',
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('Cancel'),
        ),
        ElevatedButton(
          onPressed: () async {
            final provider = Provider.of<CustomerProvider>(
              context,
              listen: false,
            );
            final success = await provider.deleteCustomer(customer.id);
            if (context.mounted) {
              Navigator.pop(context);
              if (success) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text(
                      'Customer "${customer.name}" deleted successfully!',
                    ),
                    backgroundColor: Colors.green,
                  ),
                );
              } else {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text(
                      'Failed to delete customer. ${provider.error ?? ''}',
                    ),
                    backgroundColor: Colors.red,
                  ),
                );
              }
            }
          },
          child: const Text('Delete'),
        ),
      ],
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\customers\dialogs\overdue_customers_list_dialog.dart
â•‘ SIZE: 1.36 KB
â•‘ MODIFIED: 09/13/2025 20:25:55
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


import 'package:flutter/material.dart';
import 'package:prostock/models/customer.dart';
import 'package:prostock/screens/customers/dialogs/overdue_customer_dialog.dart';

class OverdueCustomersListDialog extends StatelessWidget {
  final List<Customer> overdueCustomers;

  const OverdueCustomersListDialog({super.key, required this.overdueCustomers});

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Overdue Customers'),
      content: SizedBox(
        width: double.maxFinite,
        child: ListView.builder(
          shrinkWrap: true,
          itemCount: overdueCustomers.length,
          itemBuilder: (context, index) {
            final customer = overdueCustomers[index];
            return ListTile(
              title: Text(customer.name),
              subtitle: Text('Credit Balance: ${customer.balance}'),
              onTap: () {
                Navigator.of(context).pop(); // Close this dialog
                showDialog(
                  context: context,
                  builder: (context) => OverdueCustomerDialog(customer: customer),
                );
              },
            );
          },
        ),
      ),
      actions: [
        TextButton(
          onPressed: () {
            Navigator.of(context).pop();
          },
          child: const Text('Close'),
        ),
      ],
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\customers\dialogs\overdue_customer_dialog.dart
â•‘ SIZE: 0.97 KB
â•‘ MODIFIED: 09/13/2025 20:24:46
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


import 'package:flutter/material.dart';
import 'package:prostock/models/customer.dart';

class OverdueCustomerDialog extends StatelessWidget {
  final Customer customer;

  const OverdueCustomerDialog({super.key, required this.customer});

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text('Overdue Customer'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('Customer: ${customer.name}'),
          Text('Credit Balance: ${customer.balance}'),
          // Add more details here later
        ],
      ),
      actions: [
        TextButton(
          onPressed: () {
            // Action 1: Send reminder
          },
          child: const Text('Send Reminder'),
        ),
        TextButton(
          onPressed: () {
            Navigator.of(context).pop();
          },
          child: const Text('Close'),
        ),
      ],
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\customers\dialogs\transaction_history_dialog.dart
â•‘ SIZE: 8.61 KB
â•‘ MODIFIED: 10/21/2025 07:26:57
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/models/customer.dart';
import 'package:prostock/models/credit_sale_item.dart';
import 'package:prostock/providers/credit_provider.dart';
import 'package:prostock/providers/inventory_provider.dart';
import 'package:prostock/utils/currency_utils.dart';
import 'package:prostock/utils/error_logger.dart';
import 'package:prostock/services/local_database_service.dart';
import 'package:prostock/models/credit_transaction.dart';

class TransactionHistoryDialog extends StatefulWidget {
  final Customer customer;

  const TransactionHistoryDialog({super.key, required this.customer});

  @override
  State<TransactionHistoryDialog> createState() =>
      _TransactionHistoryDialogState();
}

class _TransactionHistoryDialogState extends State<TransactionHistoryDialog> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadTransactions();
    });
  }

  Future<void> _loadTransactions() async {
    try {
      ErrorLogger.logInfo(
        'Loading transactions',
        context: 'TransactionHistoryDialog._loadTransactions',
        metadata: {'customerId': widget.customer.id},
      );
      await Provider.of<CreditProvider>(
        context,
        listen: false,
      ).getTransactionsByCustomer(widget.customer.id);
      ErrorLogger.logInfo(
        'Transactions loaded successfully',
        context: 'TransactionHistoryDialog._loadTransactions',
        metadata: {'customerId': widget.customer.id},
      );
    } catch (e) {
      ErrorLogger.logError(
        'Error loading transactions',
        error: e,
        context: 'TransactionHistoryDialog._loadTransactions',
        metadata: {'customerId': widget.customer.id},
      );
      // Fallback to local cache when offline
      try {
        final rows = await LocalDatabaseService.instance
            .getCreditTransactionsByCustomer(widget.customer.id);
        final cached = rows
            .map((m) => CreditTransaction.fromMap(m, (m['id'] ?? '') as String))
            .toList();
        if (mounted) {
          Provider.of<CreditProvider>(context, listen: false)
            ..transactions.clear()
            ..transactions.addAll(cached);
        }
      } catch (_) {}
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Offline: showing cached history if available.'),
          ),
        );
      }
    }
  }

  List<Map<String, dynamic>> _groupItemsByProduct(List<CreditSaleItem> items) {
    final Map<String, Map<String, dynamic>> grouped = {};

    for (final item in items) {
      if (grouped.containsKey(item.productId)) {
        // Add to existing group
        grouped[item.productId]!['totalQuantity'] += item.quantity;
      } else {
        // Create new group
        grouped[item.productId] = {
          'productId': item.productId,
          'unitPrice': item.unitPrice,
          'totalQuantity': item.quantity,
        };
      }
    }

    return grouped.values.toList();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text('${widget.customer.name} - Transaction History'),
      content: SizedBox(
        width: double.maxFinite,
        height:
            MediaQuery.of(context).size.height *
            0.6, // Use 60% of screen height
        child: Consumer<CreditProvider>(
          builder: (context, provider, child) {
            final transactions = provider.transactions;

            if (provider.isLoading) {
              return const Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    CircularProgressIndicator(),
                    SizedBox(height: 16),
                    Text('Loading transactions...'),
                  ],
                ),
              );
            }

            if (provider.error != null) {
              return SingleChildScrollView(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(Icons.error, color: Colors.red, size: 48),
                    const SizedBox(height: 16),
                    Text(
                      'Error: ${provider.error}',
                      textAlign: TextAlign.center,
                      style: const TextStyle(color: Colors.red),
                    ),
                    const SizedBox(height: 16),
                    ElevatedButton(
                      onPressed: () => _loadTransactions(),
                      child: const Text('Retry'),
                    ),
                  ],
                ),
              );
            }

            if (transactions.isEmpty) {
              return const Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(Icons.receipt_long, color: Colors.grey, size: 48),
                    SizedBox(height: 16),
                    Text('No transactions found'),
                    SizedBox(height: 8),
                    Text(
                      'This customer has no credit transactions yet.',
                      style: TextStyle(color: Colors.grey),
                    ),
                  ],
                ),
              );
            }

            return ListView.builder(
              itemCount: transactions.length,
              itemBuilder: (context, index) {
                final transaction = transactions[index];
                final isPayment = transaction.type == 'payment';

                return ListTile(
                  leading: CircleAvatar(
                    backgroundColor: isPayment ? Colors.green : Colors.orange,
                    child: Icon(
                      isPayment ? Icons.payment : Icons.credit_card,
                      color: Colors.white,
                    ),
                  ),
                  title: Text(
                    isPayment ? 'Payment' : 'Credit Sale',
                    style: const TextStyle(fontWeight: FontWeight.bold),
                  ),
                  subtitle: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Show product details for credit sales
                      if (transaction.type == 'purchase' &&
                          transaction.items.isNotEmpty)
                        ..._groupItemsByProduct(transaction.items).map((
                          groupedItem,
                        ) {
                          final inventoryProvider =
                              Provider.of<InventoryProvider>(
                                context,
                                listen: false,
                              );
                          final product = inventoryProvider.getProductById(
                            groupedItem['productId'] as String,
                          );
                          final productName =
                              product?.name ?? 'Unknown Product';
                          return Text(
                            '• ${groupedItem['totalQuantity']}x $productName (₱${groupedItem['unitPrice'].toStringAsFixed(2)} each)',
                            style: const TextStyle(fontSize: 12),
                          );
                        })
                      else
                        Text(transaction.notes ?? 'No description'),
                      Text(
                        '${transaction.date.day}/${transaction.date.month}/${transaction.date.year}',
                        style: const TextStyle(
                          fontSize: 12,
                          color: Colors.grey,
                        ),
                      ),
                    ],
                  ),
                  trailing: Text(
                    '${isPayment ? '-' : '+'}${CurrencyUtils.formatCurrency(transaction.amount)}',
                    style: TextStyle(
                      fontWeight: FontWeight.bold,
                      color: isPayment ? Colors.green : Colors.orange,
                    ),
                  ),
                );
              },
            );
          },
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('Close'),
        ),
      ],
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\inventory\demand_suggestions_screen.dart
â•‘ SIZE: 3.36 KB
â•‘ MODIFIED: 09/30/2025 15:48:11
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/providers/demand_provider.dart';

class DemandSuggestionsScreen extends StatefulWidget {
  const DemandSuggestionsScreen({super.key});

  @override
  State<DemandSuggestionsScreen> createState() =>
      _DemandSuggestionsScreenState();
}

class _DemandSuggestionsScreenState extends State<DemandSuggestionsScreen> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<DemandProvider>().refresh();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('High Demand Suggestions'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () {
              context.read<DemandProvider>().refresh();
            },
          ),
        ],
      ),
      body: Consumer<DemandProvider>(
        builder: (context, dp, _) {
          if (dp.isLoading) {
            return const Center(child: CircularProgressIndicator());
          }
          if (dp.suggestions.isEmpty) {
            return const Center(child: Text('No suggestions at the moment'));
          }
          return ListView.separated(
            itemCount: dp.suggestions.length,
            separatorBuilder: (context, _) => const Divider(height: 1),
            itemBuilder: (context, index) {
              final s = dp.suggestions[index];
              return ListTile(
                title: Text(s.product.name),
                subtitle: Text(
                  'Velocity: ${s.velocityPerDay.toStringAsFixed(1)}/day\nMin-stock: ${s.currentThreshold} → ${s.suggestedThreshold}',
                ),
                isThreeLine: true,
                trailing: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    IconButton(
                      icon: const Icon(Icons.snooze),
                      tooltip: 'Snooze 7 days',
                      onPressed: () async {
                        if (s.product.id != null) {
                          await context.read<DemandProvider>().snooze(
                            s.product.id!,
                          );
                        }
                      },
                    ),
                    ElevatedButton(
                      onPressed: () async {
                        if (s.product.id != null) {
                          await context.read<DemandProvider>().accept(
                            s.product.id!,
                            s.suggestedThreshold,
                          );
                          if (!context.mounted) return;
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                              content: Text(
                                'Updated ${s.product.name} threshold to ${s.suggestedThreshold}',
                              ),
                            ),
                          );
                        }
                      },
                      child: const Text('Update'),
                    ),
                  ],
                ),
              );
            },
          );
        },
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\inventory\inventory_screen.dart
â•‘ SIZE: 2.31 KB
â•‘ MODIFIED: 09/19/2025 15:21:00
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';

import '../../widgets/add_product_dialog.dart';
import '../../widgets/barcode_scanner_widget.dart';
import 'dart:async';

import 'components/inventory_action_buttons.dart';
import 'components/inventory_search_bar.dart';
import 'components/product_list_view.dart';
import '../../widgets/sync_status_indicator.dart';

class InventoryScreen extends StatefulWidget {
  const InventoryScreen({super.key});

  @override
  State<InventoryScreen> createState() => _InventoryScreenState();
}

class _InventoryScreenState extends State<InventoryScreen> {
  final TextEditingController _searchController = TextEditingController();
  Timer? _debounce;
  String _searchQuery = '';

  @override
  void initState() {
    super.initState();
    _searchController.addListener(_onSearchChanged);
  }

  @override
  void dispose() {
    _searchController.removeListener(_onSearchChanged);
    _searchController.dispose();
    _debounce?.cancel();
    super.dispose();
  }

  void _onSearchChanged() {
    if (_debounce?.isActive ?? false) _debounce!.cancel();
    _debounce = Timer(const Duration(milliseconds: 300), () {
      setState(() {
        _searchQuery = _searchController.text.toLowerCase();
      });
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Inventory'),
        actions: [
          const SyncStatusIndicator(),
          IconButton(
            icon: const Icon(Icons.qr_code_scanner),
            tooltip: 'Scan Barcode',
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const BarcodeScannerWidget(),
                ),
              );
            },
          ),
        ],
      ),
      body: Column(
        children: [
          InventorySearchBar(controller: _searchController),
          const InventoryActionButtons(),
          const SizedBox(height: 16),
          Expanded(child: ProductListView(searchQuery: _searchQuery)),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          showDialog(
            context: context,
            builder: (context) => const AddProductDialog(),
          );
        },
        child: const Icon(Icons.add),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\inventory\components\inventory_action_buttons.dart
â•‘ SIZE: 7.07 KB
â•‘ MODIFIED: 09/25/2025 10:25:19
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/widgets/barcode_scanner_widget.dart';
import 'package:prostock/widgets/manual_stock_adjustment_dialog.dart';
import 'package:prostock/screens/inventory/demand_suggestions_screen.dart';

class InventoryActionButtons extends StatelessWidget {
  const InventoryActionButtons({super.key});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: Column(
        children: [
          // First row: Stock management buttons
          Row(
            children: [
              Expanded(
                child: PopupMenuButton<String>(
                  itemBuilder: (context) => [
                    const PopupMenuItem(
                      value: 'scan',
                      child: ListTile(
                        leading: Icon(Icons.qr_code_scanner),
                        title: Text('Scan Barcode'),
                        contentPadding: EdgeInsets.zero,
                      ),
                    ),
                    const PopupMenuItem(
                      value: 'manual',
                      child: ListTile(
                        leading: Icon(Icons.edit),
                        title: Text('Manual Entry'),
                        contentPadding: EdgeInsets.zero,
                      ),
                    ),
                  ],
                  onSelected: (value) {
                    if (value == 'scan') {
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) => const BarcodeScannerWidget(
                            mode: ScannerMode.receiveStock,
                          ),
                        ),
                      );
                    } else if (value == 'manual') {
                      showDialog(
                        context: context,
                        builder: (context) => const ManualStockAdjustmentDialog(
                          type: StockAdjustmentType.receive,
                        ),
                      );
                    }
                  },
                  child: Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 16,
                      vertical: 12,
                    ),
                    decoration: BoxDecoration(
                      color: Colors.green,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: const Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(Icons.add_box, color: Colors.white),
                        SizedBox(width: 8),
                        Flexible(
                          child: Text(
                            'Receive Stock',
                            style: TextStyle(
                              color: Colors.white,
                              fontWeight: FontWeight.bold,
                            ),
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        SizedBox(width: 4),
                        Icon(Icons.arrow_drop_down, color: Colors.white),
                      ],
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 8),
              Expanded(
                child: PopupMenuButton<String>(
                  itemBuilder: (context) => [
                    const PopupMenuItem(
                      value: 'scan',
                      child: ListTile(
                        leading: Icon(Icons.qr_code_scanner),
                        title: Text('Scan Barcode'),
                        contentPadding: EdgeInsets.zero,
                      ),
                    ),
                    const PopupMenuItem(
                      value: 'manual',
                      child: ListTile(
                        leading: Icon(Icons.edit),
                        title: Text('Manual Entry'),
                        contentPadding: EdgeInsets.zero,
                      ),
                    ),
                  ],
                  onSelected: (value) {
                    if (value == 'scan') {
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) => const BarcodeScannerWidget(
                            mode: ScannerMode.removeStock,
                          ),
                        ),
                      );
                    } else if (value == 'manual') {
                      showDialog(
                        context: context,
                        builder: (context) => const ManualStockAdjustmentDialog(
                          type: StockAdjustmentType.remove,
                        ),
                      );
                    }
                  },
                  child: Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 16,
                      vertical: 12,
                    ),
                    decoration: BoxDecoration(
                      color: Colors.red,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: const Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(Icons.remove_circle, color: Colors.white),
                        SizedBox(width: 8),
                        Flexible(
                          child: Text(
                            'Remove Stock',
                            style: TextStyle(
                              color: Colors.white,
                              fontWeight: FontWeight.bold,
                            ),
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        SizedBox(width: 4),
                        Icon(Icons.arrow_drop_down, color: Colors.white),
                      ],
                    ),
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          // Second row: Demand suggestions button
          Row(
            children: [
              Expanded(
                child: ElevatedButton.icon(
                  onPressed: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => const DemandSuggestionsScreen(),
                      ),
                    );
                  },
                  icon: const Icon(Icons.trending_up),
                  label: const Text('Demand Suggestions'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.orange,
                    foregroundColor: Colors.white,
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\inventory\components\inventory_search_bar.dart
â•‘ SIZE: 0.56 KB
â•‘ MODIFIED: 08/31/2025 09:51:46
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';

class InventorySearchBar extends StatelessWidget {
  final TextEditingController controller;

  const InventorySearchBar({super.key, required this.controller});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: TextField(
        controller: controller,
        decoration: const InputDecoration(
          hintText: 'Search products...',
          prefixIcon: Icon(Icons.search),
          border: OutlineInputBorder(),
        ),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\inventory\components\product_list_view.dart
â•‘ SIZE: 14.22 KB
â•‘ MODIFIED: 10/26/2025 11:03:00
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';

import 'package:prostock/providers/inventory_provider.dart';
import 'package:prostock/utils/currency_utils.dart';
import 'package:prostock/widgets/add_product_dialog.dart';
import 'package:prostock/widgets/price_history_dialog.dart';
import 'package:prostock/services/tax_service.dart';
import 'package:provider/provider.dart';

class ProductListView extends StatelessWidget {
  final String searchQuery;

  const ProductListView({super.key, required this.searchQuery});

  @override
  Widget build(BuildContext context) {
    return Consumer<InventoryProvider>(
      builder: (context, provider, child) {
        if (provider.isLoading) {
          return const Center(child: CircularProgressIndicator());
        }

        final filteredProducts = provider.products.where((product) {
          return product.name.toLowerCase().contains(searchQuery) ||
              (product.barcode?.toLowerCase().contains(searchQuery) ?? false);
        }).toList();

        if (filteredProducts.isEmpty) {
          return const Center(child: Text('No products found'));
        }

        if (provider.error != null) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(provider.error!),
                backgroundColor: Theme.of(context).colorScheme.error,
              ),
            );
            provider.clearError(); // Clear the error after showing it
          });
        }

        return RefreshIndicator(
          onRefresh: () => provider.refreshProducts(),
          child: ListView.builder(
            itemCount: filteredProducts.length,
            itemBuilder: (context, index) {
              final product = filteredProducts[index];
              final visualStock = provider.getVisualStock(product.id!);
              final isQueued = !provider.isOnline;
              final colorScheme = Theme.of(context).colorScheme;
              final textTheme = Theme.of(context).textTheme;

              // Determine stock status colors using theme
              final bool isOutOfStock = visualStock <= 0;
              final bool isLowStock = product.isLowStock && !isOutOfStock;

              Color stockAvatarColor;
              if (isOutOfStock) {
                stockAvatarColor = colorScheme.errorContainer;
              } else if (isLowStock) {
                stockAvatarColor = colorScheme.tertiaryContainer;
              } else {
                stockAvatarColor = colorScheme.primaryContainer;
              }

              Color stockAvatarTextColor;
              if (isOutOfStock) {
                stockAvatarTextColor = colorScheme.onErrorContainer;
              } else if (isLowStock) {
                stockAvatarTextColor = colorScheme.onTertiaryContainer;
              } else {
                stockAvatarTextColor = colorScheme.onPrimaryContainer;
              }

              return Card(
                margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
                elevation: isOutOfStock ? 0 : 1,
                child: InkWell(
                  onTap: () {
                    showDialog(
                      context: context,
                      builder: (context) => AddProductDialog(product: product),
                    );
                  },
                  borderRadius: BorderRadius.circular(12),
                  child: Padding(
                    padding: const EdgeInsets.all(12),
                    child: Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        // Stock Avatar
                        Stack(
                          alignment: Alignment.center,
                          children: [
                            CircleAvatar(
                              radius: 28,
                              backgroundColor: stockAvatarColor,
                              child: Text(
                                visualStock.toString(),
                                style: textTheme.titleMedium?.copyWith(
                                  color: stockAvatarTextColor,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ),
                            if (isOutOfStock)
                              Positioned(
                                bottom: 0,
                                child: Icon(
                                  Icons.block,
                                  color: colorScheme.error,
                                  size: 16,
                                ),
                              ),
                          ],
                        ),
                        const SizedBox(width: 12),

                        // Main Content
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              // Product Name
                              Text(
                                product.name,
                                style: textTheme.titleMedium?.copyWith(
                                  fontWeight: FontWeight.w600,
                                ),
                                maxLines: 2,
                                overflow: TextOverflow.ellipsis,
                              ),
                              const SizedBox(height: 8),

                              // Price
                              FutureBuilder<double>(
                                future:
                                    TaxService.calculateSellingPriceWithRule(
                                      product.cost,
                                      productId: product.id,
                                      categoryName: product.category,
                                    ),
                                builder: (context, snapshot) {
                                  if (snapshot.hasData) {
                                    return Text(
                                      CurrencyUtils.formatCurrency(
                                        snapshot.data!,
                                      ),
                                      style: textTheme.titleSmall?.copyWith(
                                        color: colorScheme.primary,
                                        fontWeight: FontWeight.w600,
                                      ),
                                    );
                                  }
                                  return Text(
                                    'Calculating...',
                                    style: textTheme.bodySmall?.copyWith(
                                      color: colorScheme.outline,
                                    ),
                                  );
                                },
                              ),

                              const SizedBox(height: 8),

                              // Chips and Tags
                              Wrap(
                                spacing: 6,
                                runSpacing: 6,
                                children: [
                                  if (isQueued)
                                    Chip(
                                      label: const Text('Queued'),
                                      labelStyle: textTheme.labelSmall
                                          ?.copyWith(
                                            color: colorScheme
                                                .onSecondaryContainer,
                                          ),
                                      backgroundColor:
                                          colorScheme.secondaryContainer,
                                      padding: EdgeInsets.zero,
                                      visualDensity: VisualDensity.compact,
                                      materialTapTargetSize:
                                          MaterialTapTargetSize.shrinkWrap,
                                    ),
                                  if (isLowStock)
                                    Chip(
                                      avatar: Icon(
                                        Icons.warning_amber_rounded,
                                        size: 16,
                                        color: colorScheme.onTertiaryContainer,
                                      ),
                                      label: const Text('Low Stock'),
                                      labelStyle: textTheme.labelSmall
                                          ?.copyWith(
                                            color:
                                                colorScheme.onTertiaryContainer,
                                            fontWeight: FontWeight.w600,
                                          ),
                                      backgroundColor:
                                          colorScheme.tertiaryContainer,
                                      padding: EdgeInsets.zero,
                                      visualDensity: VisualDensity.compact,
                                      materialTapTargetSize:
                                          MaterialTapTargetSize.shrinkWrap,
                                    ),
                                  if (isOutOfStock)
                                    Chip(
                                      avatar: Icon(
                                        Icons.remove_circle_outline,
                                        size: 16,
                                        color: colorScheme.onErrorContainer,
                                      ),
                                      label: const Text('Out of Stock'),
                                      labelStyle: textTheme.labelSmall
                                          ?.copyWith(
                                            color: colorScheme.onErrorContainer,
                                            fontWeight: FontWeight.w600,
                                          ),
                                      backgroundColor:
                                          colorScheme.errorContainer,
                                      padding: EdgeInsets.zero,
                                      visualDensity: VisualDensity.compact,
                                      materialTapTargetSize:
                                          MaterialTapTargetSize.shrinkWrap,
                                    ),
                                  if (product.category != null &&
                                      product.category!.isNotEmpty)
                                    Chip(
                                      label: Text(product.category!),
                                      labelStyle: textTheme.labelSmall
                                          ?.copyWith(
                                            color: colorScheme.onSurfaceVariant,
                                          ),
                                      backgroundColor:
                                          colorScheme.surfaceContainerHighest,
                                      padding: EdgeInsets.zero,
                                      visualDensity: VisualDensity.compact,
                                      materialTapTargetSize:
                                          MaterialTapTargetSize.shrinkWrap,
                                    ),
                                ],
                              ),

                              // Barcode (if exists)
                              if (product.barcode != null &&
                                  product.barcode!.isNotEmpty)
                                Padding(
                                  padding: const EdgeInsets.only(top: 8),
                                  child: Container(
                                    padding: const EdgeInsets.symmetric(
                                      horizontal: 8,
                                      vertical: 4,
                                    ),
                                    decoration: BoxDecoration(
                                      color:
                                          colorScheme.surfaceContainerHighest,
                                      borderRadius: BorderRadius.circular(4),
                                      border: Border.all(
                                        color: colorScheme.outlineVariant,
                                        width: 1,
                                      ),
                                    ),
                                    child: Text(
                                      product.barcode!,
                                      style: textTheme.bodySmall?.copyWith(
                                        fontFamily: 'monospace',
                                        color: colorScheme.onSurfaceVariant,
                                        letterSpacing: 1.2,
                                      ),
                                    ),
                                  ),
                                ),
                            ],
                          ),
                        ),

                        // History Button
                        IconButton(
                          icon: const Icon(Icons.history),
                          tooltip: 'Price History',
                          visualDensity: VisualDensity.compact,
                          onPressed: () {
                            showDialog(
                              context: context,
                              builder: (context) =>
                                  PriceHistoryDialog(productId: product.id!),
                            );
                          },
                        ),
                      ],
                    ),
                  ),
                ),
              );
            },
          ),
        );
      },
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\login_signup\forgot_password_screen.dart
â•‘ SIZE: 4.35 KB
â•‘ MODIFIED: 09/19/2025 14:01:06
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/auth_provider.dart';

class ForgotPasswordScreen extends StatefulWidget {
  const ForgotPasswordScreen({super.key});

  @override
  State<ForgotPasswordScreen> createState() => _ForgotPasswordScreenState();
}

class _ForgotPasswordScreenState extends State<ForgotPasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  bool _isLoading = false;

  @override
  void dispose() {
    _emailController.dispose();
    super.dispose();
  }

  Future<void> _sendResetEmail() async {
    if (_formKey.currentState!.validate()) {
      setState(() {
        _isLoading = true;
      });

      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final error = await authProvider.sendPasswordResetEmail(
        _emailController.text.trim(),
      );

      if (!mounted) return;

      setState(() {
        _isLoading = false;
      });

      if (error == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text(
              'Password reset email sent. Please check your inbox.',
            ),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 4),
          ),
        );
        Navigator.of(context).pop();
      } else {
        String userFriendlyError;
        if (error.contains('user-not-found')) {
          userFriendlyError = 'No account found with this email address.';
        } else if (error.contains('invalid-email')) {
          userFriendlyError = 'Please enter a valid email address.';
        } else if (error.contains('network-request-failed')) {
          userFriendlyError =
              'Network error. Please check your connection and try again.';
        } else {
          userFriendlyError = 'Failed to send reset email. Please try again.';
        }

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(userFriendlyError),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 4),
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Forgot Password')),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16.0),
          child: Form(
            key: _formKey,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Text(
                  'Enter your email to receive a password reset link.',
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 24.0),
                TextFormField(
                  controller: _emailController,
                  decoration: const InputDecoration(
                    labelText: 'Email',
                    border: OutlineInputBorder(),
                    prefixIcon: Icon(Icons.email),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter your email';
                    }
                    if (!RegExp(
                      r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                    ).hasMatch(value.trim())) {
                      return 'Please enter a valid email address';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 24.0),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    onPressed: _isLoading ? null : _sendResetEmail,
                    child: _isLoading
                        ? const SizedBox(
                            width: 24,
                            height: 24,
                            child: CircularProgressIndicator(
                              color: Colors.white,
                            ),
                          )
                        : const Text('Send Reset Link'),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\login_signup\login_screen.dart
â•‘ SIZE: 9.62 KB
â•‘ MODIFIED: 10/02/2025 17:07:31
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/screens/login_signup/forgot_password_screen.dart';
import 'package:provider/provider.dart';
import 'package:prostock/utils/app_constants.dart';
import '../../providers/auth_provider.dart';
import '../../models/user_role.dart';
import '../../widgets/enhanced_text_field.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _isLoading = false;
  bool _isFormValid = false;

  @override
  void initState() {
    super.initState();
    _emailController.addListener(_validateForm);
    _passwordController.addListener(_validateForm);
  }

  @override
  void dispose() {
    _emailController.removeListener(_validateForm);
    _passwordController.removeListener(_validateForm);
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _validateForm() {
    final isEmailValid = RegExp(
      r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
    ).hasMatch(_emailController.text.trim());
    final isPasswordValid = _passwordController.text.isNotEmpty;

    setState(() {
      _isFormValid = isEmailValid && isPasswordValid;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(UiConstants.spacingMedium),
          child: Form(
            key: _formKey,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Text(
                  'Welcome Back!',
                  style: TextStyle(
                    fontSize: UiConstants.fontSizeTitle,
                    fontWeight: FontWeight.bold,
                    color: Colors.blueAccent,
                  ),
                ),
                const SizedBox(height: UiConstants.spacingExtraLarge),
                Consumer<AuthProvider>(
                  builder: (context, authProvider, child) {
                    return EnhancedTextField(
                      controller: _emailController,
                      labelText: 'Email',
                      prefixIcon: Icons.email,
                      keyboardType: TextInputType.emailAddress,
                      errorText: authProvider.fieldErrors['email'],
                      onChanged: (value) {
                        authProvider.clearFieldErrors();
                      },
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please enter your email';
                        }
                        if (!RegExp(
                          r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                        ).hasMatch(value.trim())) {
                          return 'Please enter a valid email address';
                        }
                        return null;
                      },
                    );
                  },
                ),
                const SizedBox(height: UiConstants.spacingLarge),
                Consumer<AuthProvider>(
                  builder: (context, authProvider, child) {
                    return EnhancedTextField(
                      controller: _passwordController,
                      labelText: 'Password',
                      prefixIcon: Icons.lock,
                      isPassword: true,
                      errorText: authProvider.fieldErrors['password'],
                      onChanged: (value) {
                        authProvider.clearFieldErrors();
                      },
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please enter your password';
                        }
                        return null;
                      },
                    );
                  },
                ),
                const SizedBox(height: UiConstants.spacingExtraLarge2),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    onPressed: _isLoading || !_isFormValid
                        ? null
                        : () async {
                            if (_formKey.currentState!.validate()) {
                              setState(() {
                                _isLoading = true;
                              });

                              final navigator = Navigator.of(context);
                              final scaffold = ScaffoldMessenger.of(context);
                              final authProvider = context.read<AuthProvider>();
                              final success = await authProvider.login(
                                _emailController.text.trim(),
                                _passwordController.text,
                              );

                              if (!mounted) return;

                              if (success) {
                                scaffold.showSnackBar(
                                  const SnackBar(
                                    content: Text('Login successful!'),
                                    backgroundColor: Colors.green,
                                    duration: Duration(seconds: 2),
                                  ),
                                );
                                final userRole = authProvider.userRole;
                                if (userRole == UserRole.admin) {
                                  navigator.pushReplacementNamed('/admin');
                                } else {
                                  navigator.pushReplacementNamed('/user');
                                }
                              } else {
                                final errorMessage =
                                    authProvider.error ?? 'Login failed';
                                scaffold.showSnackBar(
                                  SnackBar(
                                    content: Text(errorMessage),
                                    backgroundColor: Colors.red,
                                    duration: const Duration(seconds: 4),
                                    action: SnackBarAction(
                                      label: 'Dismiss',
                                      textColor: Colors.white,
                                      onPressed: () =>
                                          scaffold.hideCurrentSnackBar(),
                                    ),
                                  ),
                                );
                              }

                              setState(() {
                                _isLoading = false;
                              });
                            }
                          },
                    style: ElevatedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(
                        vertical: UiConstants.spacingMedium,
                      ),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(
                          UiConstants.borderRadiusStandard,
                        ),
                      ),
                      backgroundColor: Colors.blueAccent,
                      foregroundColor: Colors.white,
                    ),
                    child: _isLoading
                        ? const SizedBox(
                            width: UiConstants.iconSizeSmall,
                            height: UiConstants.iconSizeSmall,
                            child: CircularProgressIndicator(
                              color: Colors.white,
                              strokeWidth: UiConstants.strokeWidthSmall,
                            ),
                          )
                        : Text(
                            _isFormValid ? 'Login' : 'Enter Email & Password',
                            style: const TextStyle(
                              fontSize: UiConstants.fontSizeButton,
                            ),
                          ),
                  ),
                ),
                const SizedBox(height: UiConstants.spacingLarge),
                TextButton(
                  onPressed: () {
                    Navigator.of(context).pushNamed('/signup');
                  },
                  style: TextButton.styleFrom(
                    foregroundColor: Colors.blueAccent,
                  ),
                  child: const Text(
                    'Create Account',
                    style: TextStyle(fontSize: UiConstants.fontSizeMedium),
                  ),
                ),
                TextButton(
                  onPressed: () {
                    Navigator.of(context).push(
                      MaterialPageRoute(
                        builder: (context) => const ForgotPasswordScreen(),
                      ),
                    );
                  },
                  style: TextButton.styleFrom(foregroundColor: Colors.grey),
                  child: const Text(
                    'Forgot Password?',
                    style: TextStyle(fontSize: UiConstants.fontSizeSmall),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\login_signup\signup_screen.dart
â•‘ SIZE: 11.49 KB
â•‘ MODIFIED: 10/02/2025 17:06:21
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/auth_provider.dart';
import '../../models/user_role.dart';
import '../../utils/password_helper.dart';
import '../../widgets/enhanced_text_field.dart';
import '../../widgets/password_strength_checklist.dart';

class SignupScreen extends StatefulWidget {
  const SignupScreen({super.key});

  @override
  State<SignupScreen> createState() => _SignupScreenState();
}

class _SignupScreenState extends State<SignupScreen> {
  final _formKey = GlobalKey<FormState>();
  final _usernameController = TextEditingController();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  UserRole _selectedRole = UserRole.user;
  bool _isLoading = false;
  bool _showPasswordChecklist = false;
  String _currentPassword = '';
  bool _isFormValid = false;

  @override
  void initState() {
    super.initState();
    _passwordController.addListener(_onPasswordChanged);
  }

  @override
  void dispose() {
    _passwordController.removeListener(_onPasswordChanged);
    _usernameController.dispose();
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _onPasswordChanged() {
    setState(() {
      _currentPassword = _passwordController.text;
      _showPasswordChecklist = _currentPassword.isNotEmpty;
    });
    _validateForm();
  }

  void _validateForm() {
    final isUsernameValid = _usernameController.text.trim().length >= 3;
    final isEmailValid = RegExp(
      r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
    ).hasMatch(_emailController.text.trim());
    final isPasswordValid = PasswordHelper.isPasswordStrong(_currentPassword);

    setState(() {
      _isFormValid = isUsernameValid && isEmailValid && isPasswordValid;
    });
  }

  void _showErrorSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 4),
        action: SnackBarAction(
          label: 'Dismiss',
          textColor: Colors.white,
          onPressed: () {
            ScaffoldMessenger.of(context).hideCurrentSnackBar();
          },
        ),
      ),
    );
  }

  void _showVerificationDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Verify Your Email'),
        content: const Text(
          'A verification email has been sent to your email address. Please verify your email to login.',
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              Navigator.of(context).pushReplacementNamed('/login');
            },
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16.0),
          child: Form(
            key: _formKey,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Text(
                  'Create Account',
                  style: TextStyle(
                    fontSize: 32,
                    fontWeight: FontWeight.bold,
                    color: Colors.blueAccent,
                  ),
                ),
                const SizedBox(height: 40),
                Consumer<AuthProvider>(
                  builder: (context, authProvider, child) {
                    return EnhancedTextField(
                      controller: _usernameController,
                      labelText: 'Username',
                      prefixIcon: Icons.person,
                      errorText: authProvider.fieldErrors['username'],
                      onChanged: (value) {
                        authProvider.clearFieldErrors();
                        _validateForm();
                      },
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please enter a username';
                        }
                        if (value.trim().length < 3) {
                          return 'Username must be at least 3 characters long';
                        }
                        if (!RegExp(
                          r'^[a-zA-Z0-9_]+$',
                        ).hasMatch(value.trim())) {
                          return 'Username can only contain letters, numbers, and underscores';
                        }
                        return null;
                      },
                    );
                  },
                ),
                const SizedBox(height: 20),
                Consumer<AuthProvider>(
                  builder: (context, authProvider, child) {
                    return EnhancedTextField(
                      controller: _emailController,
                      labelText: 'Email',
                      prefixIcon: Icons.email,
                      keyboardType: TextInputType.emailAddress,
                      errorText: authProvider.fieldErrors['email'],
                      onChanged: (value) {
                        authProvider.clearFieldErrors();
                        _validateForm();
                      },
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please enter an email';
                        }
                        if (!RegExp(
                          r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                        ).hasMatch(value.trim())) {
                          return 'Please enter a valid email address';
                        }
                        return null;
                      },
                    );
                  },
                ),
                const SizedBox(height: 20),
                Consumer<AuthProvider>(
                  builder: (context, authProvider, child) {
                    return Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        EnhancedTextField(
                          controller: _passwordController,
                          labelText: 'Password',
                          prefixIcon: Icons.lock,
                          isPassword: true,
                          errorText: authProvider.fieldErrors['password'],
                          showValidationIcon: false,
                          onChanged: (value) {
                            authProvider.clearFieldErrors();
                            _onPasswordChanged();
                          },
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return 'Please enter a password';
                            }
                            if (!PasswordHelper.isPasswordStrong(value)) {
                              return 'Password is not strong enough.';
                            }
                            return null;
                          },
                        ),
                        PasswordStrengthChecklist(
                          password: _currentPassword,
                          isVisible: _showPasswordChecklist,
                        ),
                      ],
                    );
                  },
                ),
                const SizedBox(height: 20),
                DropdownButtonFormField<UserRole>(
                  initialValue: _selectedRole,
                  decoration: const InputDecoration(
                    labelText: 'Role',
                    border: OutlineInputBorder(),
                    prefixIcon: Icon(Icons.person_pin_rounded),
                    filled: true,
                    fillColor: Colors.white70,
                  ),
                  items: UserRole.values.map((role) {
                    return DropdownMenuItem<UserRole>(
                      value: role,
                      child: Text(role.name),
                    );
                  }).toList(),
                  onChanged: (value) {
                    if (value != null) {
                      setState(() {
                        _selectedRole = value;
                      });
                    }
                  },
                ),
                const SizedBox(height: 30),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    onPressed: _isLoading || !_isFormValid
                        ? null
                        : () async {
                            if (_formKey.currentState!.validate()) {
                              setState(() {
                                _isLoading = true;
                              });

                              final authProvider = context.read<AuthProvider>();
                              final success = await authProvider.createUser(
                                _usernameController.text.trim(),
                                _emailController.text.trim(),
                                _passwordController.text,
                                _selectedRole,
                              );

                              if (!mounted) return;

                              if (success) {
                                _showVerificationDialog();
                              } else {
                                final errorMessage =
                                    authProvider.error ?? 'Signup failed';
                                _showErrorSnackBar(errorMessage);
                              }

                              setState(() {
                                _isLoading = false;
                              });
                            }
                          },
                    style: ElevatedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 15),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(10),
                      ),
                      backgroundColor: Colors.blueAccent,
                      foregroundColor: Colors.white,
                    ),
                    child: _isLoading
                        ? const CircularProgressIndicator(color: Colors.white)
                        : Text(
                            _isFormValid
                                ? 'Create Account'
                                : 'Complete Form to Continue',
                            style: const TextStyle(fontSize: 18),
                          ),
                  ),
                ),
                const SizedBox(height: 10),
                TextButton(
                  onPressed: () {
                    Navigator.of(context).pushNamed('/login');
                  },
                  style: TextButton.styleFrom(
                    foregroundColor: Colors.blueAccent,
                  ),
                  child: const Text(
                    'Already have an account? Login',
                    style: TextStyle(fontSize: 16),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\pos\pos_screen.dart
â•‘ SIZE: 6.74 KB
â•‘ MODIFIED: 10/04/2025 04:57:01
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/utils/app_constants.dart';
import '../../providers/sales_provider.dart';
import '../../providers/inventory_provider.dart';
import '../../models/customer.dart';
import '../../widgets/barcode_scanner_widget.dart';
import '../../widgets/receipt_dialog.dart';
import '../../widgets/confirmation_dialog.dart';
import '../../widgets/sync_status_indicator.dart';
import 'dart:async';

import 'components/cart_view.dart';
import 'components/product_grid_view.dart';
import 'components/product_search_view.dart';

class POSScreen extends StatefulWidget {
  final Customer? customer;
  final String? paymentMethod;

  const POSScreen({super.key, this.customer, this.paymentMethod});

  @override
  State<POSScreen> createState() => _POSScreenState();
}

class _POSScreenState extends State<POSScreen> {
  final GlobalKey<CartViewState> _cartViewKey = GlobalKey<CartViewState>();
  Customer? _selectedCustomer;
  String _paymentMethod = 'cash';
  final TextEditingController _productSearchController =
      TextEditingController();
  Timer? _productSearchDebounce;
  bool _isProcessingSale = false;

  @override
  void initState() {
    super.initState();
    _selectedCustomer = widget.customer;
    if (widget.paymentMethod != null) {
      _paymentMethod = widget.paymentMethod!;
    }
    _productSearchController.addListener(_onProductSearchChanged);
  }

  @override
  void dispose() {
    _productSearchController.removeListener(_onProductSearchChanged);
    _productSearchController.dispose();
    _productSearchDebounce?.cancel();
    super.dispose();
  }

  void _onProductSearchChanged() {
    if (_productSearchDebounce?.isActive ?? false) {
      _productSearchDebounce!.cancel();
    }
    _productSearchDebounce = Timer(UiConstants.debounceDuration, () {
      Provider.of<InventoryProvider>(
        context,
        listen: false,
      ).loadProducts(searchQuery: _productSearchController.text.toLowerCase());
    });
  }

  void _onCustomerChanged(Customer? customer) {
    setState(() {
      _selectedCustomer = customer;
      if (_selectedCustomer == null) {
        _paymentMethod = 'cash';
      }
    });
  }

  void _onPaymentMethodChanged(String? value) {
    setState(() {
      _paymentMethod = value!;
    });
  }

  Future<void> _completeSale() async {
    final confirmed = await showConfirmationDialog(
      context: context,
      title: 'Complete Sale',
      content: 'Are you sure you want to complete this sale?',
      confirmText: 'Complete',
    );

    if (confirmed != true) return;

    setState(() {
      _isProcessingSale = true;
    });
    try {
      if (!mounted) return;
      DateTime? dueDate;
      if (_paymentMethod == 'credit') {
        dueDate = await showDatePicker(
          context: context,
          initialDate: DateTime.now().add(const Duration(days: 30)),
          firstDate: DateTime.now(),
          lastDate: DateTime.now().add(const Duration(days: 365)),
        );
      }
      if (!mounted) return;
      final salesProvider = Provider.of<SalesProvider>(context, listen: false);
      final receipt = await salesProvider.completeSale(
        customerId: _selectedCustomer?.id,
        paymentMethod: _paymentMethod,
        dueDate: dueDate,
      );

      final cashTendered = _cartViewKey.currentState?.getCashTendered();
      final change = _cartViewKey.currentState?.getChange();

      if (context.mounted) {
        if (receipt != null) {
          if (!mounted) return;
          showDialog(
            context: context,
            barrierDismissible: false,
            builder: (context) => ReceiptDialog(
              receipt: receipt,
              cashTendered: double.tryParse(cashTendered ?? '0.0') ?? 0.0,
              change: change ?? 0.0,
            ),
          );
        } else {
          if (!mounted) return;
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(salesProvider.error ?? 'Sale failed'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } finally {
      if (mounted) {
        setState(() {
          _isProcessingSale = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      resizeToAvoidBottomInset: true,
      appBar: AppBar(
        title: const Text('Point of Sale'),
        actions: [
          const SyncStatusIndicator(),
          IconButton(
            icon: const Icon(Icons.qr_code_scanner),
            tooltip: 'Scan Product Barcode',
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const BarcodeScannerWidget(),
                ),
              );
            },
          ),
        ],
      ),
      body: Column(
        children: [
          // Product section - gets most of the space (70%)
          Expanded(
            flex: 7, // Increased from 3 to give more space to products
            child: Column(
              children: [
                // Search bar (let it size itself to avoid overflow on loading/keyboard)
                ProductSearchView(
                  controller: _productSearchController,
                  onChanged: (value) => _onProductSearchChanged(),
                ),
                // Product grid takes remaining space in this section
                const Expanded(child: ProductGridView()),
              ],
            ),
          ),
          // Cart section - adaptive height (30% of available space, respects keyboard)
          Builder(
            builder: (context) {
              final media = MediaQuery.of(context);
              final availableHeight =
                  (media.size.height - media.viewInsets.bottom).clamp(
                    0.0,
                    double.infinity,
                  );
              final targetHeight = (availableHeight * 0.3).clamp(160.0, 360.0);
              return AnimatedContainer(
                duration: const Duration(milliseconds: 200),
                height: targetHeight,
                child: CartView(
                  key: _cartViewKey,
                  selectedCustomer: _selectedCustomer,
                  paymentMethod: _paymentMethod,
                  isProcessingSale: _isProcessingSale,
                  onCustomerChanged: _onCustomerChanged,
                  onPaymentMethodChanged: _onPaymentMethodChanged,
                  onCompleteSale: _completeSale,
                ),
              );
            },
          ),
        ],
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\pos\components\cart_view.dart
â•‘ SIZE: 20.46 KB
â•‘ MODIFIED: 10/21/2025 07:26:57
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/models/customer.dart';
import 'package:prostock/models/product.dart';
import 'package:prostock/providers/customer_provider.dart';
import 'package:prostock/providers/inventory_provider.dart';
import 'package:prostock/providers/sales_provider.dart';
import 'package:prostock/utils/app_constants.dart';
import 'package:prostock/utils/currency_utils.dart';

import 'package:provider/provider.dart';

class CartView extends StatefulWidget {
  final Customer? selectedCustomer;
  final String paymentMethod;
  final bool isProcessingSale;
  final ValueChanged<Customer?> onCustomerChanged;
  final ValueChanged<String?> onPaymentMethodChanged;
  final VoidCallback onCompleteSale;

  const CartView({
    super.key,
    required this.selectedCustomer,
    required this.paymentMethod,
    required this.isProcessingSale,
    required this.onCustomerChanged,
    required this.onPaymentMethodChanged,
    required this.onCompleteSale,
  });

  @override
  State<CartView> createState() => CartViewState();
}

class CartViewState extends State<CartView> {
  final TextEditingController _cashTenderedController = TextEditingController();
  double _change = 0.0;

  String getCashTendered() {
    return _cashTenderedController.text;
  }

  double getChange() {
    return _change;
  }

  @override
  void initState() {
    super.initState();
    _cashTenderedController.addListener(_calculateChange);
  }

  @override
  void dispose() {
    _cashTenderedController.removeListener(_calculateChange);
    _cashTenderedController.dispose();
    super.dispose();
  }

  void _calculateChange() {
    final total = Provider.of<SalesProvider>(
      context,
      listen: false,
    ).currentSaleTotal;
    final cashTendered = double.tryParse(_cashTenderedController.text) ?? 0.0;
    setState(() {
      _change = cashTendered - total;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        border: Border(
          top: BorderSide(color: Theme.of(context).colorScheme.outline),
        ),
        color: Theme.of(context).colorScheme.surface,
      ),
      child: SingleChildScrollView(
        // Make entire cart scrollable
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            _buildCartHeader(context),
            _buildCartItems(context),
            _buildCartFooter(context),
          ],
        ),
      ),
    );
  }

  Widget _buildCartHeader(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(UiConstants.spacingSmall),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainer,
        border: Border(
          bottom: BorderSide(color: Theme.of(context).colorScheme.outline),
        ),
      ),
      child: Column(
        children: [
          Consumer<CustomerProvider>(
            builder: (context, provider, child) {
              return DropdownButtonFormField<Customer>(
                initialValue: widget.selectedCustomer,
                decoration: const InputDecoration(
                  labelText: 'Customer',
                  border: OutlineInputBorder(),
                  isDense: true,
                  contentPadding: EdgeInsets.symmetric(
                    horizontal: UiConstants.spacingSmall,
                    vertical: UiConstants.spacingSmall,
                  ),
                ),
                isExpanded: true,
                items: [
                  const DropdownMenuItem<Customer>(
                    value: null,
                    child: Text('Walk-in Customer'),
                  ),
                  ...provider.customers.map(
                    (customer) => DropdownMenuItem<Customer>(
                      value: customer,
                      child: Text(
                        customer.name,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ),
                ],
                onChanged: widget.onCustomerChanged,
              );
            },
          ),
          const SizedBox(height: UiConstants.spacingSmall),
          DropdownButtonFormField<String>(
            initialValue: widget.paymentMethod,
            decoration: const InputDecoration(
              labelText: 'Payment Method',
              border: OutlineInputBorder(),
              isDense: true,
              contentPadding: EdgeInsets.symmetric(
                horizontal: UiConstants.spacingSmall,
                vertical: UiConstants.spacingSmall,
              ),
            ),
            isExpanded: true,
            items: [
              const DropdownMenuItem(value: 'cash', child: Text('Cash')),
              DropdownMenuItem(
                value: 'credit',
                enabled: widget.selectedCustomer != null,
                child: Text(
                  'Credit',
                  style: TextStyle(
                    color: widget.selectedCustomer != null
                        ? Theme.of(context).colorScheme.onSurface
                        : Theme.of(
                            context,
                          ).colorScheme.onSurface.withValues(alpha: 0.5),
                  ),
                ),
              ),
            ],
            onChanged: widget.onPaymentMethodChanged,
          ),
        ],
      ),
    );
  }

  Widget _buildCartItems(BuildContext context) {
    return Consumer<SalesProvider>(
      builder: (context, salesProvider, child) {
        if (salesProvider.currentSaleItems.isEmpty) {
          return Container(
            padding: const EdgeInsets.all(UiConstants.spacingLarge),
            child: const Text(
              'No items in cart',
              style: TextStyle(
                color: Colors.grey,
                fontSize: UiConstants.fontSizeMedium,
              ),
            ),
          );
        }

        // Calculate height based on number of items (max 4 items visible)
        final itemCount = salesProvider.currentSaleItems.length;
        final maxVisibleItems = 4;
        final itemHeight = 85.0; // Increased height to prevent overflow
        final calculatedHeight = itemCount > maxVisibleItems
            ? maxVisibleItems * itemHeight
            : itemCount * itemHeight;

        return Container(
          constraints: BoxConstraints(
            maxHeight: calculatedHeight,
            minHeight: itemHeight,
          ),
          child: ListView.builder(
            shrinkWrap: true,
            padding: const EdgeInsets.symmetric(horizontal: 4),
            itemCount: salesProvider.currentSaleItems.length,
            itemExtent: itemHeight,
            itemBuilder: (context, index) {
              final item = salesProvider.currentSaleItems[index];
              // Get product from inventory provider regardless of current search filter
              final inventoryProvider = context.watch<InventoryProvider>();
              final product =
                  inventoryProvider.getProductById(item.productId) ??
                  Product(
                    name: 'Unknown Product',
                    cost: 0,
                    stock: 0,
                    createdAt: DateTime.now(),
                    updatedAt: DateTime.now(),
                  );

              return Card(
                margin: const EdgeInsets.symmetric(
                  horizontal: UiConstants.spacingSmall,
                  vertical: 2,
                ),
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: UiConstants.spacingSmall,
                    vertical: 4,
                  ),
                  child: Row(
                    children: [
                      // Product info
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          mainAxisAlignment: MainAxisAlignment.center,
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Text(
                              product.name,
                              style: const TextStyle(
                                fontSize: UiConstants.fontSizeSmall,
                                fontWeight: FontWeight.w500,
                              ),
                              overflow: TextOverflow.ellipsis,
                              maxLines: 1,
                            ),
                            const SizedBox(height: 2),
                            Text(
                              '@ ${CurrencyUtils.formatCurrency(item.unitPrice)} each',
                              style: const TextStyle(
                                fontSize: UiConstants.fontSizeExtraSmall,
                                color: Colors.grey,
                              ),
                            ),
                          ],
                        ),
                      ),
                      // Price and controls
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.end,
                        mainAxisAlignment: MainAxisAlignment.center,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text(
                            CurrencyUtils.formatCurrency(item.totalPrice),
                            style: const TextStyle(
                              fontSize: UiConstants.fontSizeSmall,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                          const SizedBox(height: 4),
                          Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              SizedBox(
                                width: 26,
                                height: 26,
                                child: IconButton(
                                  padding: EdgeInsets.zero,
                                  visualDensity: VisualDensity.compact,
                                  constraints: const BoxConstraints.tightFor(
                                    width: 26,
                                    height: 26,
                                  ),
                                  icon: const Icon(
                                    Icons.remove_circle_outline,
                                    size: 18,
                                    color: Colors.red,
                                  ),
                                  onPressed: () {
                                    if (item.quantity > 1) {
                                      salesProvider.updateItemQuantity(
                                        index,
                                        item.quantity - 1,
                                      );
                                    } else {
                                      // Remove item completely when quantity reaches 0
                                      salesProvider.removeItemFromCurrentSale(
                                        index,
                                      );
                                    }
                                  },
                                ),
                              ),
                              Container(
                                constraints: const BoxConstraints(minWidth: 32),
                                padding: const EdgeInsets.symmetric(
                                  horizontal: 8,
                                  vertical: 2,
                                ),
                                decoration: BoxDecoration(
                                  border: Border.all(
                                    color: Theme.of(
                                      context,
                                    ).colorScheme.outline,
                                    width: 0.5,
                                  ),
                                  borderRadius: BorderRadius.circular(4),
                                ),
                                child: Text(
                                  '${item.quantity}',
                                  textAlign: TextAlign.center,
                                  style: const TextStyle(
                                    fontSize: UiConstants.fontSizeExtraSmall,
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                              ),
                              SizedBox(
                                width: 26,
                                height: 26,
                                child: IconButton(
                                  padding: EdgeInsets.zero,
                                  visualDensity: VisualDensity.compact,
                                  constraints: const BoxConstraints.tightFor(
                                    width: 26,
                                    height: 26,
                                  ),
                                  icon: const Icon(
                                    Icons.add_circle_outline,
                                    size: 18,
                                    color: Colors.green,
                                  ),
                                  onPressed: () {
                                    salesProvider.updateItemQuantity(
                                      index,
                                      item.quantity + 1,
                                    );
                                  },
                                ),
                              ),
                            ],
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        );
      },
    );
  }

  Widget _buildCartFooter(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: UiConstants.spacingSmall,
        vertical: 8,
      ),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        border: Border(
          top: BorderSide(color: Theme.of(context).colorScheme.outline),
        ),
        boxShadow: [
          BoxShadow(
            color: Theme.of(context).colorScheme.shadow.withAlpha(26),
            spreadRadius: 1,
            blurRadius: 2,
            offset: const Offset(0, -1),
          ),
        ],
      ),
      child: Consumer<SalesProvider>(
        builder: (context, provider, child) {
          return Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  const Text(
                    'Total:',
                    style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                  ),
                  Text(
                    CurrencyUtils.formatCurrency(provider.currentSaleTotal),
                    style: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                      color: Colors.green,
                    ),
                  ),
                ],
              ),
              if (widget.paymentMethod == 'cash') ...[
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: TextFormField(
                        controller: _cashTenderedController,
                        keyboardType: const TextInputType.numberWithOptions(
                          decimal: true,
                        ),
                        decoration: const InputDecoration(
                          labelText: 'Cash Tendered',
                          border: OutlineInputBorder(),
                          isDense: true,
                          prefixText: '₱ ',
                          contentPadding: EdgeInsets.symmetric(
                            horizontal: 8,
                            vertical: 8,
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(width: 8),
                    Flexible(
                      child: Container(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 8,
                          vertical: 12,
                        ),
                        decoration: BoxDecoration(
                          color: _change >= 0
                              ? Colors.blue[50]
                              : Colors.red[50],
                          border: Border.all(
                            color: _change >= 0 ? Colors.blue : Colors.red,
                          ),
                          borderRadius: BorderRadius.circular(4),
                        ),
                        child: Text(
                          'Change: ${CurrencyUtils.formatCurrency(_change)}',
                          style: TextStyle(
                            fontSize: 12,
                            fontWeight: FontWeight.bold,
                            color: _change >= 0 ? Colors.blue : Colors.red,
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ],
              const SizedBox(height: 8),
              Row(
                children: [
                  Expanded(
                    child: ElevatedButton(
                      onPressed: provider.currentSaleItems.isEmpty
                          ? null
                          : () {
                              provider.clearCurrentSale();
                              _cashTenderedController.clear();
                            },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Theme.of(
                          context,
                        ).colorScheme.secondary,
                        foregroundColor: Theme.of(
                          context,
                        ).colorScheme.onSecondary,
                        padding: const EdgeInsets.symmetric(vertical: 8),
                      ),
                      child: const Text(
                        'Clear',
                        style: TextStyle(fontSize: 12),
                      ),
                    ),
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    flex: 2,
                    child: ElevatedButton(
                      onPressed:
                          provider.currentSaleItems.isEmpty ||
                              widget.isProcessingSale ||
                              (widget.paymentMethod == 'cash' &&
                                  (double.tryParse(
                                            _cashTenderedController.text,
                                          ) ??
                                          0.0) <
                                      provider.currentSaleTotal)
                          ? null
                          : widget.onCompleteSale,
                      style: ElevatedButton.styleFrom(
                        padding: const EdgeInsets.symmetric(vertical: 8),
                      ),
                      child: widget.isProcessingSale
                          ? SizedBox(
                              width: 16,
                              height: 16,
                              child: CircularProgressIndicator(
                                color: Theme.of(context).colorScheme.onPrimary,
                                strokeWidth: 2,
                              ),
                            )
                          : const Text(
                              'Checkout',
                              style: TextStyle(fontSize: 12),
                            ),
                    ),
                  ),
                ],
              ),
            ],
          );
        },
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\pos\components\product_grid_view.dart
â•‘ SIZE: 16.25 KB
â•‘ MODIFIED: 10/27/2025 09:14:13
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import 'package:prostock/providers/inventory_provider.dart';
import 'package:prostock/providers/sales_provider.dart';
import 'package:prostock/utils/app_constants.dart';
import 'package:prostock/utils/currency_utils.dart';
import 'package:prostock/services/tax_service.dart';

class ProductGridView extends StatelessWidget {
  const ProductGridView({super.key});

  @override
  Widget build(BuildContext context) {
    return Consumer<InventoryProvider>(
      builder: (context, provider, child) {
        if (provider.isLoading) {
          return LayoutBuilder(
            builder: (context, constraints) {
              return SingleChildScrollView(
                padding: const EdgeInsets.all(UiConstants.spacingMedium),
                child: ConstrainedBox(
                  constraints: BoxConstraints(minHeight: constraints.maxHeight),
                  child: const Center(
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        CircularProgressIndicator(),
                        SizedBox(height: 16),
                        Text('Loading products...'),
                      ],
                    ),
                  ),
                ),
              );
            },
          );
        }

        if (provider.error != null) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(provider.error!),
                backgroundColor: Theme.of(context).colorScheme.error,
                duration: const Duration(seconds: 4),
                action: SnackBarAction(
                  label: 'Retry',
                  textColor: Theme.of(context).colorScheme.onError,
                  onPressed: () {
                    provider.loadProducts(refresh: true);
                  },
                ),
              ),
            );
            provider.clearError();
          });
        }

        final productsToDisplay = provider.products;

        if (productsToDisplay.isEmpty) {
          return LayoutBuilder(
            builder: (context, constraints) {
              return SingleChildScrollView(
                padding: const EdgeInsets.all(UiConstants.spacingMedium),
                child: ConstrainedBox(
                  constraints: BoxConstraints(minHeight: constraints.maxHeight),
                  child: Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(
                          Icons.search_off,
                          size: 64,
                          color: Theme.of(context).colorScheme.outline,
                        ),
                        const SizedBox(height: 16),
                        Text(
                          'No products found',
                          style: Theme.of(context).textTheme.titleLarge
                              ?.copyWith(
                                color: Theme.of(
                                  context,
                                ).colorScheme.onSurfaceVariant,
                              ),
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'Try adjusting your search or add new products',
                          style: Theme.of(context).textTheme.bodyMedium
                              ?.copyWith(
                                color: Theme.of(
                                  context,
                                ).colorScheme.onSurfaceVariant,
                              ),
                          textAlign: TextAlign.center,
                        ),
                        const SizedBox(height: 16),
                        ElevatedButton.icon(
                          onPressed: () => provider.loadProducts(refresh: true),
                          icon: const Icon(Icons.refresh),
                          label: const Text('Refresh'),
                        ),
                      ],
                    ),
                  ),
                ),
              );
            },
          );
        }

        return GridView.builder(
          padding: const EdgeInsets.all(UiConstants.spacingMedium),
          gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: 3,
            crossAxisSpacing: UiConstants.spacingSmall,
            mainAxisSpacing: UiConstants.spacingSmall,
            childAspectRatio: 0.8,
          ),
          itemCount: productsToDisplay.length,
          physics: const AlwaysScrollableScrollPhysics(),
          itemBuilder: (context, index) {
            final product = productsToDisplay[index];
            final visualStock = provider.getVisualStock(product.id!);
            final isOutOfStock = visualStock <= 0;
            final isLowStock = product.isLowStock && !isOutOfStock;
            final isQueued = !provider.isOnline;
            final colorScheme = Theme.of(context).colorScheme;
            final textTheme = Theme.of(context).textTheme;

            // Determine stock status colors
            Color stockBadgeColor;
            Color stockBadgeTextColor;
            if (isOutOfStock) {
              stockBadgeColor = colorScheme.errorContainer;
              stockBadgeTextColor = colorScheme.onErrorContainer;
            } else if (isLowStock) {
              stockBadgeColor = colorScheme.tertiaryContainer;
              stockBadgeTextColor = colorScheme.onTertiaryContainer;
            } else {
              stockBadgeColor = colorScheme.primaryContainer;
              stockBadgeTextColor = colorScheme.onPrimaryContainer;
            }

            return Card(
              elevation: isOutOfStock ? 0 : 1,
              clipBehavior: Clip.antiAlias,
              child: InkWell(
                onTap: isOutOfStock
                    ? null
                    : () async {
                        await Provider.of<SalesProvider>(
                          context,
                          listen: false,
                        ).addItemToCurrentSale(product, 1);
                      },
                borderRadius: BorderRadius.circular(12),
                child: Stack(
                  children: [
                    // Main content with opacity for out-of-stock
                    Opacity(
                      opacity: isOutOfStock ? 0.5 : 1.0,
                      child: Padding(
                        padding: const EdgeInsets.all(6),
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            // Icon/Image area with stock badge
                            Expanded(
                              flex: 3,
                              child: Stack(
                                children: [
                                  Container(
                                    width: double.infinity,
                                    decoration: BoxDecoration(
                                      color: colorScheme.surfaceContainer,
                                      borderRadius: BorderRadius.circular(
                                        UiConstants.borderRadiusStandard,
                                      ),
                                    ),
                                    child: Icon(
                                      Icons.inventory,
                                      size: 32,
                                      color: colorScheme.onSurfaceVariant,
                                    ),
                                  ),
                                  // Stock count badge on icon
                                  Positioned(
                                    bottom: 2,
                                    right: 2,
                                    child: CircleAvatar(
                                      radius: 12,
                                      backgroundColor: stockBadgeColor,
                                      child: Text(
                                        visualStock.toString(),
                                        style: textTheme.labelSmall?.copyWith(
                                          color: stockBadgeTextColor,
                                          fontWeight: FontWeight.bold,
                                          fontSize: 10,
                                        ),
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                            ),
                            const SizedBox(height: 4),

                            // Product name
                            Expanded(
                              flex: 2,
                              child: Text(
                                product.name,
                                style: textTheme.labelMedium?.copyWith(
                                  fontWeight: FontWeight.bold,
                                ),
                                maxLines: 2,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),

                            // Price
                            FutureBuilder<double>(
                              future: TaxService.calculateSellingPriceWithRule(
                                product.cost,
                                productId: product.id,
                                categoryName: product.category,
                              ),
                              builder: (context, snapshot) {
                                final price = snapshot.data;
                                return Text(
                                  price != null
                                      ? CurrencyUtils.formatCurrency(price)
                                      : '...',
                                  style: textTheme.labelLarge?.copyWith(
                                    color: colorScheme.primary,
                                    fontWeight: FontWeight.bold,
                                  ),
                                  maxLines: 1,
                                  overflow: TextOverflow.ellipsis,
                                );
                              },
                            ),
                          ],
                        ),
                      ),
                    ),

                    // Status badges overlay
                    Positioned(
                      top: 4,
                      right: 4,
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.end,
                        children: [
                          if (isQueued)
                            Container(
                              margin: const EdgeInsets.only(bottom: 4),
                              padding: const EdgeInsets.symmetric(
                                horizontal: 6,
                                vertical: 3,
                              ),
                              decoration: BoxDecoration(
                                color: colorScheme.secondaryContainer,
                                borderRadius: BorderRadius.circular(6),
                                border: Border.all(
                                  color: colorScheme.outline.withValues(
                                    alpha: 0.3,
                                  ),
                                  width: 1,
                                ),
                              ),
                              child: Text(
                                'Queued',
                                style: textTheme.labelSmall?.copyWith(
                                  color: colorScheme.onSecondaryContainer,
                                  fontWeight: FontWeight.w600,
                                  fontSize: 9,
                                ),
                              ),
                            ),
                          if (isOutOfStock)
                            Container(
                              padding: const EdgeInsets.symmetric(
                                horizontal: 6,
                                vertical: 3,
                              ),
                              decoration: BoxDecoration(
                                color: colorScheme.errorContainer,
                                borderRadius: BorderRadius.circular(6),
                                border: Border.all(
                                  color: colorScheme.error.withValues(
                                    alpha: 0.3,
                                  ),
                                  width: 1,
                                ),
                              ),
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  Icon(
                                    Icons.remove_circle_outline,
                                    size: 10,
                                    color: colorScheme.onErrorContainer,
                                  ),
                                  const SizedBox(width: 2),
                                  Text(
                                    'Out',
                                    style: textTheme.labelSmall?.copyWith(
                                      color: colorScheme.onErrorContainer,
                                      fontWeight: FontWeight.bold,
                                      fontSize: 9,
                                    ),
                                  ),
                                ],
                              ),
                            )
                          else if (isLowStock)
                            Container(
                              padding: const EdgeInsets.symmetric(
                                horizontal: 6,
                                vertical: 3,
                              ),
                              decoration: BoxDecoration(
                                color: colorScheme.tertiaryContainer,
                                borderRadius: BorderRadius.circular(6),
                                border: Border.all(
                                  color: colorScheme.tertiary.withValues(
                                    alpha: 0.3,
                                  ),
                                  width: 1,
                                ),
                              ),
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  Icon(
                                    Icons.warning_amber_rounded,
                                    size: 10,
                                    color: colorScheme.onTertiaryContainer,
                                  ),
                                  const SizedBox(width: 2),
                                  Text(
                                    'Low',
                                    style: textTheme.labelSmall?.copyWith(
                                      color: colorScheme.onTertiaryContainer,
                                      fontWeight: FontWeight.bold,
                                      fontSize: 9,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        );
      },
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\pos\components\product_search_view.dart
â•‘ SIZE: 1.92 KB
â•‘ MODIFIED: 09/19/2025 14:08:59
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/utils/app_constants.dart';

class ProductSearchView extends StatefulWidget {
  final TextEditingController controller;
  final ValueChanged<String> onChanged;

  const ProductSearchView({
    super.key,
    required this.controller,
    required this.onChanged,
  });

  @override
  State<ProductSearchView> createState() => _ProductSearchViewState();
}

class _ProductSearchViewState extends State<ProductSearchView> {
  bool _isSearching = false;

  @override
  void initState() {
    super.initState();
    widget.controller.addListener(_onTextChanged);
  }

  @override
  void dispose() {
    widget.controller.removeListener(_onTextChanged);
    super.dispose();
  }

  void _onTextChanged() {
    setState(() {
      _isSearching = widget.controller.text.isNotEmpty;
    });
  }

  void _clearSearch() {
    widget.controller.clear();
    widget.onChanged('');
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(UiConstants.spacingMedium),
      child: TextField(
        controller: widget.controller,
        onChanged: widget.onChanged,
        decoration: InputDecoration(
          hintText: 'Search products by name, barcode, or description...',
          prefixIcon: const Icon(Icons.search),
          suffixIcon: _isSearching
              ? IconButton(
                  icon: const Icon(Icons.clear),
                  onPressed: _clearSearch,
                  tooltip: 'Clear search',
                )
              : null,
          border: const OutlineInputBorder(),
          isDense: true,
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 12,
          ),
        ),
        textInputAction: TextInputAction.search,
        onSubmitted: (value) {
          // Trigger search immediately on submit
          widget.onChanged(value);
        },
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\report_tabs\reports_screen.dart
â•‘ SIZE: 5.95 KB
â•‘ MODIFIED: 10/04/2025 04:57:01
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/models/loss.dart';
import 'package:prostock/providers/customer_provider.dart';
import 'package:prostock/providers/inventory_provider.dart';
import 'package:prostock/providers/sales_provider.dart';
import 'package:prostock/providers/stock_movement_provider.dart';
import 'package:prostock/screens/report_tabs/components/customers_report_tab.dart';
import 'package:prostock/screens/report_tabs/components/financial_report_tab.dart';
import 'package:prostock/screens/report_tabs/components/inventory_report_tab.dart';
import 'package:prostock/screens/report_tabs/components/report_tabs.dart';
import 'package:prostock/screens/report_tabs/components/sales_report_tab.dart';
import 'package:prostock/services/firestore/inventory_service.dart';
import 'package:prostock/services/firestore/sale_service.dart';
import 'package:prostock/services/local_database_service.dart';
import 'package:prostock/services/offline_manager.dart';
import 'package:prostock/widgets/analytics_report_widget.dart';
import 'package:prostock/widgets/stock_movement_report_widget.dart';
import 'package:prostock/widgets/sync_status_indicator.dart';
import 'package:provider/provider.dart';
import 'package:prostock/models/sale_item.dart';
import 'package:prostock/models/credit_transaction.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

class ReportsScreen extends StatefulWidget {
  const ReportsScreen({super.key});

  @override
  State<ReportsScreen> createState() => _ReportsScreenState();
}

class _ReportsScreenState extends State<ReportsScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  List<Loss> _losses = [];
  List<SaleItem> _saleItems = [];
  List<CreditTransaction> _creditTransactions = [];

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: ReportTabs.tabs.length, vsync: this);
    WidgetsBinding.instance.addPostFrameCallback((_) => _loadData());
  }

  Future<void> _loadData({bool refresh = false}) async {
    final salesProvider = Provider.of<SalesProvider>(context, listen: false);
    final customersProvider = Provider.of<CustomerProvider>(
      context,
      listen: false,
    );
    final inventoryProvider = Provider.of<InventoryProvider>(
      context,
      listen: false,
    );
    final stockMovementProvider = Provider.of<StockMovementProvider>(
      context,
      listen: false,
    );
    final offlineManager = Provider.of<OfflineManager>(context, listen: false);
    final inventoryService = InventoryService(FirebaseFirestore.instance);
    // final saleService = SaleService(FirebaseFirestore.instance);

    await salesProvider.loadSales(refresh: refresh);
    if (!mounted) return;
    await customersProvider.loadCustomers(refresh: refresh);
    if (!mounted) return;
    await inventoryProvider.loadProducts(refresh: refresh);
    if (!mounted) return;
    await stockMovementProvider.loadMovements(refresh: refresh);

    // Load losses from both Firestore and local database
    List<Loss> losses = [];
    if (offlineManager.isOnline) {
      losses = await inventoryService.getLosses();
    } else {
      final localLossesData = await LocalDatabaseService.instance.getLosses();
      losses = localLossesData.map((loss) => Loss.fromMap(loss)).toList();
    }

    // Prefer provider-managed sale items when available.
    // If online, provider already fetched sale items from Firestore for all loaded sales.
    // If offline, fall back to local DB per sale.
    List<SaleItem> allSaleItems = [];
    if (offlineManager.isOnline && salesProvider.saleItems.isNotEmpty) {
      allSaleItems = salesProvider.saleItems;
    } else {
      for (final sale in salesProvider.sales) {
        if (sale.id != null) {
          final localItems = await LocalDatabaseService.instance.getSaleItems(
            sale.id!,
          );
          allSaleItems.addAll(
            localItems.map((item) => SaleItem.fromMap(item)).toList(),
          );
        }
      }
    }

    final creditTx = await _loadCreditTransactions(offlineManager);
    if (mounted) {
      setState(() {
        _losses = losses;
        _saleItems = allSaleItems;
        _creditTransactions = creditTx;
      });
    }
  }

  Future<List<CreditTransaction>> _loadCreditTransactions(
    OfflineManager offlineManager,
  ) async {
    try {
      if (offlineManager.isOnline) {
        final saleService = SaleService(FirebaseFirestore.instance);
        return await saleService.getAllCreditTransactions();
      } else {
        final rows = await LocalDatabaseService.instance
            .getAllCreditTransactions();
        return rows
            .map((m) => CreditTransaction.fromMap(m, m['id']?.toString() ?? ''))
            .toList();
      }
    } catch (_) {
      return [];
    }
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Reports'),
        actions: [
          const SyncStatusIndicator(),
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () => _loadData(refresh: true),
          ),
        ],
        bottom: TabBar(
          controller: _tabController,
          isScrollable: true,
          tabs: ReportTabs.tabs,
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          const SalesReportTab(),
          const InventoryReportTab(),
          CustomersReportTab(creditTransactions: _creditTransactions),
          FinancialReportTab(
            losses: _losses,
            creditTransactions: _creditTransactions,
          ),
          AnalyticsReportWidget(saleItems: _saleItems, losses: _losses),
          const StockMovementReportWidget(),
        ],
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\report_tabs\components\customers_report_tab.dart
â•‘ SIZE: 37.14 KB
â•‘ MODIFIED: 10/29/2025 19:23:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/providers/sales_provider.dart';
import 'package:prostock/providers/inventory_provider.dart';
import 'package:prostock/models/credit_transaction.dart';
import 'package:prostock/screens/customers/dialogs/customer_details_dialog.dart';
import 'package:provider/provider.dart';
import 'package:prostock/providers/customer_provider.dart';
import 'package:prostock/services/report_service.dart';
import 'package:prostock/utils/currency_utils.dart';
import 'package:prostock/widgets/report_helpers.dart';
import 'package:prostock/services/pdf_report_service.dart';
import 'package:prostock/widgets/export_filter_dialog.dart';
import 'dart:io';

class CustomersReportTab extends StatelessWidget {
  final List<CreditTransaction> creditTransactions;
  const CustomersReportTab({super.key, this.creditTransactions = const []});

  @override
  Widget build(BuildContext context) {
    final reportService = ReportService();
    return Consumer2<CustomerProvider, SalesProvider>(
      builder: (context, customerProvider, salesProvider, child) {
        final totalCustomers = reportService.calculateTotalCustomers(
          customerProvider.customers,
        );
        final customersWithBalance = reportService
            .calculateCustomersWithBalance(customerProvider.customers);
        final totalBalance = reportService.calculateTotalBalance(
          customerProvider.customers,
        );

        // Calculate additional metrics
        final activeCustomers = customerProvider.customers
            .where((c) => c.balance == 0)
            .length;
        final averageBalance = customersWithBalance > 0
            ? totalBalance / customersWithBalance
            : 0.0;
        final totalCreditReceived = reportService.calculateTotalCreditPayments(
          creditTransactions,
        );
        final highestBalance = customerProvider.customers.isNotEmpty
            ? customerProvider.customers
                  .map((c) => c.balance)
                  .reduce((a, b) => a > b ? a : b)
            : 0.0;

        return SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  ElevatedButton.icon(
                    icon: const Icon(Icons.picture_as_pdf),
                    label: const Text('Export PDF'),
                    onPressed: () async {
                      try {
                        // Show filter options
                        final exportOptions = ExportFilterOptions(
                          useDataRangeFilter: false,
                          startDate: null,
                          endDate: null,
                        );

                        // Show the filter dialog
                        final result = await showDialog<ExportFilterOptions>(
                          context: context,
                          builder: (context) => ExportFilterDialog(
                            initialOptions: exportOptions,
                            onApply: (options) {
                              Navigator.of(context).pop(options);
                            },
                          ),
                        );

                        // If user cancelled the dialog
                        if (result == null || !context.mounted) return;

                        final options = result;
                        final scaffold = ScaffoldMessenger.of(context);

                        // Show loading indicator
                        scaffold.showSnackBar(
                          const SnackBar(
                            content: Text('Generating PDF...'),
                            duration: Duration(seconds: 2),
                          ),
                        );

                        final pdf = PdfReportService();
                        final inventory = context.read<InventoryProvider>();
                        final productById = {
                          for (final p in inventory.products) p.id: p,
                        };
                        final sections = <PdfReportSection>[
                          PdfReportSection(
                            title: 'Customer Summary',
                            rows: [
                              ['Total Customers', totalCustomers.toString()],
                              ['Active Customers', activeCustomers.toString()],
                              ['With Balance', customersWithBalance.toString()],
                              [
                                'Total Outstanding',
                                CurrencyUtils.formatCurrency(totalBalance),
                              ],
                              [
                                'Average Balance',
                                CurrencyUtils.formatCurrency(averageBalance),
                              ],
                              [
                                'Total Credit Received',
                                CurrencyUtils.formatCurrency(
                                  totalCreditReceived,
                                ),
                              ],
                              [
                                'Highest Balance',
                                CurrencyUtils.formatCurrency(highestBalance),
                              ],
                            ],
                          ),
                        ];

                        // Build per-customer total payments received
                        final Map<String, double> paymentsByCustomer = {};
                        for (final tx in creditTransactions.where(
                          (t) => t.type.toLowerCase() == 'payment',
                        )) {
                          paymentsByCustomer.update(
                            tx.customerId,
                            (v) => v + tx.amount,
                            ifAbsent: () => tx.amount,
                          );
                        }

                        if (paymentsByCustomer.isNotEmpty) {
                          final nameById = {
                            for (final c in customerProvider.customers)
                              c.id: c.name,
                          };
                          final paymentRows = <List<String>>[];
                          double totalReceived = 0.0;
                          final customerIds =
                              paymentsByCustomer.keys.toList(growable: false)
                                ..sort(
                                  (a, b) => (nameById[a] ?? a).compareTo(
                                    nameById[b] ?? b,
                                  ),
                                );
                          for (final id in customerIds) {
                            final name = nameById[id] ?? 'Unknown Customer';
                            final amount = paymentsByCustomer[id] ?? 0.0;
                            paymentRows.add([
                              name,
                              CurrencyUtils.formatCurrency(amount),
                            ]);
                            totalReceived += amount;
                          }
                          paymentRows.add([
                            'Total Received',
                            CurrencyUtils.formatCurrency(totalReceived),
                          ]);
                          sections.add(
                            PdfReportSection(
                              title: 'Customer Payments Received',
                              rows: paymentRows,
                            ),
                          );
                        }

                        // Build per-customer balances
                        final balanceRows = <List<String>>[];
                        double totalOutstanding = 0.0;
                        final customersSorted = [...customerProvider.customers]
                          ..sort((a, b) => a.name.compareTo(b.name));
                        for (final c in customersSorted) {
                          balanceRows.add([
                            c.name,
                            CurrencyUtils.formatCurrency(c.balance),
                          ]);
                          totalOutstanding += c.balance;
                        }
                        if (balanceRows.isNotEmpty) {
                          balanceRows.add([
                            'Total Outstanding',
                            CurrencyUtils.formatCurrency(totalOutstanding),
                          ]);
                          sections.add(
                            PdfReportSection(
                              title: 'Customer Balances',
                              rows: balanceRows,
                            ),
                          );
                        }

                        // Utang breakdown per customer: products bought on credit
                        // Include both credit sales and credit transactions
                        for (final customer in customersSorted) {
                          final Map<String, int> qtyByProduct = {};
                          final Map<String, double> amountByProduct = {};

                          // 1. Process credit sales (from salesProvider.sales)
                          final creditSalesForCustomer = salesProvider.sales
                              .where(
                                (s) =>
                                    (s.customerId == customer.id) &&
                                    s.paymentMethod.toLowerCase() == 'credit',
                              )
                              .toList();

                          if (creditSalesForCustomer.isNotEmpty) {
                            final saleIds = creditSalesForCustomer
                                .map((s) => s.id)
                                .whereType<String>()
                                .toSet();

                            for (final item in salesProvider.saleItems) {
                              if (saleIds.contains(item.saleId)) {
                                qtyByProduct.update(
                                  item.productId,
                                  (v) => v + item.quantity,
                                  ifAbsent: () => item.quantity,
                                );
                                amountByProduct.update(
                                  item.productId,
                                  (v) => v + item.totalPrice,
                                  ifAbsent: () => item.totalPrice,
                                );
                              }
                            }
                          }

                          // 2. Process credit transactions (from CreditTransaction with type 'purchase')
                          final creditTransactionsForCustomer =
                              creditTransactions
                                  .where(
                                    (t) =>
                                        (t.customerId == customer.id) &&
                                        t.type.toLowerCase() == 'purchase',
                                  )
                                  .toList();

                          for (final transaction
                              in creditTransactionsForCustomer) {
                            for (final item in transaction.items) {
                              qtyByProduct.update(
                                item.productId,
                                (v) => v + item.quantity,
                                ifAbsent: () => item.quantity,
                              );
                              amountByProduct.update(
                                item.productId,
                                (v) => v + item.totalPrice,
                                ifAbsent: () => item.totalPrice,
                              );
                            }
                          }

                          if (qtyByProduct.isEmpty) continue;

                          final rows =
                              <List<String>>[]; // [Product, Quantity, Amount]
                          int totalQty = 0;
                          double totalAmt = 0.0;
                          final productIds =
                              qtyByProduct.keys.toList(growable: false)..sort(
                                (a, b) => (productById[a]?.name ?? a).compareTo(
                                  productById[b]?.name ?? b,
                                ),
                              );
                          for (final pid in productIds) {
                            final name =
                                productById[pid]?.name ?? 'Unknown Product';
                            final qty = qtyByProduct[pid] ?? 0;
                            final amt = amountByProduct[pid] ?? 0.0;
                            rows.add([
                              name,
                              qty.toString(),
                              CurrencyUtils.formatCurrency(amt),
                            ]);
                            totalQty += qty;
                            totalAmt += amt;
                          }

                          rows.add([
                            'Total',
                            totalQty.toString(),
                            CurrencyUtils.formatCurrency(totalAmt),
                          ]);

                          sections.add(
                            PdfReportSection(
                              title: 'Utang Breakdown - ${customer.name}',
                              rows: rows,
                            ),
                          );
                        }

                        // Apply filter options to limit data
                        List<PdfReportSection> filteredSections = sections;
                        if (options.limitItemCount || options.summaryOnly) {
                          filteredSections = pdf.applyDataLimits(
                            sections,
                            maxRowsPerSection: options.maxItemCount,
                            summaryOnly: options.summaryOnly,
                          );
                        }

                        try {
                          // Show progress dialog
                          showDialog(
                            context: context,
                            barrierDismissible: false,
                            builder: (context) => const AlertDialog(
                              content: Column(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  CircularProgressIndicator(),
                                  SizedBox(height: 16),
                                  Text('Generating PDF...\nPlease wait.'),
                                ],
                              ),
                            ),
                          );

                          // Generate the PDF with filtered sections in background
                          final file = await pdf.generatePdfInBackground(
                            reportTitle:
                                'Customer Activity Report - Sari-Sari Store',
                            startDate: null,
                            endDate: null,
                            sections: filteredSections,
                          );

                          // Close progress dialog
                          if (!context.mounted) return;
                          Navigator.of(context).pop();

                          if (!context.mounted) return;
                          scaffold.showSnackBar(
                            SnackBar(
                              content: Text('PDF saved: ${file.path}'),
                              backgroundColor: Colors.green,
                              duration: const Duration(seconds: 4),
                            ),
                          );
                        } catch (e) {
                          // Close progress dialog if still showing
                          if (!context.mounted) return;
                          if (Navigator.canPop(context)) {
                            Navigator.of(context).pop();
                          }

                          // If we get TooManyPagesException, try paginated approach
                          if (e.toString().contains('TooManyPagesException')) {
                            scaffold.showSnackBar(
                              const SnackBar(
                                content: Text(
                                  'Document too large, splitting into multiple PDFs...',
                                ),
                                backgroundColor: Colors.orange,
                                duration: Duration(seconds: 3),
                              ),
                            );

                            // Show progress dialog for paginated generation
                            showDialog(
                              context: context,
                              barrierDismissible: false,
                              builder: (context) => const AlertDialog(
                                content: Column(
                                  mainAxisSize: MainAxisSize.min,
                                  children: [
                                    CircularProgressIndicator(),
                                    SizedBox(height: 16),
                                    Text(
                                      'Creating multiple PDF files...\nPlease wait.',
                                    ),
                                  ],
                                ),
                              ),
                            );

                            // Generate paginated PDFs in background
                            final files = await pdf
                                .generatePaginatedPDFsInBackground(
                                  reportTitle:
                                      'Customer Activity Report - Sari-Sari Store',
                                  startDate: null,
                                  endDate: null,
                                  sections: filteredSections,
                                  sectionsPerPdf: 3, // Fewer sections per PDF
                                );

                            // Close progress dialog
                            if (!context.mounted) return;
                            Navigator.of(context).pop();

                            if (!context.mounted) return;

                            scaffold.showSnackBar(
                              SnackBar(
                                content: Text(
                                  'Generated ${files.length} PDF files in ${Directory(files.first.parent.path).path}',
                                ),
                                backgroundColor: Colors.green,
                                duration: const Duration(seconds: 4),
                              ),
                            );
                          } else {
                            rethrow; // Re-throw to be caught by outer catch
                          }
                        }
                      } catch (e) {
                        if (context.mounted) {
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                              content: Text('Error generating PDF: $e'),
                              backgroundColor: Colors.red,
                              duration: const Duration(seconds: 5),
                            ),
                          );
                        }
                      }
                    },
                  ),
                ],
              ),
              const SizedBox(height: 12),
              // Enhanced summary cards grid
              GridView.count(
                crossAxisCount: 2,
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                childAspectRatio: 1.3,
                crossAxisSpacing: 12,
                mainAxisSpacing: 12,
                children: [
                  buildSummaryCard(
                    context,
                    'Total Customers',
                    totalCustomers.toString(),
                    Icons.people,
                    Colors.blue,
                  ),
                  buildSummaryCard(
                    context,
                    'Active Customers',
                    activeCustomers.toString(),
                    Icons.person_outline,
                    Colors.green,
                  ),
                  buildSummaryCard(
                    context,
                    'With Balance',
                    customersWithBalance.toString(),
                    Icons.credit_card_off,
                    Colors.orange,
                  ),
                  buildSummaryCard(
                    context,
                    'Total Credit Received',
                    CurrencyUtils.formatCurrency(totalCreditReceived),
                    Icons.credit_card,
                    Colors.purple,
                  ),
                ],
              ),

              const SizedBox(height: 16),

              // Balance summary cards
              Row(
                children: [
                  Expanded(
                    child: buildSummaryCard(
                      context,
                      'Total Outstanding',
                      CurrencyUtils.formatCurrency(totalBalance),
                      Icons.account_balance,
                      Colors.red,
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: buildSummaryCard(
                      context,
                      'Average Balance',
                      CurrencyUtils.formatCurrency(averageBalance),
                      Icons.calculate,
                      Colors.teal,
                    ),
                  ),
                ],
              ),

              const SizedBox(height: 16),

              buildSummaryCard(
                context,
                'Highest Balance',
                CurrencyUtils.formatCurrency(highestBalance),
                Icons.trending_up,
                Colors.indigo,
              ),

              const SizedBox(height: 24),

              // Customer Analysis
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.surfaceContainer,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      'Customer Analysis',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 12),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Flexible(child: Text('Active Customers:')),
                        Flexible(
                          child: Text(
                            '${totalCustomers > 0 ? ((activeCustomers / totalCustomers) * 100).toStringAsFixed(1) : 0}%',
                            style: const TextStyle(
                              fontWeight: FontWeight.bold,
                              color: Colors.green,
                            ),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Flexible(child: Text('Contact Coverage:')),
                        Flexible(
                          child: Text(
                            '${totalCustomers > 0 ? ((customerProvider.customers.where((c) => c.phone?.isNotEmpty == true).length / totalCustomers) * 100).toStringAsFixed(1) : 0}%',
                            style: TextStyle(
                              fontWeight: FontWeight.bold,
                              color:
                                  customerProvider.customers
                                              .where(
                                                (c) =>
                                                    c.phone?.isNotEmpty == true,
                                              )
                                              .length /
                                          (totalCustomers == 0
                                              ? 1
                                              : totalCustomers) >=
                                      0.8
                                  ? Colors.green
                                  : Colors.orange,
                            ),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Flexible(child: Text('Collection Status:')),
                        Flexible(
                          child: Text(
                            _getCollectionStatus(totalBalance),
                            style: TextStyle(
                              fontWeight: FontWeight.bold,
                              color: _getCollectionStatusColor(totalBalance),
                            ),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Flexible(child: Text('Customer Health:')),
                        Flexible(
                          child: Text(
                            _getCustomerHealth(
                              customersWithBalance,
                              totalCustomers,
                            ),
                            style: TextStyle(
                              fontWeight: FontWeight.bold,
                              color: _getCustomerHealthColor(
                                customersWithBalance,
                                totalCustomers,
                              ),
                            ),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),

              const SizedBox(height: 24),

              if (customersWithBalance > 0) ...[
                Row(
                  children: [
                    Icon(
                      Icons.account_balance_wallet,
                      color: Theme.of(context).colorScheme.secondary,
                      size: 24,
                    ),
                    const SizedBox(width: 8),
                    Text(
                      'Outstanding Balances',
                      style: Theme.of(context).textTheme.titleLarge?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                ListView.builder(
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  itemCount: customerProvider.customers
                      .where((c) => c.balance > 0)
                      .length,
                  itemBuilder: (context, index) {
                    final customer =
                        customerProvider.customers
                            .where((c) => c.balance > 0)
                            .toList()
                          ..sort((a, b) => b.balance.compareTo(a.balance));
                    final customerData = customer[index];
                    final isHighPriority =
                        customerData.balance > (averageBalance * 1.5);
                    final colorScheme = Theme.of(context).colorScheme;
                    final textTheme = Theme.of(context).textTheme;

                    return Card(
                      elevation: 1,
                      margin: const EdgeInsets.only(bottom: 8),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: InkWell(
                        onTap: () {
                          showDialog(
                            context: context,
                            builder: (context) =>
                                CustomerDetailsDialog(customer: customerData),
                          );
                        },
                        borderRadius: BorderRadius.circular(12),
                        child: Padding(
                          padding: const EdgeInsets.all(12),
                          child: Row(
                            children: [
                              // Icon
                              Container(
                                width: 48,
                                height: 48,
                                decoration: BoxDecoration(
                                  color: isHighPriority
                                      ? colorScheme.errorContainer
                                      : colorScheme.secondaryContainer,
                                  borderRadius: BorderRadius.circular(24),
                                ),
                                child: Icon(
                                  isHighPriority
                                      ? Icons.priority_high
                                      : Icons.person,
                                  color: isHighPriority
                                      ? colorScheme.onErrorContainer
                                      : colorScheme.onSecondaryContainer,
                                  size: 24,
                                ),
                              ),
                              const SizedBox(width: 12),

                              // Content
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      customerData.name,
                                      style: textTheme.titleMedium?.copyWith(
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                    const SizedBox(height: 4),
                                    Text(
                                      'Phone: ${customerData.phone ?? 'Not provided'}',
                                      style: textTheme.bodySmall?.copyWith(
                                        color: colorScheme.onSurfaceVariant,
                                      ),
                                    ),
                                    if (customerData.phone?.isEmpty != false)
                                      Text(
                                        'No contact info',
                                        style: textTheme.bodySmall?.copyWith(
                                          color: colorScheme.error,
                                          fontStyle: FontStyle.italic,
                                        ),
                                      ),
                                  ],
                                ),
                              ),

                              // Amount & Badge
                              Column(
                                mainAxisAlignment: MainAxisAlignment.center,
                                crossAxisAlignment: CrossAxisAlignment.end,
                                children: [
                                  Text(
                                    CurrencyUtils.formatCurrency(
                                      customerData.balance,
                                    ),
                                    style: textTheme.titleMedium?.copyWith(
                                      fontWeight: FontWeight.bold,
                                      color: isHighPriority
                                          ? colorScheme.error
                                          : colorScheme.secondary,
                                    ),
                                  ),
                                  if (isHighPriority) ...[
                                    const SizedBox(height: 4),
                                    Container(
                                      padding: const EdgeInsets.symmetric(
                                        horizontal: 6,
                                        vertical: 2,
                                      ),
                                      decoration: BoxDecoration(
                                        color: colorScheme.errorContainer,
                                        borderRadius: BorderRadius.circular(8),
                                      ),
                                      child: Text(
                                        'HIGH',
                                        style: textTheme.labelSmall?.copyWith(
                                          fontWeight: FontWeight.bold,
                                          color: colorScheme.onErrorContainer,
                                        ),
                                      ),
                                    ),
                                  ],
                                ],
                              ),
                            ],
                          ),
                        ),
                      ),
                    );
                  },
                ),
              ] else ...[
                Center(
                  child: Column(
                    children: [
                      Icon(
                        Icons.check_circle_outline,
                        size: 64,
                        color: Theme.of(context).colorScheme.primary,
                      ),
                      const SizedBox(height: 16),
                      Text(
                        'No Outstanding Balances',
                        style: Theme.of(context).textTheme.titleLarge?.copyWith(
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        'All customers have cleared their balances',
                        style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                          color: Theme.of(context).colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ],
          ),
        );
      },
    );
  }

  String _getCollectionStatus(double totalBalance) {
    if (totalBalance == 0) return 'Excellent';
    if (totalBalance < 10000) return 'Good';
    if (totalBalance < 50000) return 'Fair';
    return 'Needs Attention';
  }

  Color _getCollectionStatusColor(double totalBalance) {
    if (totalBalance == 0) return Colors.green;
    if (totalBalance < 10000) return Colors.blue;
    if (totalBalance < 50000) return Colors.orange;
    return Colors.red;
  }

  String _getCustomerHealth(int withBalance, int total) {
    if (total == 0) return 'No Data';
    final healthyPercentage = ((total - withBalance) / total) * 100;

    if (healthyPercentage >= 90) return 'Excellent';
    if (healthyPercentage >= 75) return 'Good';
    if (healthyPercentage >= 60) return 'Fair';
    return 'Needs Attention';
  }

  Color _getCustomerHealthColor(int withBalance, int total) {
    if (total == 0) return Colors.grey;
    final healthyPercentage = ((total - withBalance) / total) * 100;

    if (healthyPercentage >= 90) return Colors.green;
    if (healthyPercentage >= 75) return Colors.blue;
    if (healthyPercentage >= 60) return Colors.orange;
    return Colors.red;
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\report_tabs\components\financial_report_tab.dart
â•‘ SIZE: 51.78 KB
â•‘ MODIFIED: 10/29/2025 19:23:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/models/loss.dart';
import 'package:prostock/models/sale.dart';
import 'package:prostock/models/sale_item.dart';
import 'package:prostock/models/credit_transaction.dart';
// import 'package:prostock/models/product.dart';
import 'package:prostock/providers/stock_movement_provider.dart';
import 'package:prostock/services/report_service.dart';
import 'package:provider/provider.dart';
import 'package:prostock/providers/sales_provider.dart';
import 'package:prostock/providers/inventory_provider.dart';
import 'package:prostock/providers/customer_provider.dart';
import 'package:prostock/utils/currency_utils.dart';
// import 'package:prostock/utils/constants.dart';

import 'package:prostock/widgets/loss_breakdown_list.dart';
import 'package:prostock/widgets/report_helpers.dart';
import 'package:prostock/utils/error_logger.dart';
import 'package:prostock/widgets/top_selling_products_list.dart';
import 'package:prostock/services/pdf_report_service.dart';
import 'package:prostock/services/historical_cost_service.dart';
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:prostock/widgets/export_filter_dialog.dart';
import 'dart:io';
import 'package:prostock/services/cost_history_service.dart';
import 'package:prostock/services/local_database_service.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

class FinancialReportTab extends StatefulWidget {
  final List<Loss> losses;
  final List<CreditTransaction> creditTransactions;
  const FinancialReportTab({
    super.key,
    required this.losses,
    this.creditTransactions = const [],
  });

  @override
  State<FinancialReportTab> createState() => _FinancialReportTabState();
}

class _FinancialReportTabState extends State<FinancialReportTab> {
  DateTime? _startDate;
  DateTime? _endDate;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final salesProvider = Provider.of<SalesProvider>(context, listen: false);
      final stockMovementProvider = Provider.of<StockMovementProvider>(
        context,
        listen: false,
      );
      salesProvider.loadSales();
      stockMovementProvider.loadAllMovements();
    });
  }

  Future<void> _selectDateRange(BuildContext context) async {
    final initialDateRange = DateTimeRange(
      start: _startDate ?? DateTime.now().subtract(const Duration(days: 30)),
      end: _endDate ?? DateTime.now(),
    );
    final newDateRange = await showDateRangePicker(
      context: context,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
      initialDateRange: initialDateRange,
    );

    if (!mounted) return;

    if (newDateRange != null) {
      setState(() {
        _startDate = newDateRange.start;
        _endDate = newDateRange.end;
      });

      if (!context.mounted) return;
      final salesProvider = Provider.of<SalesProvider>(context, listen: false);
      final stockMovementProvider = Provider.of<StockMovementProvider>(
        context,
        listen: false,
      );

      salesProvider.loadSales(
        startDate: _startDate,
        endDate: _endDate,
        refresh: true,
      );
      stockMovementProvider.loadAllMovements(
        startDate: _startDate,
        endDate: _endDate,
      );
    }
  }

  // Category lookup removed for product-level export

  // Category helpers removed for product-level PDF export

  @override
  Widget build(BuildContext context) {
    final reportService = ReportService();
    return Consumer4<
      SalesProvider,
      InventoryProvider,
      CustomerProvider,
      StockMovementProvider
    >(
      builder: (context, sales, inventory, customers, stockMovements, child) {
        if (sales.isLoading || stockMovements.isLoading) {
          return const Center(child: CircularProgressIndicator());
        }

        final filteredSales = _filterSalesByDate(sales.sales);
        final filteredSaleItems = _filterSaleItemsBySales(
          sales.saleItems,
          filteredSales,
        );
        final filteredLosses = _filterLossesByDate(widget.losses);

        if (filteredSales.isEmpty) {
          return const Center(
            child: Text('No data available for the selected period.'),
          );
        }

        final cashSalesRevenue = reportService.calculateTotalSales(
          filteredSales,
        );
        final creditPaymentsRevenue = reportService
            .calculateTotalCreditPayments(widget.creditTransactions);
        final totalRevenue = cashSalesRevenue + creditPaymentsRevenue;
        final totalCostSales = reportService.calculateTotalCost(
          filteredSaleItems,
          inventory.products,
        );
        final totalCostCredit = reportService
            .calculateTotalCostFromCreditTransactions(
              widget.creditTransactions,
              inventory.products,
            );
        final totalCost = totalCostSales + totalCostCredit;
        final totalLoss = reportService.calculateTotalLoss(filteredLosses);
        final totalProfit = reportService.calculateGrossProfit(
          totalRevenue,
          totalCost,
          totalLoss,
        );
        final outstandingUtang = reportService.calculateTotalBalance(
          customers.customers,
        );

        final profitMargin = reportService.calculateProfitMargin(
          totalProfit,
          totalRevenue,
        );

        final roi = reportService.calculateRoi(totalProfit, totalCost);

        // NEW CALCULATIONS
        final averageOrderValue = reportService.calculateAverageOrderValue(
          filteredSales,
        );
        final markupPercentage = reportService.calculateMarkupPercentage(
          totalRevenue,
          totalCost,
        );

        // Corrected Inventory Turnover Calculation
        final endingInventoryValue = reportService.calculateTotalInventoryValue(
          inventory.products,
        );
        final beginningInventoryValue = reportService
            .calculateBeginningInventoryValue(
              inventory.products,
              stockMovements.allMovements,
            );
        final averageInventoryValue =
            (beginningInventoryValue + endingInventoryValue) / 2;

        final inventoryTurnover = reportService.calculateInventoryTurnover(
          totalCost,
          averageInventoryValue,
        );
        // Calculate potential profit asynchronously
        final potentialProfitFuture = reportService
            .calculatePotentialInventoryProfit(inventory.products);

        return FutureBuilder<double>(
          future: potentialProfitFuture,
          builder: (context, snapshot) {
            final potentialProfit = snapshot.hasData ? snapshot.data! : 0.0;

            final topProducts = reportService.getTopSellingProductsByRevenue(
              filteredSaleItems,
              inventory.products,
            );

            final lossBreakdown = reportService.getLossBreakdown(
              filteredLosses,
            );

            return SingleChildScrollView(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      ElevatedButton.icon(
                        icon: const Icon(Icons.picture_as_pdf),
                        label: const Text('Export PDF'),
                        onPressed: () async {
                          try {
                            // Show filter options
                            final exportOptions = ExportFilterOptions(
                              useDataRangeFilter:
                                  _startDate != null && _endDate != null,
                              startDate: _startDate,
                              endDate: _endDate,
                            );

                            // Show the filter dialog
                            if (!context.mounted) return;
                            final result =
                                await showDialog<ExportFilterOptions>(
                                  context: context,
                                  builder: (context) => ExportFilterDialog(
                                    initialOptions: exportOptions,
                                    onApply: (options) async {
                                      Navigator.of(context).pop(options);
                                    },
                                  ),
                                );

                            // If user cancelled the dialog
                            if (result == null || !context.mounted) return;

                            final options = result;
                            final scaffold = ScaffoldMessenger.of(context);

                            // Show loading indicator
                            scaffold.showSnackBar(
                              const SnackBar(
                                content: Text('Generating PDF...'),
                                duration: Duration(seconds: 2),
                              ),
                            );

                            final pdf = PdfReportService();

                            // Category breakdown no longer needed for product-level export

                            // Build income section by product with quantity and price
                            // incomeRows: [product, quantity, unit price, amount]
                            final incomeRows = <List<String>>[];
                            // cogsRows: [product, quantity, cost]
                            final cogsRows = <List<String>>[];

                            // Group sale items by product and unit price
                            final Map<String, Map<double, double>>
                            qtyByProductPrice = {};
                            final Map<String, Map<double, double>>
                            revenueByProductPrice = {};
                            // Also track total quantity per product for COGS computation
                            final Map<String, double> qtyByProduct = {};
                            for (final item in filteredSaleItems) {
                              // Round unit price to 2 decimals to avoid floating noise
                              final roundedUnitPrice =
                                  (item.unitPrice * 100).round() / 100.0;

                              qtyByProduct[item.productId] =
                                  (qtyByProduct[item.productId] ?? 0) +
                                  item.quantity;

                              qtyByProductPrice[item.productId] ??= {};
                              qtyByProductPrice[item
                                      .productId]![roundedUnitPrice] =
                                  (qtyByProductPrice[item
                                          .productId]![roundedUnitPrice] ??
                                      0) +
                                  item.quantity;

                              revenueByProductPrice[item.productId] ??= {};
                              revenueByProductPrice[item
                                      .productId]![roundedUnitPrice] =
                                  (revenueByProductPrice[item
                                          .productId]![roundedUnitPrice] ??
                                      0) +
                                  item.totalPrice;
                            }

                            // Build lookup for product names and costs
                            final productById = {
                              for (final p in inventory.products) p.id: p,
                            };

                            double totalSalesQty = 0;
                            double totalCogsQty = 0;
                            // Build income rows per product per unit price
                            final productIdsSorted =
                                qtyByProductPrice.keys.toList(growable: false)
                                  ..sort(
                                    (a, b) => (productById[a]?.name ?? a)
                                        .compareTo(productById[b]?.name ?? b),
                                  );

                            for (final productId in productIdsSorted) {
                              final product = productById[productId];
                              final name =
                                  product?.name ??
                                  'Unknown Product ($productId)';
                              final priceMap =
                                  qtyByProductPrice[productId] ?? {};
                              final pricesSorted = priceMap.keys.toList(
                                growable: false,
                              )..sort();
                              for (final price in pricesSorted) {
                                final qty = priceMap[price] ?? 0;
                                final revenue =
                                    (revenueByProductPrice[productId] ??
                                        {})[price] ??
                                    0.0;
                                totalSalesQty += qty;
                                incomeRows.add([
                                  name,
                                  qty.toStringAsFixed(0),
                                  CurrencyUtils.formatCurrency(price),
                                  CurrencyUtils.formatCurrency(revenue),
                                ]);
                              }
                            }

                            // COGS rows based on historical cost * qty, grouped by product and cost
                            final Map<String, Map<double, double>>
                            qtyByProductCost = {};
                            final Map<String, Map<double, double>>
                            costByProductCost = {};

                            // Initialize historical cost service
                            final costHistoryService = CostHistoryService(
                              FirebaseFirestore.instance,
                            );
                            final localDatabaseService =
                                LocalDatabaseService.instance;
                            final historicalCostService = HistoricalCostService(
                              costHistoryService,
                              localDatabaseService,
                            );

                            // Get sales provider before async operations
                            final salesProvider = Provider.of<SalesProvider>(
                              context,
                              listen: false,
                            );

                            // Group sale items by product and get historical costs
                            final Map<String, List<SaleItem>> itemsByProduct =
                                {};
                            for (final item in filteredSaleItems) {
                              itemsByProduct[item.productId] ??= [];
                              itemsByProduct[item.productId]!.add(item);
                            }

                            for (final entry in itemsByProduct.entries) {
                              final productId = entry.key;
                              final items = entry.value;

                              // Group by historical cost for each sale item
                              for (final item in items) {
                                // Get historical cost at the time of sale
                                final saleDate = salesProvider.sales
                                    .firstWhere((s) => s.id == item.saleId)
                                    .createdAt;

                                // Get historical cost for this sale item
                                final historicalCost =
                                    await historicalCostService
                                        .getHistoricalCostForSaleItem(
                                          item,
                                          saleDate,
                                        );

                                // Round cost to 2 decimals to avoid floating noise
                                final roundedCost =
                                    (historicalCost * 100).round() / 100.0;

                                qtyByProductCost[productId] ??= {};
                                qtyByProductCost[productId]![roundedCost] =
                                    (qtyByProductCost[productId]![roundedCost] ??
                                        0) +
                                    item.quantity;

                                costByProductCost[productId] ??= {};
                                costByProductCost[productId]![roundedCost] =
                                    (costByProductCost[productId]![roundedCost] ??
                                        0) +
                                    (roundedCost * item.quantity);
                              }
                            }

                            // Build COGS rows per product per cost
                            final cogsProductIdsSorted =
                                qtyByProductCost.keys.toList(growable: false)
                                  ..sort(
                                    (a, b) => (productById[a]?.name ?? a)
                                        .compareTo(productById[b]?.name ?? b),
                                  );

                            for (final productId in cogsProductIdsSorted) {
                              final product = productById[productId];
                              final name =
                                  product?.name ??
                                  'Unknown Product ($productId)';
                              final costMap = qtyByProductCost[productId] ?? {};
                              final costsSorted = costMap.keys.toList(
                                growable: false,
                              )..sort();

                              for (final cost in costsSorted) {
                                final qty = costMap[cost] ?? 0;
                                final totalCost =
                                    (costByProductCost[productId] ??
                                        {})[cost] ??
                                    0.0;
                                totalCogsQty += qty;
                                cogsRows.add([
                                  name,
                                  qty.toStringAsFixed(0),
                                  CurrencyUtils.formatCurrency(cost),
                                  CurrencyUtils.formatCurrency(totalCost),
                                ]);
                              }
                            }

                            // Totals
                            incomeRows.add([
                              'Total Sales',
                              totalSalesQty.toStringAsFixed(0),
                              '-',
                              CurrencyUtils.formatCurrency(totalRevenue),
                            ]);
                            cogsRows.add([
                              'Total COGS',
                              totalCogsQty.toStringAsFixed(0),
                              '-',
                              CurrencyUtils.formatCurrency(totalCost),
                            ]);

                            final sections = <PdfReportSection>[
                              // 1. Income
                              PdfReportSection(
                                title: '1. Income',
                                rows: incomeRows,
                              ),

                              // 2. Cost of Goods Sold
                              PdfReportSection(
                                title: '2. Cost of Goods Sold (COGS)',
                                rows: cogsRows,
                              ),
                            ];

                            final calculations = <PdfCalculationSection>[
                              // 1. Total Revenue
                              PdfCalculationSection(
                                title: '1. Total Revenue',
                                formula: 'Sum of all sales transactions',
                                calculation:
                                    'Sum of ${filteredSaleItems.length} sale items = ${totalRevenue.toStringAsFixed(2)}',
                                result: CurrencyUtils.formatCurrency(
                                  totalRevenue,
                                ),
                              ),

                              // 2. Cost of Goods Sold
                              PdfCalculationSection(
                                title: '2. Cost of Goods Sold',
                                formula:
                                    'Sum of product costs × quantities sold',
                                calculation:
                                    'Sum of (product cost × quantity sold) for each item = ${totalCost.toStringAsFixed(2)}',
                                result: CurrencyUtils.formatCurrency(totalCost),
                              ),

                              // 3. Total Losses
                              PdfCalculationSection(
                                title: '3. Total Losses',
                                formula: 'Sum of damaged/expired items',
                                calculation:
                                    'Sum of ${filteredLosses.length} loss items = ${totalLoss.toStringAsFixed(2)}',
                                result: CurrencyUtils.formatCurrency(totalLoss),
                              ),

                              // 4. Gross Profit
                              PdfCalculationSection(
                                title: '4. Gross Profit',
                                formula:
                                    'Total Revenue - Cost of Goods Sold - Total Losses',
                                calculation:
                                    '${totalRevenue.toStringAsFixed(0).replaceAllMapped(RegExp(r'(\d{1,3})(?=(\d{3})+(?!\d))'), (Match m) => '${m[1]},')} - ${totalCost.toStringAsFixed(0).replaceAllMapped(RegExp(r'(\d{1,3})(?=(\d{3})+(?!\d))'), (Match m) => '${m[1]},')} - ${totalLoss.toStringAsFixed(0).replaceAllMapped(RegExp(r'(\d{1,3})(?=(\d{3})+(?!\d))'), (Match m) => '${m[1]},')} = ${totalProfit.toStringAsFixed(0).replaceAllMapped(RegExp(r'(\d{1,3})(?=(\d{3})+(?!\d))'), (Match m) => '${m[1]},')}',
                                result: CurrencyUtils.formatCurrency(
                                  totalProfit,
                                ),
                              ),

                              // 5. Profit Margin
                              PdfCalculationSection(
                                title: '5. Profit Margin',
                                formula: '(Gross Profit ÷ Total Revenue) × 100',
                                calculation:
                                    '(${totalProfit.toStringAsFixed(2)} ÷ ${totalRevenue.toStringAsFixed(2)}) × 100 = ${profitMargin.toStringAsFixed(1)}%',
                                result: '${profitMargin.toStringAsFixed(1)}%',
                              ),

                              // 6. Markup Percentage
                              PdfCalculationSection(
                                title: '6. Markup Percentage',
                                formula: '((Revenue - Cost) ÷ Cost) × 100',
                                calculation:
                                    '((${totalRevenue.toStringAsFixed(2)} - ${totalCost.toStringAsFixed(2)}) ÷ ${totalCost.toStringAsFixed(2)}) × 100 = ${markupPercentage.toStringAsFixed(1)}%',
                                result:
                                    '${markupPercentage.toStringAsFixed(1)}%',
                              ),

                              // 7. Return on Investment (ROI)
                              PdfCalculationSection(
                                title: '7. Return on Investment (ROI)',
                                formula: '(Total Profit ÷ Total Cost) × 100',
                                calculation:
                                    '(${totalProfit.toStringAsFixed(2)} ÷ ${totalCost.toStringAsFixed(2)}) × 100 = ${roi.toStringAsFixed(1)}%',
                                result: '${roi.toStringAsFixed(1)}%',
                              ),

                              // 8. Inventory Turnover
                              PdfCalculationSection(
                                title: '8. Inventory Turnover',
                                formula: 'COGS ÷ Average Inventory Value',
                                calculation:
                                    '${totalCost.toStringAsFixed(2)} ÷ ${averageInventoryValue.toStringAsFixed(2)} = ${inventoryTurnover.toStringAsFixed(1)}x',
                                result:
                                    '${inventoryTurnover.toStringAsFixed(1)}x',
                              ),
                            ];

                            final summaries = <PdfSummarySection>[];

                            // Apply filter options to limit data
                            List<PdfReportSection> filteredSections = sections;
                            if (options.useDataRangeFilter) {
                              // Date filtering is already applied via _startDate and _endDate
                            }

                            // Apply item count limit and summary-only filter
                            if (options.limitItemCount || options.summaryOnly) {
                              filteredSections = pdf.applyDataLimits(
                                sections,
                                maxRowsPerSection: options.maxItemCount,
                                summaryOnly: options.summaryOnly,
                              );
                            }

                            try {
                              // Show progress dialog
                              if (!context.mounted) return;
                              showDialog(
                                context: context,
                                barrierDismissible: false,
                                builder: (context) => const AlertDialog(
                                  content: Column(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      CircularProgressIndicator(),
                                      SizedBox(height: 16),
                                      Text('Generating PDF...\nPlease wait.'),
                                    ],
                                  ),
                                ),
                              );

                              ErrorLogger.logInfo(
                                'Starting financial report PDF generation',
                                context: 'FinancialReportTab',
                                metadata: {
                                  'filteredSections': filteredSections.length,
                                  'calculations': calculations.length,
                                  'summaries': summaries.length,
                                },
                              );

                              // Generate the PDF with filtered sections in background
                              final file = await pdf.generatePdfInBackground(
                                reportTitle:
                                    'Financial Report - Sari-Sari Store',
                                startDate: options.useDataRangeFilter
                                    ? options.startDate
                                    : _startDate,
                                endDate: options.useDataRangeFilter
                                    ? options.endDate
                                    : _endDate,
                                sections: filteredSections,
                                calculations: calculations,
                                summaries: summaries,
                              );

                              // Close progress dialog
                              if (!context.mounted) return;
                              Navigator.of(context).pop();

                              // Make sure the file exists and has content
                              final fileExists = await file.exists();
                              final fileSize = fileExists
                                  ? await file.length()
                                  : 0;

                              ErrorLogger.logInfo(
                                'PDF file generation successful',
                                context: 'FinancialReportTab',
                                metadata: {
                                  'filePath': file.path,
                                  'fileExists': fileExists,
                                  'fileSize': fileSize,
                                },
                              );

                              if (!context.mounted) return;

                              if (fileExists && fileSize > 0) {
                                // Extract user-friendly location from the path
                                String userFriendlyPath = file.path;
                                if (file.path.contains(
                                  '/My Phone/Internal Storage/Download',
                                )) {
                                  userFriendlyPath = 'Downloads folder';
                                } else if (file.path.contains(
                                  '/storage/emulated/0/Download',
                                )) {
                                  userFriendlyPath = 'Downloads folder';
                                } else if (file.path.contains(
                                  '/sdcard/Download',
                                )) {
                                  userFriendlyPath = 'Downloads folder';
                                } else {
                                  // Try to make the path more readable
                                  final pathParts = file.path.split('/');
                                  if (pathParts.length >= 3) {
                                    userFriendlyPath =
                                        '${pathParts[pathParts.length - 3]}/${pathParts[pathParts.length - 2]}/${pathParts[pathParts.length - 1]}';
                                  }
                                }

                                scaffold.showSnackBar(
                                  SnackBar(
                                    content: Text(
                                      'PDF saved successfully in: $userFriendlyPath',
                                    ),
                                    backgroundColor: Colors.green,
                                    duration: const Duration(seconds: 8),
                                  ),
                                );
                              } else {
                                scaffold.showSnackBar(
                                  SnackBar(
                                    content: Text(
                                      'Error: PDF file was not created properly. Please check storage permissions.',
                                    ),
                                    backgroundColor: Colors.red,
                                    duration: const Duration(seconds: 6),
                                  ),
                                );
                              }
                            } catch (e, stack) {
                              // Log detailed error
                              ErrorLogger.logError(
                                'PDF generation failed',
                                error: e,
                                stackTrace: stack,
                                context: 'FinancialReportTab',
                                metadata: {
                                  'filteredSections': filteredSections.length,
                                  'calculations': calculations.length,
                                  'summaries': summaries.length,
                                },
                              );

                              // Close progress dialog if still showing
                              if (!context.mounted) return;
                              if (Navigator.canPop(context)) {
                                Navigator.of(context).pop();
                              }

                              // Show technical details to help debugging
                              if (kDebugMode) {
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text(
                                      'DEBUG: PDF Error: ${e.toString().substring(0, min(100, e.toString().length))}',
                                    ),
                                    backgroundColor: Colors.red,
                                    duration: const Duration(seconds: 10),
                                  ),
                                );
                              }

                              // If we get TooManyPagesException, try paginated approach
                              if (e.toString().contains(
                                'TooManyPagesException',
                              )) {
                                scaffold.showSnackBar(
                                  const SnackBar(
                                    content: Text(
                                      'Document too large, splitting into multiple PDFs...',
                                    ),
                                    backgroundColor: Colors.orange,
                                    duration: Duration(seconds: 3),
                                  ),
                                );

                                // Show progress dialog for paginated generation
                                showDialog(
                                  context: context,
                                  barrierDismissible: false,
                                  builder: (context) => const AlertDialog(
                                    content: Column(
                                      mainAxisSize: MainAxisSize.min,
                                      children: [
                                        CircularProgressIndicator(),
                                        SizedBox(height: 16),
                                        Text(
                                          'Creating multiple PDF files...\nPlease wait.',
                                        ),
                                      ],
                                    ),
                                  ),
                                );

                                // Generate paginated PDFs in background
                                final files = await pdf
                                    .generatePaginatedPDFsInBackground(
                                      reportTitle:
                                          'Financial Report - Sari-Sari Store',
                                      startDate: options.useDataRangeFilter
                                          ? options.startDate
                                          : _startDate,
                                      endDate: options.useDataRangeFilter
                                          ? options.endDate
                                          : _endDate,
                                      sections: filteredSections,
                                      calculations: calculations,
                                      summaries: summaries,
                                      sectionsPerPdf:
                                          3, // Fewer sections per PDF
                                    );

                                // Close progress dialog
                                if (!context.mounted) return;
                                Navigator.of(context).pop();

                                if (!context.mounted) return;

                                // Extract user-friendly location from the path
                                String userFriendlyPath = Directory(
                                  files.first.parent.path,
                                ).path;
                                if (userFriendlyPath.contains(
                                  '/My Phone/Internal Storage/Download',
                                )) {
                                  userFriendlyPath = 'Downloads folder';
                                } else if (userFriendlyPath.contains(
                                  '/storage/emulated/0/Download',
                                )) {
                                  userFriendlyPath = 'Downloads folder';
                                } else if (userFriendlyPath.contains(
                                  '/sdcard/Download',
                                )) {
                                  userFriendlyPath = 'Downloads folder';
                                }

                                scaffold.showSnackBar(
                                  SnackBar(
                                    content: Text(
                                      'Generated ${files.length} PDF files in $userFriendlyPath',
                                    ),
                                    backgroundColor: Colors.green,
                                    duration: const Duration(seconds: 6),
                                  ),
                                );
                              } else {
                                rethrow; // Re-throw to be caught by outer catch
                              }
                            }
                          } catch (e) {
                            ErrorLogger.logError(
                              'PDF Export Error',
                              error: e,
                              context: 'FinancialReportTab.ExportPDF',
                            );
                            if (!context.mounted) return;

                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(
                                content: Text('Error generating PDF: $e'),
                                backgroundColor: Colors.red,
                                duration: const Duration(seconds: 5),
                              ),
                            );
                          }
                        },
                      ),
                    ],
                  ),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        _startDate == null
                            ? 'All Time'
                            : '${_startDate!.toLocal().toString().split(' ')[0]} - ${_endDate!.toLocal().toString().split(' ')[0]}',
                        style: const TextStyle(fontWeight: FontWeight.bold),
                      ),
                      TextButton.icon(
                        onPressed: () => _selectDateRange(context),
                        icon: const Icon(Icons.calendar_today),
                        label: const Text('Select Date'),
                      ),
                    ],
                  ),

                  // UPDATED: Expanded grid with new metrics
                  GridView.count(
                    crossAxisCount: 2,
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    childAspectRatio: 1.3,
                    crossAxisSpacing: 12,
                    mainAxisSpacing: 12,
                    children: [
                      // Existing cards
                      buildSummaryCard(
                        context,
                        'Total Revenue',
                        CurrencyUtils.formatCurrency(totalRevenue),
                        Icons.trending_up,
                        Colors.green,
                      ),
                      buildSummaryCard(
                        context,
                        'Total Cost',
                        CurrencyUtils.formatCurrency(totalCost),
                        Icons.trending_down,
                        Colors.red,
                      ),
                      buildSummaryCard(
                        context,
                        'Total Loss',
                        CurrencyUtils.formatCurrency(totalLoss),
                        Icons.remove_shopping_cart,
                        Colors.orange,
                      ),
                      buildSummaryCard(
                        context,
                        'Gross Profit',
                        CurrencyUtils.formatCurrency(totalProfit),
                        Icons.signal_cellular_alt,
                        totalProfit >= 0 ? Colors.green : Colors.red,
                      ),

                      // NEW CARDS ADDED HERE
                      buildSummaryCard(
                        context,
                        'Average Order',
                        CurrencyUtils.formatCurrency(averageOrderValue),
                        Icons.shopping_cart_checkout,
                        Colors.purple,
                      ),
                      buildSummaryCard(
                        context,
                        'Markup %',
                        '${markupPercentage.toStringAsFixed(1)}%',
                        Icons.trending_up,
                        Colors.indigo,
                      ),
                    ],
                  ),
                  const SizedBox(height: 16),
                  buildSummaryCard(
                    context,
                    'Outstanding Utang',
                    CurrencyUtils.formatCurrency(outstandingUtang),
                    Icons.credit_card,
                    Colors.red,
                  ),

                  // NEW: Additional metrics row
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      Expanded(
                        child: buildSummaryCard(
                          context,
                          'Inventory Turnover',
                          '${inventoryTurnover.toStringAsFixed(1)}x',
                          Icons.sync,
                          Colors.teal,
                        ),
                      ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: buildSummaryCard(
                          context,
                          'Potential Profit',
                          CurrencyUtils.formatCurrency(potentialProfit),
                          Icons.account_balance_wallet,
                          Colors.amber,
                        ),
                      ),
                    ],
                  ),

                  const SizedBox(height: 24),

                  // UPDATED: Enhanced Profit Analysis section
                  Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(16),
                    decoration: BoxDecoration(
                      color: Theme.of(
                        context,
                      ).colorScheme.surfaceContainerHighest,
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Profit Analysis',
                          style: Theme.of(context).textTheme.titleMedium
                              ?.copyWith(fontWeight: FontWeight.bold),
                        ),
                        const SizedBox(height: 12),
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Flexible(
                              child: Text(
                                'Profit Margin:',
                                style: Theme.of(context).textTheme.bodyMedium,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                            Flexible(
                              child: Text(
                                '${profitMargin.toStringAsFixed(1)}%',
                                style: Theme.of(context).textTheme.bodyMedium
                                    ?.copyWith(
                                      fontWeight: FontWeight.bold,
                                      color: totalProfit >= 0
                                          ? Theme.of(
                                              context,
                                            ).colorScheme.primary
                                          : Theme.of(context).colorScheme.error,
                                    ),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 4),
                        // NEW: Markup Percentage row
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Flexible(
                              child: Text(
                                'Markup Percentage:',
                                style: Theme.of(context).textTheme.bodyMedium,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                            Flexible(
                              child: Text(
                                '${markupPercentage.toStringAsFixed(1)}%',
                                style: Theme.of(context).textTheme.bodyMedium
                                    ?.copyWith(
                                      fontWeight: FontWeight.bold,
                                      color: totalProfit >= 0
                                          ? Theme.of(
                                              context,
                                            ).colorScheme.primary
                                          : Theme.of(context).colorScheme.error,
                                    ),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 4),
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Flexible(
                              child: Text(
                                'Return on Investment:',
                                style: Theme.of(context).textTheme.bodyMedium,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                            Flexible(
                              child: Text(
                                '${roi.toStringAsFixed(1)}%',
                                style: Theme.of(context).textTheme.bodyMedium
                                    ?.copyWith(
                                      fontWeight: FontWeight.bold,
                                      color: totalProfit >= 0
                                          ? Theme.of(
                                              context,
                                            ).colorScheme.primary
                                          : Theme.of(context).colorScheme.error,
                                    ),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 4),
                        // NEW: Stock Turns Per Year
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Flexible(
                              child: Text(
                                'Stock Turns/Year:',
                                style: Theme.of(context).textTheme.bodyMedium,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                            Flexible(
                              child: Text(
                                '${_calculateAnnualizedTurnover(inventoryTurnover).toStringAsFixed(1)}x',
                                style: Theme.of(context).textTheme.bodyMedium
                                    ?.copyWith(fontWeight: FontWeight.bold),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 24),
                  TopSellingProductsList(
                    topProducts: topProducts.map((entry) => entry.key).toList(),
                    saleItems: filteredSaleItems,
                  ),
                  const SizedBox(height: 24),
                  LossBreakdownList(lossBreakdown: lossBreakdown),
                ],
              ),
            );
          },
        );
      },
    );
  }

  // NEW: Helper method to calculate annualized turnover
  double _calculateAnnualizedTurnover(double inventoryTurnover) {
    if (_startDate != null && _endDate != null) {
      final daysDiff = _endDate!.difference(_startDate!).inDays;
      if (daysDiff > 0) {
        return inventoryTurnover * (365 / daysDiff);
      }
    }
    return inventoryTurnover;
  }

  List<Sale> _filterSalesByDate(List<Sale> sales) {
    if (_startDate == null || _endDate == null) {
      return sales;
    }
    return sales.where((sale) {
      final saleDate = sale.createdAt;
      return saleDate.isAfter(_startDate!) &&
          saleDate.isBefore(_endDate!.add(const Duration(days: 1)));
    }).toList();
  }

  List<SaleItem> _filterSaleItemsBySales(
    List<SaleItem> saleItems,
    List<Sale> filteredSales,
  ) {
    final filteredSaleIds = filteredSales.map((s) => s.id).toSet();
    return saleItems
        .where((item) => filteredSaleIds.contains(item.saleId))
        .toList();
  }

  List<Loss> _filterLossesByDate(List<Loss> losses) {
    if (_startDate == null || _endDate == null) {
      return losses;
    }
    return losses.where((loss) {
      final lossDate = loss.timestamp;
      return lossDate.isAfter(_startDate!) &&
          lossDate.isBefore(_endDate!.add(const Duration(days: 1)));
    }).toList();
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\report_tabs\components\inventory_report_tab.dart
â•‘ SIZE: 39.69 KB
â•‘ MODIFIED: 10/29/2025 19:23:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/providers/inventory_provider.dart';
import 'package:prostock/services/report_service.dart';
import 'package:prostock/utils/currency_utils.dart';
import 'package:prostock/widgets/inventory_chart.dart';
import 'package:prostock/widgets/report_helpers.dart';
import 'package:prostock/services/pdf_report_service.dart';
import 'package:prostock/models/product.dart';
import 'package:prostock/widgets/export_filter_dialog.dart';
import 'dart:io';

class InventoryReportTab extends StatelessWidget {
  const InventoryReportTab({super.key});

  @override
  Widget build(BuildContext context) {
    final reportService = ReportService();
    return Consumer<InventoryProvider>(
      builder: (context, provider, child) {
        final totalProducts = reportService.calculateTotalProducts(
          provider.products,
        );
        final lowStockCount = provider.lowStockProducts.length;
        final totalValue = reportService.calculateTotalInventoryValue(
          provider.products,
        );
        return FutureBuilder<Map<String, double>>(
          future: _calculateAllMetrics(provider.products),
          builder: (context, snapshot) {
            if (!snapshot.hasData) {
              return const Center(child: CircularProgressIndicator());
            }

            final metrics = snapshot.data!;
            final totalRetailValue = metrics['totalRetailValue']!;
            final potentialProfit = metrics['potentialProfit']!;

            // Calculate additional metrics
            final outOfStockCount = provider.products
                .where((p) => p.stock == 0)
                .length;
            final averageStockValue = totalProducts > 0
                ? totalValue / totalProducts
                : 0.0;

            // Calculate total stock quantity
            final totalStockQuantity = provider.products.fold(
              0,
              (sum, product) => sum + product.stock,
            );

            return SingleChildScrollView(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      ElevatedButton.icon(
                        icon: const Icon(Icons.picture_as_pdf),
                        label: const Text('Export PDF'),
                        onPressed: () async {
                          try {
                            // Show filter options
                            final exportOptions = ExportFilterOptions(
                              useDataRangeFilter: false,
                              startDate: null,
                              endDate: null,
                            );

                            // Show the filter dialog
                            final result =
                                await showDialog<ExportFilterOptions>(
                                  context: context,
                                  builder: (context) => ExportFilterDialog(
                                    initialOptions: exportOptions,
                                    onApply: (options) {
                                      Navigator.of(context).pop(options);
                                    },
                                  ),
                                );

                            // If user cancelled the dialog
                            if (result == null || !context.mounted) return;

                            final options = result;

                            // Capture context-dependent values before async gap
                            final scaffold = ScaffoldMessenger.of(context);

                            scaffold.showSnackBar(
                              const SnackBar(
                                content: Text('Generating PDF...'),
                                duration: Duration(seconds: 2),
                              ),
                            );

                            final pdf = PdfReportService();
                            final sections = <PdfReportSection>[
                              PdfReportSection(
                                title: 'Inventory Summary',
                                rows: [
                                  ['Total Products', totalProducts.toString()],
                                  ['Low Stock Items', lowStockCount.toString()],
                                  ['Out of Stock', outOfStockCount.toString()],
                                  [
                                    'Total Stock',
                                    totalStockQuantity.toString(),
                                  ],
                                  [
                                    'Cost Value',
                                    CurrencyUtils.formatCurrency(totalValue),
                                  ],
                                  [
                                    'Retail Value',
                                    CurrencyUtils.formatCurrency(
                                      totalRetailValue,
                                    ),
                                  ],
                                  [
                                    'Potential Profit',
                                    CurrencyUtils.formatCurrency(
                                      potentialProfit,
                                    ),
                                  ],
                                  [
                                    'Average Stock Value',
                                    CurrencyUtils.formatCurrency(
                                      averageStockValue,
                                    ),
                                  ],
                                ],
                              ),
                            ];

                            // Product Stock Breakdown (Product, Qty, Cost Value)
                            final productRows = <List<String>>[];
                            double productRowsTotalCost = 0.0;
                            int productRowsTotalQty = 0;
                            final sortedProducts = [...provider.products]
                              ..sort((a, b) => a.name.compareTo(b.name));
                            for (final p in sortedProducts) {
                              final qty = p.stock;
                              final costValue = p.cost * qty;
                              productRows.add([
                                p.name,
                                qty.toString(),
                                CurrencyUtils.formatCurrency(costValue),
                              ]);
                              productRowsTotalQty += qty;
                              productRowsTotalCost += costValue;
                            }
                            if (productRows.isNotEmpty) {
                              productRows.add([
                                'Total',
                                productRowsTotalQty.toString(),
                                CurrencyUtils.formatCurrency(
                                  productRowsTotalCost,
                                ),
                              ]);
                              sections.add(
                                PdfReportSection(
                                  title: 'Product Stock Breakdown',
                                  rows: productRows,
                                ),
                              );
                            }

                            // Inventory Distribution by Category (Category, Distribution %, Quantity)
                            final Map<String, int> qtyByCategory = {};
                            for (final p in provider.products) {
                              final cat = (p.category?.isNotEmpty == true)
                                  ? p.category!
                                  : 'Uncategorized';
                              qtyByCategory.update(
                                cat,
                                (v) => v + p.stock,
                                ifAbsent: () => p.stock,
                              );
                            }
                            final distributionRows = <List<String>>[];
                            int distTotalQty = 0;
                            final cats = qtyByCategory.keys.toList(
                              growable: false,
                            )..sort();
                            for (final c in cats) {
                              final q = qtyByCategory[c] ?? 0;
                              distTotalQty += q;
                            }
                            for (final c in cats) {
                              final q = qtyByCategory[c] ?? 0;
                              final percentage = distTotalQty > 0
                                  ? '${(q / distTotalQty * 100).toStringAsFixed(1)}%'
                                  : '0.0%';
                              distributionRows.add([
                                c,
                                percentage,
                                q.toString(),
                              ]);
                            }
                            if (distributionRows.isNotEmpty) {
                              distributionRows.add([
                                'Total',
                                '100.0%',
                                distTotalQty.toString(),
                              ]);
                              sections.add(
                                PdfReportSection(
                                  title: 'Inventory Distribution by Category',
                                  rows: distributionRows,
                                ),
                              );
                            }

                            // Low Stock Products (Product, Qty, Cost Value)
                            final lowRows = <List<String>>[];
                            int lowTotalQty = 0;
                            double lowTotalCost = 0.0;
                            final lowProducts = [...provider.lowStockProducts]
                              ..sort((a, b) => a.name.compareTo(b.name));
                            for (final p in lowProducts.where(
                              (p) => p.stock > 0,
                            )) {
                              final qty = p.stock;
                              final costValue = p.cost * qty;
                              lowRows.add([
                                p.name,
                                qty.toString(),
                                CurrencyUtils.formatCurrency(costValue),
                              ]);
                              lowTotalQty += qty;
                              lowTotalCost += costValue;
                            }
                            if (lowRows.isNotEmpty) {
                              lowRows.add([
                                'Total',
                                lowTotalQty.toString(),
                                CurrencyUtils.formatCurrency(lowTotalCost),
                              ]);
                              sections.add(
                                PdfReportSection(
                                  title: 'Low Stock Products',
                                  rows: lowRows,
                                ),
                              );
                            }

                            // Out of Stock Products (Product, Qty, Cost Value)
                            final outRows = <List<String>>[];
                            int outTotalQty =
                                0; // will be zero but keep for consistency
                            double outTotalCost = 0.0; // zero as qty is zero
                            final outProducts =
                                provider.products
                                    .where((p) => p.stock == 0)
                                    .toList()
                                  ..sort((a, b) => a.name.compareTo(b.name));
                            for (final p in outProducts) {
                              outRows.add([
                                p.name,
                                '0',
                                CurrencyUtils.formatCurrency(0),
                              ]);
                            }
                            if (outRows.isNotEmpty) {
                              outRows.add([
                                'Total',
                                outTotalQty.toString(),
                                CurrencyUtils.formatCurrency(outTotalCost),
                              ]);
                              sections.add(
                                PdfReportSection(
                                  title: 'Out of Stock Products',
                                  rows: outRows,
                                ),
                              );
                            }

                            // Apply filter options to limit data
                            List<PdfReportSection> filteredSections = sections;
                            if (options.limitItemCount || options.summaryOnly) {
                              filteredSections = pdf.applyDataLimits(
                                sections,
                                maxRowsPerSection: options.maxItemCount,
                                summaryOnly: options.summaryOnly,
                              );
                            }

                            try {
                              // Show progress dialog
                              showDialog(
                                context: context,
                                barrierDismissible: false,
                                builder: (context) => const AlertDialog(
                                  content: Column(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      CircularProgressIndicator(),
                                      SizedBox(height: 16),
                                      Text('Generating PDF...\nPlease wait.'),
                                    ],
                                  ),
                                ),
                              );

                              // Generate the PDF with filtered sections in background
                              final file = await pdf.generatePdfInBackground(
                                reportTitle:
                                    'Inventory Report - Sari-Sari Store',
                                startDate: null,
                                endDate: null,
                                sections: filteredSections,
                              );

                              // Close progress dialog
                              if (!context.mounted) return;
                              Navigator.of(context).pop();

                              if (!context.mounted) return;
                              scaffold.showSnackBar(
                                SnackBar(
                                  content: Text('PDF saved: ${file.path}'),
                                  backgroundColor: Colors.green,
                                  duration: const Duration(seconds: 4),
                                ),
                              );
                            } catch (e) {
                              // Close progress dialog if still showing
                              if (!context.mounted) return;
                              if (Navigator.canPop(context)) {
                                Navigator.of(context).pop();
                              }

                              // If we get TooManyPagesException, try paginated approach
                              if (e.toString().contains(
                                'TooManyPagesException',
                              )) {
                                scaffold.showSnackBar(
                                  const SnackBar(
                                    content: Text(
                                      'Document too large, splitting into multiple PDFs...',
                                    ),
                                    backgroundColor: Colors.orange,
                                    duration: Duration(seconds: 3),
                                  ),
                                );

                                // Show progress dialog for paginated generation
                                showDialog(
                                  context: context,
                                  barrierDismissible: false,
                                  builder: (context) => const AlertDialog(
                                    content: Column(
                                      mainAxisSize: MainAxisSize.min,
                                      children: [
                                        CircularProgressIndicator(),
                                        SizedBox(height: 16),
                                        Text(
                                          'Creating multiple PDF files...\nPlease wait.',
                                        ),
                                      ],
                                    ),
                                  ),
                                );

                                // Generate paginated PDFs in background
                                final files = await pdf
                                    .generatePaginatedPDFsInBackground(
                                      reportTitle:
                                          'Inventory Report - Sari-Sari Store',
                                      startDate: null,
                                      endDate: null,
                                      sections: filteredSections,
                                      sectionsPerPdf:
                                          3, // Fewer sections per PDF
                                    );

                                // Close progress dialog
                                if (!context.mounted) return;
                                Navigator.of(context).pop();

                                if (!context.mounted) return;

                                scaffold.showSnackBar(
                                  SnackBar(
                                    content: Text(
                                      'Generated ${files.length} PDF files in ${Directory(files.first.parent.path).path}',
                                    ),
                                    backgroundColor: Colors.green,
                                    duration: const Duration(seconds: 4),
                                  ),
                                );
                              } else {
                                rethrow; // Re-throw to be caught by outer catch
                              }
                            }
                          } catch (e) {
                            if (context.mounted) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text('Error generating PDF: $e'),
                                  backgroundColor: Colors.red,
                                  duration: const Duration(seconds: 5),
                                ),
                              );
                            }
                          }
                        },
                      ),
                    ],
                  ),
                  const SizedBox(height: 12),
                  // Enhanced summary cards grid
                  GridView.count(
                    crossAxisCount: 2,
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    childAspectRatio: 1.3,
                    crossAxisSpacing: 12,
                    mainAxisSpacing: 12,
                    children: [
                      buildSummaryCard(
                        context,
                        'Total Products',
                        totalProducts.toString(),
                        Icons.inventory_2,
                        Colors.blue,
                      ),
                      buildSummaryCard(
                        context,
                        'Low Stock Items',
                        lowStockCount.toString(),
                        Icons.warning_amber,
                        Colors.orange,
                      ),
                      buildSummaryCard(
                        context,
                        'Out of Stock',
                        outOfStockCount.toString(),
                        Icons.remove_shopping_cart,
                        Colors.red,
                      ),
                      buildSummaryCard(
                        context,
                        'Total Stock',
                        totalStockQuantity.toString(),
                        Icons.warehouse,
                        Colors.purple,
                      ),
                    ],
                  ),

                  const SizedBox(height: 16),

                  // Inventory value cards
                  Row(
                    children: [
                      Expanded(
                        child: buildSummaryCard(
                          context,
                          'Cost Value',
                          CurrencyUtils.formatCurrency(totalValue),
                          Icons.account_balance_wallet,
                          Colors.green,
                        ),
                      ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: buildSummaryCard(
                          context,
                          'Retail Value',
                          CurrencyUtils.formatCurrency(totalRetailValue),
                          Icons.storefront,
                          Colors.teal,
                        ),
                      ),
                    ],
                  ),

                  const SizedBox(height: 16),

                  buildSummaryCard(
                    context,
                    'Potential Profit',
                    CurrencyUtils.formatCurrency(potentialProfit),
                    Icons.trending_up,
                    Colors.indigo,
                  ),

                  const SizedBox(height: 24),

                  // Inventory Analysis
                  Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(16),
                    decoration: BoxDecoration(
                      color: Theme.of(
                        context,
                      ).colorScheme.surfaceContainerHighest,
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Inventory Analysis',
                          style: Theme.of(context).textTheme.titleMedium
                              ?.copyWith(fontWeight: FontWeight.bold),
                        ),
                        const SizedBox(height: 12),
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Flexible(
                              child: Text(
                                'Average Stock Value:',
                                style: Theme.of(context).textTheme.bodyMedium,
                              ),
                            ),
                            Flexible(
                              child: Text(
                                CurrencyUtils.formatCurrency(averageStockValue),
                                style: Theme.of(context).textTheme.bodyMedium
                                    ?.copyWith(fontWeight: FontWeight.bold),
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 4),
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Flexible(
                              child: Text(
                                'Stock Health:',
                                style: Theme.of(context).textTheme.bodyMedium,
                              ),
                            ),
                            Flexible(
                              child: Text(
                                _getStockHealth(
                                  totalProducts,
                                  lowStockCount,
                                  outOfStockCount,
                                ),
                                style: Theme.of(context).textTheme.bodyMedium
                                    ?.copyWith(
                                      fontWeight: FontWeight.bold,
                                      color: _getStockHealthColor(
                                        totalProducts,
                                        lowStockCount,
                                        outOfStockCount,
                                        context,
                                      ),
                                    ),
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 4),
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Flexible(
                              child: Text(
                                'Markup Potential:',
                                style: Theme.of(context).textTheme.bodyMedium,
                              ),
                            ),
                            Flexible(
                              child: Text(
                                '${totalValue > 0 ? ((potentialProfit / totalValue) * 100).toStringAsFixed(1) : 0.0}%',
                                style: Theme.of(context).textTheme.bodyMedium
                                    ?.copyWith(
                                      fontWeight: FontWeight.bold,
                                      color: Theme.of(
                                        context,
                                      ).colorScheme.primary,
                                    ),
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),

                  const SizedBox(height: 24),
                  const Text(
                    'Inventory Distribution',
                    style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 16),
                  const InventoryChart(),

                  const SizedBox(height: 24),

                  if (provider.lowStockProducts.isNotEmpty) ...[
                    Row(
                      children: [
                        Icon(
                          Icons.warning_amber,
                          color: Theme.of(context).colorScheme.tertiary,
                          size: 24,
                        ),
                        const SizedBox(width: 8),
                        Text(
                          'Low Stock Alert',
                          style: Theme.of(context).textTheme.titleLarge
                              ?.copyWith(fontWeight: FontWeight.bold),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    FutureBuilder<Map<String, double>>(
                      future: reportService.calculateBatchSellingPrices(
                        provider.lowStockProducts,
                      ),
                      builder: (context, priceSnapshot) {
                        if (!priceSnapshot.hasData) {
                          return const Center(
                            child: CircularProgressIndicator(),
                          );
                        }

                        final lowStockPrices = priceSnapshot.data!;

                        return ListView.builder(
                          shrinkWrap: true,
                          physics: const NeverScrollableScrollPhysics(),
                          itemCount: provider.lowStockProducts.length,
                          itemBuilder: (context, index) {
                            final product = provider.lowStockProducts[index];
                            final isOutOfStock = product.stock == 0;
                            final colorScheme = Theme.of(context).colorScheme;
                            final textTheme = Theme.of(context).textTheme;

                            return Card(
                              elevation: 1,
                              margin: const EdgeInsets.only(bottom: 8),
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(12),
                              ),
                              child: Padding(
                                padding: const EdgeInsets.all(12),
                                child: Row(
                                  children: [
                                    // Icon
                                    Container(
                                      width: 48,
                                      height: 48,
                                      decoration: BoxDecoration(
                                        color: isOutOfStock
                                            ? colorScheme.errorContainer
                                            : colorScheme.tertiaryContainer,
                                        borderRadius: BorderRadius.circular(24),
                                      ),
                                      child: Icon(
                                        isOutOfStock
                                            ? Icons.remove_shopping_cart
                                            : Icons.warning_amber,
                                        color: isOutOfStock
                                            ? colorScheme.onErrorContainer
                                            : colorScheme.onTertiaryContainer,
                                        size: 24,
                                      ),
                                    ),
                                    const SizedBox(width: 12),

                                    // Content
                                    Expanded(
                                      child: Column(
                                        crossAxisAlignment:
                                            CrossAxisAlignment.start,
                                        children: [
                                          Text(
                                            product.name,
                                            style: textTheme.titleMedium
                                                ?.copyWith(
                                                  fontWeight: FontWeight.w600,
                                                ),
                                          ),
                                          const SizedBox(height: 4),
                                          Text(
                                            'Current Stock: ${product.stock}',
                                            style: textTheme.bodySmall
                                                ?.copyWith(
                                                  color: isOutOfStock
                                                      ? colorScheme.error
                                                      : colorScheme.tertiary,
                                                  fontWeight: FontWeight.w500,
                                                ),
                                          ),
                                          Text(
                                            'Min Required: ${product.minStock}',
                                            style: textTheme.bodySmall
                                                ?.copyWith(
                                                  color: colorScheme
                                                      .onSurfaceVariant,
                                                ),
                                          ),
                                        ],
                                      ),
                                    ),

                                    // Badge and price
                                    Column(
                                      mainAxisAlignment:
                                          MainAxisAlignment.center,
                                      crossAxisAlignment:
                                          CrossAxisAlignment.end,
                                      children: [
                                        Container(
                                          padding: const EdgeInsets.symmetric(
                                            horizontal: 8,
                                            vertical: 4,
                                          ),
                                          decoration: BoxDecoration(
                                            color: isOutOfStock
                                                ? colorScheme.errorContainer
                                                : colorScheme.tertiaryContainer,
                                            borderRadius: BorderRadius.circular(
                                              12,
                                            ),
                                            border: Border.all(
                                              color: isOutOfStock
                                                  ? colorScheme.error
                                                  : colorScheme.tertiary,
                                            ),
                                          ),
                                          child: Text(
                                            isOutOfStock ? 'OUT' : 'LOW',
                                            style: textTheme.labelSmall
                                                ?.copyWith(
                                                  fontWeight: FontWeight.bold,
                                                  color: isOutOfStock
                                                      ? colorScheme
                                                            .onErrorContainer
                                                      : colorScheme
                                                            .onTertiaryContainer,
                                                ),
                                          ),
                                        ),
                                        const SizedBox(height: 4),
                                        Text(
                                          CurrencyUtils.formatCurrency(
                                            lowStockPrices[product.id] ?? 0.0,
                                          ),
                                          style: textTheme.labelSmall?.copyWith(
                                            color: colorScheme.outline,
                                          ),
                                        ),
                                      ],
                                    ),
                                  ],
                                ),
                              ),
                            );
                          },
                        );
                      },
                    ),
                  ] else ...[
                    Center(
                      child: Column(
                        children: [
                          Icon(
                            Icons.check_circle_outline,
                            size: 64,
                            color: Theme.of(context).colorScheme.primary,
                          ),
                          const SizedBox(height: 16),
                          Text(
                            'All Stock Levels Good',
                            style: Theme.of(context).textTheme.titleMedium
                                ?.copyWith(
                                  fontWeight: FontWeight.w600,
                                  color: Theme.of(context).colorScheme.primary,
                                ),
                          ),
                          const SizedBox(height: 8),
                          Text(
                            'No low stock alerts at this time',
                            style: Theme.of(context).textTheme.bodySmall
                                ?.copyWith(
                                  color: Theme.of(
                                    context,
                                  ).colorScheme.onSurfaceVariant,
                                ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ],
              ),
            );
          },
        );
      },
    );
  }

  /// Calculate all metrics in a single batch operation
  Future<Map<String, double>> _calculateAllMetrics(
    List<Product> products,
  ) async {
    final reportService = ReportService();
    final prices = await reportService.calculateBatchSellingPrices(products);

    double totalRetailValue = 0.0;
    double potentialProfit = 0.0;

    for (final product in products) {
      if (product.id != null) {
        final price = prices[product.id!] ?? 0.0;
        totalRetailValue += price * product.stock;
        potentialProfit += (price - product.cost) * product.stock;
      }
    }

    return {
      'totalRetailValue': totalRetailValue,
      'potentialProfit': potentialProfit,
    };
  }

  String _getStockHealth(int total, int lowStock, int outOfStock) {
    if (total == 0) return 'No Products';

    final healthyPercentage = ((total - lowStock - outOfStock) / total) * 100;

    if (healthyPercentage >= 80) return 'Excellent';
    if (healthyPercentage >= 60) return 'Good';
    if (healthyPercentage >= 40) return 'Fair';
    return 'Needs Attention';
  }

  Color _getStockHealthColor(
    int total,
    int lowStock,
    int outOfStock,
    BuildContext context,
  ) {
    final colorScheme = Theme.of(context).colorScheme;

    if (total == 0) return colorScheme.outline;

    final healthyPercentage = ((total - lowStock - outOfStock) / total) * 100;

    if (healthyPercentage >= 80) return colorScheme.primary;
    if (healthyPercentage >= 60) return colorScheme.secondary;
    if (healthyPercentage >= 40) return colorScheme.tertiary;
    return colorScheme.error;
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\report_tabs\components\report_tabs.dart
â•‘ SIZE: 0.26 KB
â•‘ MODIFIED: 10/04/2025 01:04:02
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';

class ReportTabs {
  static const List<Widget> tabs = [
    Tab(text: 'Sales'),
    Tab(text: 'Inventory'),
    Tab(text: 'Customers'),
    Tab(text: 'Financial'),
    Tab(text: 'Analytics'),
    Tab(text: 'Stock Log'),
  ];
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\report_tabs\components\sales_report_tab.dart
â•‘ SIZE: 36.61 KB
â•‘ MODIFIED: 10/29/2025 19:23:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/providers/sales_provider.dart';
import 'package:prostock/services/report_service.dart';
import 'package:prostock/providers/inventory_provider.dart';
import 'package:prostock/utils/currency_utils.dart';
import 'package:prostock/widgets/report_helpers.dart';
import 'package:prostock/services/pdf_report_service.dart';
import 'package:prostock/widgets/export_filter_dialog.dart';
import 'dart:io';

class SalesReportTab extends StatelessWidget {
  const SalesReportTab({super.key});

  @override
  Widget build(BuildContext context) {
    final reportService = ReportService();

    return Consumer<SalesProvider>(
      builder: (context, provider, child) {
        final totalSales = reportService.calculateTotalSales(provider.sales);
        final todaySales = reportService.calculateTodaySales(provider.sales);
        final averageOrderValue = reportService.calculateAverageOrderValue(
          provider.sales,
        );
        final totalTransactions = provider.sales.length;

        // Calculate weekly sales (normalize to start of day, inclusive start)
        final nowTs = DateTime.now();
        final todayStart = DateTime(nowTs.year, nowTs.month, nowTs.day);
        final weekStartDate = todayStart.subtract(
          Duration(days: todayStart.weekday - 1), // Monday 00:00
        );
        final weekEndDateExclusive = weekStartDate.add(
          const Duration(days: 7),
        ); // next Monday 00:00
        final weeklySales = provider.sales
            .where((sale) {
              final ts = sale.createdAt;
              return (ts.isAtSameMomentAs(weekStartDate) ||
                      ts.isAfter(weekStartDate)) &&
                  ts.isBefore(weekEndDateExclusive);
            })
            .fold(0.0, (sum, sale) => sum + sale.totalAmount);

        // Calculate monthly sales
        final now = DateTime.now();
        final monthStartDate = DateTime(now.year, now.month, 1);
        final monthEndDate = DateTime(now.year, now.month + 1, 0);
        final monthlySales = provider.sales
            .where((sale) {
              return sale.createdAt.isAfter(monthStartDate) &&
                  sale.createdAt.isBefore(
                    monthEndDate.add(const Duration(days: 1)),
                  );
            })
            .fold(0.0, (sum, sale) => sum + sale.totalAmount);

        return SingleChildScrollView(
          physics: const AlwaysScrollableScrollPhysics(),
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  ElevatedButton.icon(
                    icon: const Icon(Icons.picture_as_pdf),
                    label: const Text('Export PDF'),
                    onPressed: () async {
                      try {
                        // Show filter options
                        final exportOptions = ExportFilterOptions(
                          useDataRangeFilter: false,
                          startDate: null,
                          endDate: null,
                        );

                        // Show the filter dialog
                        final result = await showDialog<ExportFilterOptions>(
                          context: context,
                          builder: (context) => ExportFilterDialog(
                            initialOptions: exportOptions,
                            onApply: (options) {
                              Navigator.of(context).pop(options);
                            },
                          ),
                        );

                        // If user cancelled the dialog
                        if (result == null || !context.mounted) return;

                        final options = result;
                        final scaffold = ScaffoldMessenger.of(context);

                        // Show loading indicator
                        scaffold.showSnackBar(
                          const SnackBar(
                            content: Text('Generating PDF...'),
                            duration: Duration(seconds: 2),
                          ),
                        );

                        final pdf = PdfReportService();

                        // Build breakdowns per period with product name and quantity
                        final inventory = context.read<InventoryProvider>();
                        final productById = {
                          for (final p in inventory.products) p.id: p,
                        };

                        List<PdfReportSection> buildBreakdownSections() {
                          // Helper to group sale items by product and unit price for a set of saleIds
                          List<List<String>> buildRowsForSaleIds(
                            Set<String> saleIds,
                          ) {
                            // Group by product and unit price to track price changes
                            final Map<String, Map<double, double>>
                            qtyByProductPrice = {};
                            final Map<String, Map<double, double>>
                            revenueByProductPrice = {};

                            for (final item in provider.saleItems) {
                              if (saleIds.contains(item.saleId)) {
                                // Round unit price to 2 decimals to avoid floating noise
                                final roundedUnitPrice =
                                    (item.unitPrice * 100).round() / 100.0;

                                qtyByProductPrice[item.productId] ??= {};
                                qtyByProductPrice[item
                                        .productId]![roundedUnitPrice] =
                                    (qtyByProductPrice[item
                                            .productId]![roundedUnitPrice] ??
                                        0) +
                                    item.quantity;

                                revenueByProductPrice[item.productId] ??= {};
                                revenueByProductPrice[item
                                        .productId]![roundedUnitPrice] =
                                    (revenueByProductPrice[item
                                            .productId]![roundedUnitPrice] ??
                                        0) +
                                    item.totalPrice;
                              }
                            }

                            final rows = <List<String>>[];
                            double totalQty = 0;
                            double totalAmt = 0;

                            // Sort products by name
                            final productIds =
                                qtyByProductPrice.keys.toList(growable: false)
                                  ..sort(
                                    (a, b) => (productById[a]?.name ?? a)
                                        .compareTo(productById[b]?.name ?? b),
                                  );

                            for (final productId in productIds) {
                              final name =
                                  productById[productId]?.name ??
                                  'Unknown Product';
                              final priceMap =
                                  qtyByProductPrice[productId] ?? {};
                              final pricesSorted = priceMap.keys.toList(
                                growable: false,
                              )..sort();

                              for (final price in pricesSorted) {
                                final qty = priceMap[price] ?? 0;
                                final revenue =
                                    (revenueByProductPrice[productId] ??
                                        {})[price] ??
                                    0.0;

                                rows.add([
                                  name,
                                  qty.toStringAsFixed(0),
                                  CurrencyUtils.formatCurrency(price),
                                  CurrencyUtils.formatCurrency(revenue),
                                ]);
                                totalQty += qty;
                                totalAmt += revenue;
                              }
                            }

                            if (rows.isNotEmpty) {
                              rows.add([
                                'Total',
                                totalQty.toStringAsFixed(0),
                                '-',
                                CurrencyUtils.formatCurrency(totalAmt),
                              ]);
                            }
                            return rows;
                          }

                          // Helper to get saleIds for a period
                          Set<String> saleIdsWhere(
                            bool Function(DateTime ts) predicate,
                          ) {
                            return provider.sales
                                .where((s) => predicate(s.createdAt))
                                .map((s) => s.id)
                                .whereType<String>()
                                .toSet();
                          }

                          final now = DateTime.now();
                          final todayStart = DateTime(
                            now.year,
                            now.month,
                            now.day,
                          );
                          final tomorrowStart = todayStart.add(
                            const Duration(days: 1),
                          );

                          final weekStart = todayStart.subtract(
                            Duration(days: todayStart.weekday - 1),
                          );
                          final nextWeekStart = weekStart.add(
                            const Duration(days: 7),
                          );

                          final monthStart = DateTime(now.year, now.month, 1);
                          final nextMonthStart = DateTime(
                            now.year,
                            now.month + 1,
                            1,
                          );

                          final todaySaleIds = saleIdsWhere(
                            (ts) =>
                                (ts.isAtSameMomentAs(todayStart) ||
                                    ts.isAfter(todayStart)) &&
                                ts.isBefore(tomorrowStart),
                          );
                          final weekSaleIds = saleIdsWhere(
                            (ts) =>
                                (ts.isAtSameMomentAs(weekStart) ||
                                    ts.isAfter(weekStart)) &&
                                ts.isBefore(nextWeekStart),
                          );
                          final monthSaleIds = saleIdsWhere(
                            (ts) =>
                                (ts.isAtSameMomentAs(monthStart) ||
                                    ts.isAfter(monthStart)) &&
                                ts.isBefore(nextMonthStart),
                          );
                          final totalSaleIds = provider.sales
                              .map((s) => s.id)
                              .whereType<String>()
                              .toSet();

                          final sections = <PdfReportSection>[
                            PdfReportSection(
                              title: 'Sales Summary',
                              rows: [
                                [
                                  "Today's Sales",
                                  CurrencyUtils.formatCurrency(todaySales),
                                ],
                                [
                                  'Weekly Sales',
                                  CurrencyUtils.formatCurrency(weeklySales),
                                ],
                                [
                                  'Monthly Sales',
                                  CurrencyUtils.formatCurrency(monthlySales),
                                ],
                                [
                                  'Total Sales',
                                  CurrencyUtils.formatCurrency(totalSales),
                                ],
                                [
                                  'Total Transactions',
                                  totalTransactions.toString(),
                                ],
                                [
                                  'Average Order Value',
                                  CurrencyUtils.formatCurrency(
                                    averageOrderValue,
                                  ),
                                ],
                              ],
                            ),
                          ];

                          final todayRows = buildRowsForSaleIds(todaySaleIds);
                          if (todayRows.isNotEmpty) {
                            sections.add(
                              PdfReportSection(
                                title: "Today's Sales Breakdown",
                                rows: todayRows,
                              ),
                            );
                          }

                          final weekRows = buildRowsForSaleIds(weekSaleIds);
                          if (weekRows.isNotEmpty) {
                            sections.add(
                              PdfReportSection(
                                title: 'Weekly Sales Breakdown',
                                rows: weekRows,
                              ),
                            );
                          }

                          final monthRows = buildRowsForSaleIds(monthSaleIds);
                          if (monthRows.isNotEmpty) {
                            sections.add(
                              PdfReportSection(
                                title: 'Monthly Sales Breakdown',
                                rows: monthRows,
                              ),
                            );
                          }

                          final totalRows = buildRowsForSaleIds(totalSaleIds);
                          if (totalRows.isNotEmpty) {
                            sections.add(
                              PdfReportSection(
                                title: 'Total Sales Breakdown',
                                rows: totalRows,
                              ),
                            );
                          }

                          return sections;
                        }

                        final sections = buildBreakdownSections();

                        // Apply filter options to limit data
                        List<PdfReportSection> filteredSections = sections;
                        if (options.limitItemCount || options.summaryOnly) {
                          filteredSections = pdf.applyDataLimits(
                            sections,
                            maxRowsPerSection: options.maxItemCount,
                            summaryOnly: options.summaryOnly,
                          );
                        }

                        try {
                          // Show progress dialog
                          showDialog(
                            context: context,
                            barrierDismissible: false,
                            builder: (context) => const AlertDialog(
                              content: Column(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  CircularProgressIndicator(),
                                  SizedBox(height: 16),
                                  Text('Generating PDF...\nPlease wait.'),
                                ],
                              ),
                            ),
                          );

                          // Generate the PDF with filtered sections in background
                          final file = await pdf.generatePdfInBackground(
                            reportTitle: 'Sales Report - Sari-Sari Store',
                            startDate: options.useDataRangeFilter
                                ? options.startDate
                                : null,
                            endDate: options.useDataRangeFilter
                                ? options.endDate
                                : null,
                            sections: filteredSections,
                          );

                          // Close progress dialog
                          if (!context.mounted) return;
                          Navigator.of(context).pop();

                          if (!context.mounted) return;
                          scaffold.showSnackBar(
                            SnackBar(
                              content: Text('PDF saved: ${file.path}'),
                              backgroundColor: Colors.green,
                              duration: const Duration(seconds: 4),
                            ),
                          );
                        } catch (e) {
                          // Close progress dialog if still showing
                          if (!context.mounted) return;
                          if (Navigator.canPop(context)) {
                            Navigator.of(context).pop();
                          }

                          // If we get TooManyPagesException, try paginated approach
                          if (e.toString().contains('TooManyPagesException')) {
                            scaffold.showSnackBar(
                              const SnackBar(
                                content: Text(
                                  'Document too large, splitting into multiple PDFs...',
                                ),
                                backgroundColor: Colors.orange,
                                duration: Duration(seconds: 3),
                              ),
                            );

                            // Show progress dialog for paginated generation
                            showDialog(
                              context: context,
                              barrierDismissible: false,
                              builder: (context) => const AlertDialog(
                                content: Column(
                                  mainAxisSize: MainAxisSize.min,
                                  children: [
                                    CircularProgressIndicator(),
                                    SizedBox(height: 16),
                                    Text(
                                      'Creating multiple PDF files...\nPlease wait.',
                                    ),
                                  ],
                                ),
                              ),
                            );

                            // Generate paginated PDFs in background
                            final files = await pdf
                                .generatePaginatedPDFsInBackground(
                                  reportTitle: 'Sales Report - Sari-Sari Store',
                                  startDate: options.useDataRangeFilter
                                      ? options.startDate
                                      : null,
                                  endDate: options.useDataRangeFilter
                                      ? options.endDate
                                      : null,
                                  sections: filteredSections,
                                  sectionsPerPdf: 3, // Fewer sections per PDF
                                );

                            // Close progress dialog
                            if (!context.mounted) return;
                            Navigator.of(context).pop();

                            if (!context.mounted) return;

                            scaffold.showSnackBar(
                              SnackBar(
                                content: Text(
                                  'Generated ${files.length} PDF files in ${Directory(files.first.parent.path).path}',
                                ),
                                backgroundColor: Colors.green,
                                duration: const Duration(seconds: 4),
                              ),
                            );
                          } else {
                            rethrow; // Re-throw to be caught by outer catch
                          }
                        }
                      } catch (e) {
                        if (context.mounted) {
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                              content: Text('Error generating PDF: $e'),
                              backgroundColor: Colors.red,
                              duration: const Duration(seconds: 5),
                            ),
                          );
                        }
                      }
                    },
                  ),
                ],
              ),
              const SizedBox(height: 12),
              // Enhanced summary cards grid
              GridView.count(
                crossAxisCount: 2,
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                childAspectRatio: 1.3,
                crossAxisSpacing: 12,
                mainAxisSpacing: 12,
                children: [
                  buildSummaryCard(
                    context,
                    'Today\'s Sales',
                    CurrencyUtils.formatCurrency(todaySales),
                    Icons.today,
                    Colors.green,
                  ),
                  buildSummaryCard(
                    context,
                    'Weekly Sales',
                    CurrencyUtils.formatCurrency(weeklySales),
                    Icons.calendar_view_week,
                    Colors.blue,
                  ),
                  buildSummaryCard(
                    context,
                    'Monthly Sales',
                    CurrencyUtils.formatCurrency(monthlySales),
                    Icons.calendar_month,
                    Colors.orange,
                  ),
                  buildSummaryCard(
                    context,
                    'Total Sales',
                    CurrencyUtils.formatCurrency(totalSales),
                    Icons.receipt_long,
                    Colors.purple,
                  ),
                ],
              ),
              const SizedBox(height: 24),

              // Additional metrics row
              Row(
                children: [
                  Expanded(
                    child: buildSummaryCard(
                      context,
                      'Total Transactions',
                      totalTransactions.toString(),
                      Icons.shopping_bag,
                      Colors.indigo,
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: buildSummaryCard(
                      context,
                      'Avg Order Value',
                      CurrencyUtils.formatCurrency(averageOrderValue),
                      Icons.trending_up,
                      Colors.teal,
                    ),
                  ),
                ],
              ),

              const SizedBox(height: 24),

              // Sales Performance Analysis
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.surfaceContainerHighest,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Sales Performance',
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 12),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Flexible(
                          child: Text(
                            'Daily Average:',
                            style: Theme.of(context).textTheme.bodyMedium,
                          ),
                        ),
                        Flexible(
                          child: Text(
                            CurrencyUtils.formatCurrency(
                              totalSales /
                                  (provider.sales.isEmpty
                                      ? 1
                                      : _getUniqueDaysCount(provider.sales)),
                            ),
                            style: Theme.of(context).textTheme.bodyMedium
                                ?.copyWith(fontWeight: FontWeight.bold),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Flexible(
                          child: Text(
                            'Transactions Today:',
                            style: Theme.of(context).textTheme.bodyMedium,
                          ),
                        ),
                        Flexible(
                          child: Text(
                            _getTodayTransactionCount(
                              provider.sales,
                            ).toString(),
                            style: Theme.of(context).textTheme.bodyMedium
                                ?.copyWith(fontWeight: FontWeight.bold),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Flexible(
                          child: Text(
                            'Sales Growth:',
                            style: Theme.of(context).textTheme.bodyMedium,
                          ),
                        ),
                        Flexible(
                          child: Text(
                            '${_calculateGrowthPercentage(provider.sales).toStringAsFixed(1)}%',
                            style: Theme.of(context).textTheme.bodyMedium
                                ?.copyWith(
                                  fontWeight: FontWeight.bold,
                                  color:
                                      _calculateGrowthPercentage(
                                            provider.sales,
                                          ) >=
                                          0
                                      ? Theme.of(context).colorScheme.primary
                                      : Theme.of(context).colorScheme.error,
                                ),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),

              const SizedBox(height: 24),
              const Text(
                'Recent Sales',
                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 16),
              if (provider.sales.isEmpty)
                Center(
                  child: Column(
                    children: [
                      Icon(
                        Icons.receipt_outlined,
                        size: 64,
                        color: Theme.of(context).colorScheme.outline,
                      ),
                      const SizedBox(height: 16),
                      Text(
                        'No sales recorded yet',
                        style: Theme.of(context).textTheme.titleMedium
                            ?.copyWith(
                              color: Theme.of(
                                context,
                              ).colorScheme.onSurfaceVariant,
                            ),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        'Start making sales to see them here',
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          color: Theme.of(context).colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ],
                  ),
                )
              else
                ListView.builder(
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  itemCount: provider.sales.take(10).length,
                  itemBuilder: (context, index) {
                    final sale = provider.sales[index];
                    final colorScheme = Theme.of(context).colorScheme;
                    final textTheme = Theme.of(context).textTheme;

                    return Card(
                      elevation: 1,
                      margin: const EdgeInsets.only(bottom: 8),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: InkWell(
                        onTap: () => showHistoricalReceipt(context, sale),
                        borderRadius: BorderRadius.circular(12),
                        child: Padding(
                          padding: const EdgeInsets.all(12),
                          child: Row(
                            children: [
                              // Icon
                              Container(
                                width: 48,
                                height: 48,
                                decoration: BoxDecoration(
                                  color: colorScheme.primaryContainer,
                                  borderRadius: BorderRadius.circular(24),
                                ),
                                child: Icon(
                                  Icons.receipt,
                                  color: colorScheme.onPrimaryContainer,
                                  size: 24,
                                ),
                              ),
                              const SizedBox(width: 12),

                              // Content
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      'Sale #${sale.id}',
                                      style: textTheme.titleMedium?.copyWith(
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                    const SizedBox(height: 4),
                                    Text(
                                      _formatDate(sale.createdAt),
                                      style: textTheme.bodySmall?.copyWith(
                                        color: colorScheme.onSurfaceVariant,
                                      ),
                                    ),
                                    Text(
                                      'Payment: ${sale.paymentMethod}',
                                      style: textTheme.labelSmall?.copyWith(
                                        color: colorScheme.outline,
                                      ),
                                    ),
                                  ],
                                ),
                              ),

                              // Amount and time
                              Column(
                                mainAxisAlignment: MainAxisAlignment.center,
                                crossAxisAlignment: CrossAxisAlignment.end,
                                children: [
                                  Text(
                                    CurrencyUtils.formatCurrency(
                                      sale.totalAmount,
                                    ),
                                    style: textTheme.titleMedium?.copyWith(
                                      fontWeight: FontWeight.bold,
                                      color: colorScheme.primary,
                                    ),
                                  ),
                                  const SizedBox(height: 4),
                                  Text(
                                    _getTimeAgo(sale.createdAt),
                                    style: textTheme.labelSmall?.copyWith(
                                      color: colorScheme.outline,
                                    ),
                                  ),
                                ],
                              ),
                            ],
                          ),
                        ),
                      ),
                    );
                  },
                ),
            ],
          ),
        );
      },
    );
  }

  int _getUniqueDaysCount(List<dynamic> sales) {
    if (sales.isEmpty) return 1;
    final uniqueDates = <String>{};
    for (final sale in sales) {
      final dateStr =
          '${sale.createdAt.year}-${sale.createdAt.month}-${sale.createdAt.day}';
      uniqueDates.add(dateStr);
    }
    return uniqueDates.length;
  }

  int _getTodayTransactionCount(List<dynamic> sales) {
    final today = DateTime.now();
    return sales
        .where(
          (sale) =>
              sale.createdAt.day == today.day &&
              sale.createdAt.month == today.month &&
              sale.createdAt.year == today.year,
        )
        .length;
  }

  double _calculateGrowthPercentage(List<dynamic> sales) {
    if (sales.length < 2) return 0.0;

    final now = DateTime.now();
    final yesterday = now.subtract(const Duration(days: 1));

    final todaySales = sales
        .where(
          (sale) =>
              sale.createdAt.day == now.day &&
              sale.createdAt.month == now.month &&
              sale.createdAt.year == now.year,
        )
        .fold(0.0, (sum, sale) => sum + sale.totalAmount);

    final yesterdaySales = sales
        .where(
          (sale) =>
              sale.createdAt.day == yesterday.day &&
              sale.createdAt.month == yesterday.month &&
              sale.createdAt.year == yesterday.year,
        )
        .fold(0.0, (sum, sale) => sum + sale.totalAmount);

    if (yesterdaySales == 0) return todaySales > 0 ? 100.0 : 0.0;

    return ((todaySales - yesterdaySales) / yesterdaySales) * 100;
  }

  String _formatDate(DateTime date) {
    final now = DateTime.now();
    final difference = now.difference(date).inDays;

    if (difference == 0) {
      return 'Today ${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
    } else if (difference == 1) {
      return 'Yesterday ${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
    } else {
      return '${date.day}/${date.month}/${date.year}';
    }
  }

  String _getTimeAgo(DateTime date) {
    final now = DateTime.now();
    final difference = now.difference(date);

    if (difference.inMinutes < 60) {
      return '${difference.inMinutes}m ago';
    } else if (difference.inHours < 24) {
      return '${difference.inHours}h ago';
    } else {
      return '${difference.inDays}d ago';
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\report_tabs\components\staff_report_tab.dart
â•‘ SIZE: 10.16 KB
â•‘ MODIFIED: 10/26/2025 12:52:58
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/providers/auth_provider.dart';
import 'package:prostock/services/firestore/activity_service.dart';
import 'package:prostock/models/user_activity.dart';
import 'package:prostock/services/pdf_report_service.dart';
import 'package:prostock/widgets/export_filter_dialog.dart';
import 'dart:io';

class StaffReportTab extends StatefulWidget {
  const StaffReportTab({super.key});

  @override
  State<StaffReportTab> createState() => _StaffReportTabState();
}

class _StaffReportTabState extends State<StaffReportTab> {
  late Stream<List<UserActivity>> _activityStream;

  @override
  void initState() {
    super.initState();
    _activityStream = context.read<ActivityService>().getActivitiesStream();
  }

  @override
  Widget build(BuildContext context) {
    final auth = context.watch<AuthProvider>();
    return Column(
      children: [
        Align(
          alignment: Alignment.centerRight,
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: ElevatedButton.icon(
              icon: const Icon(Icons.picture_as_pdf),
              label: const Text('Export PDF'),
              onPressed: () async {
                try {
                  // Show filter options
                  final exportOptions = ExportFilterOptions(
                    useDataRangeFilter: false,
                    startDate: null,
                    endDate: null,
                  );

                  // Show the filter dialog
                  final result = await showDialog<ExportFilterOptions>(
                    context: context,
                    builder: (context) => ExportFilterDialog(
                      initialOptions: exportOptions,
                      onApply: (options) {
                        Navigator.of(context).pop(options);
                      },
                    ),
                  );

                  // If user cancelled the dialog
                  if (result == null || !context.mounted) return;

                  final options = result;
                  final scaffold = ScaffoldMessenger.of(context);

                  // Show loading indicator
                  scaffold.showSnackBar(
                    const SnackBar(
                      content: Text('Generating PDF...'),
                      duration: Duration(seconds: 2),
                    ),
                  );

                  final activities = await _activityStream.first;

                  final actionsCount = <String, int>{};
                  for (final a in activities) {
                    actionsCount.update(
                      a.action,
                      (v) => v + 1,
                      ifAbsent: () => 1,
                    );
                  }

                  final sections = <PdfReportSection>[
                    PdfReportSection(
                      title: 'Staff Summary',
                      rows: [
                        ['Current User', auth.username ?? ''],
                        ['Total Activities', activities.length.toString()],
                      ],
                    ),
                    PdfReportSection(
                      title: 'Actions Breakdown',
                      rows: actionsCount.entries
                          .map((e) => [e.key, e.value.toString()])
                          .toList(),
                    ),
                  ];

                  final pdf = PdfReportService();

                  // Apply filter options to limit data
                  List<PdfReportSection> filteredSections = sections;
                  if (options.limitItemCount || options.summaryOnly) {
                    filteredSections = pdf.applyDataLimits(
                      sections,
                      maxRowsPerSection: options.maxItemCount,
                      summaryOnly: options.summaryOnly,
                    );
                  }

                  try {
                    // Show progress dialog
                    if (!context.mounted) return;
                    showDialog(
                      context: context,
                      barrierDismissible: false,
                      builder: (context) => const AlertDialog(
                        content: Column(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            CircularProgressIndicator(),
                            SizedBox(height: 16),
                            Text('Generating PDF...\nPlease wait.'),
                          ],
                        ),
                      ),
                    );

                    // Generate the PDF with filtered sections in background
                    final file = await pdf.generatePdfInBackground(
                      reportTitle: 'Staff Performance Report - Sari-Sari Store',
                      startDate: null,
                      endDate: null,
                      sections: filteredSections,
                    );

                    // Close progress dialog
                    if (!context.mounted) return;
                    Navigator.of(context).pop();

                    if (!context.mounted) return;
                    scaffold.showSnackBar(
                      SnackBar(
                        content: Text('PDF saved: ${file.path}'),
                        backgroundColor: Colors.green,
                        duration: const Duration(seconds: 4),
                      ),
                    );
                  } catch (e) {
                    // Close progress dialog if still showing
                    if (!context.mounted) return;
                    if (Navigator.canPop(context)) {
                      Navigator.of(context).pop();
                    }

                    // If we get TooManyPagesException, try paginated approach
                    if (e.toString().contains('TooManyPagesException')) {
                      scaffold.showSnackBar(
                        const SnackBar(
                          content: Text(
                            'Document too large, splitting into multiple PDFs...',
                          ),
                          backgroundColor: Colors.orange,
                          duration: Duration(seconds: 3),
                        ),
                      );

                      // Show progress dialog for paginated generation
                      if (!context.mounted) return;
                      showDialog(
                        context: context,
                        barrierDismissible: false,
                        builder: (context) => const AlertDialog(
                          content: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              CircularProgressIndicator(),
                              SizedBox(height: 16),
                              Text(
                                'Creating multiple PDF files...\nPlease wait.',
                              ),
                            ],
                          ),
                        ),
                      );

                      // Generate paginated PDFs in background
                      final files = await pdf.generatePaginatedPDFsInBackground(
                        reportTitle:
                            'Staff Performance Report - Sari-Sari Store',
                        startDate: null,
                        endDate: null,
                        sections: filteredSections,
                        sectionsPerPdf: 3, // Fewer sections per PDF
                      );

                      // Close progress dialog
                      if (!context.mounted) return;
                      Navigator.of(context).pop();

                      if (!context.mounted) return;

                      scaffold.showSnackBar(
                        SnackBar(
                          content: Text(
                            'Generated ${files.length} PDF files in ${Directory(files.first.parent.path).path}',
                          ),
                          backgroundColor: Colors.green,
                          duration: const Duration(seconds: 4),
                        ),
                      );
                    } else {
                      rethrow; // Re-throw to be caught by outer catch
                    }
                  }
                } catch (e) {
                  if (mounted && context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text('Error generating PDF: $e'),
                        backgroundColor: Colors.red,
                        duration: const Duration(seconds: 5),
                      ),
                    );
                  }
                }
              },
            ),
          ),
        ),
        Expanded(
          child: StreamBuilder<List<UserActivity>>(
            stream: _activityStream,
            builder: (context, snapshot) {
              if (!snapshot.hasData) {
                return const Center(child: CircularProgressIndicator());
              }
              final activities = snapshot.data!;
              if (activities.isEmpty) {
                return const Center(child: Text('No staff activity yet.'));
              }
              return ListView.builder(
                itemCount: activities.length,
                itemBuilder: (context, index) {
                  final a = activities[index];
                  return ListTile(
                    leading: const Icon(Icons.person_outline),
                    title: Text(a.action),
                    subtitle: Text(a.details ?? ''),
                    trailing: Text(
                      a.timestamp.toLocal().toString().split('.').first,
                      style: const TextStyle(fontSize: 12),
                    ),
                  );
                },
              );
            },
          ),
        ),
      ],
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\settings\settings_screen.dart
â•‘ SIZE: 5.41 KB
â•‘ MODIFIED: 10/04/2025 05:03:47
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/widgets/sync_failure_dialog.dart';
import 'package:prostock/providers/sync_failure_provider.dart';
import 'package:flutter/material.dart';
import 'package:prostock/providers/theme_provider.dart';
import 'package:prostock/screens/settings/components/about_screen.dart';
import 'package:prostock/screens/settings/components/user_management_screen.dart';
import 'package:provider/provider.dart';
import '../../providers/auth_provider.dart';
import 'components/change_password_screen.dart';
import 'components/printer_settings_screen.dart';
import 'components/tax_rules_screen.dart';

class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Settings')),
      body: ListView(
        children: [
          ListTile(
            leading: const Icon(Icons.palette_outlined),
            title: const Text('Appearance'),
            onTap: () {
              _showThemeDialog(context);
            },
          ),
          ListTile(
            leading: const Icon(Icons.lock_outline),
            title: const Text('Change Password'),
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => const ChangePasswordScreen(),
                ),
              );
            },
          ),
          ListTile(
            leading: const Icon(Icons.print_outlined),
            title: const Text('Printer Settings'),
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => const PrinterSettingsScreen(),
                ),
              );
            },
          ),
          ListTile(
            leading: const Icon(Icons.rule),
            title: const Text('Markup Rules'),
            subtitle: const Text('Category & product-specific markups'),
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(builder: (context) => const TaxRulesScreen()),
              );
            },
          ),
          ListTile(
            leading: const Icon(Icons.people_outline),
            title: const Text('User Management'),
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => const UserManagementScreen(),
                ),
              );
            },
          ),
          const Divider(),
          Consumer<SyncFailureProvider>(
            builder: (context, syncFailureProvider, child) {
              return ListTile(
                leading: Badge(
                  isLabelVisible: syncFailureProvider.failures.isNotEmpty,
                  label: Text(syncFailureProvider.failures.length.toString()),
                  child: const Icon(Icons.sync_problem_outlined),
                ),
                title: const Text('Sync Failures'),
                onTap: () {
                  showDialog(
                    context: context,
                    builder: (context) => const SyncFailureDialog(),
                  );
                },
              );
            },
          ),
          const Divider(),
          ListTile(
            leading: const Icon(Icons.info_outline),
            title: const Text('About'),
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(builder: (context) => const AboutScreen()),
              );
            },
          ),
          const Divider(),
          ListTile(
            leading: const Icon(Icons.logout),
            title: const Text('Logout'),
            onTap: () async {
              final authProvider = context.read<AuthProvider>();
              await authProvider.logout();
              if (context.mounted) {
                Navigator.of(
                  context,
                ).pushNamedAndRemoveUntil('/login', (route) => false);
              }
            },
          ),
        ],
      ),
    );
  }

  void _showThemeDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) {
        return SimpleDialog(
          title: const Text('Select Theme'),
          children: [
            SimpleDialogOption(
              onPressed: () {
                Provider.of<ThemeProvider>(
                  context,
                  listen: false,
                ).setThemeMode(ThemeMode.light);
                Navigator.of(context).pop();
              },
              child: const Text('Light'),
            ),
            SimpleDialogOption(
              onPressed: () {
                Provider.of<ThemeProvider>(
                  context,
                  listen: false,
                ).setThemeMode(ThemeMode.dark);
                Navigator.of(context).pop();
              },
              child: const Text('Dark'),
            ),
            SimpleDialogOption(
              onPressed: () {
                Provider.of<ThemeProvider>(
                  context,
                  listen: false,
                ).setThemeMode(ThemeMode.system);
                Navigator.of(context).pop();
              },
              child: const Text('System Default'),
            ),
          ],
        );
      },
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\settings\components\about_screen.dart
â•‘ SIZE: 1.15 KB
â•‘ MODIFIED: 09/10/2025 11:01:43
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart';

class AboutScreen extends StatelessWidget {
  const AboutScreen({super.key});

  Future<void> _launchURL(String url) async {
    final Uri uri = Uri.parse(url);
    if (!await launchUrl(uri)) {
      throw 'Could not launch $url';
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('About'),
      ),
      body: ListView(
        children: [
          ListTile(
            title: const Text('App Version'),
            subtitle: const Text('1.0.0+1'), // Hardcoded for now
          ),
          const Divider(),
          ListTile(
            title: const Text('Help & Support'),
            onTap: () => _launchURL('https://your-support-page.com'),
          ),
          ListTile(
            title: const Text('Privacy Policy'),
            onTap: () => _launchURL('https://your-privacy-policy.com'),
          ),
          ListTile(
            title: const Text('Terms of Service'),
            onTap: () => _launchURL('https://your-terms-of-service.com'),
          ),
        ],
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\settings\components\app_update_widget.dart
â•‘ SIZE: 1.54 KB
â•‘ MODIFIED: 09/12/2025 20:25:29
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';

class AppUpdateWidget extends StatelessWidget {
  const AppUpdateWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'App Updates',
          style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 10),
        Card(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Maintenance Announcement',
                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 10),
                const Text(
                  'The app will be down for maintenance on Sunday at 2:00 AM for approximately 2 hours.',
                ),
                const SizedBox(height: 10),
                ElevatedButton(
                  onPressed: () {
                    // In a real app, this would trigger an update check.
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                        content: Text('No new updates available.'),
                      ),
                    );
                  },
                  child: const Text('Check for Updates'),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\settings\components\change_password_screen.dart
â•‘ SIZE: 17.48 KB
â•‘ MODIFIED: 10/03/2025 07:37:38
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../../utils/password_helper.dart';
import '../../../widgets/enhanced_text_field.dart';
import '../../../widgets/password_strength_checklist.dart';

class ChangePasswordScreen extends StatefulWidget {
  const ChangePasswordScreen({super.key});

  @override
  State<ChangePasswordScreen> createState() => _ChangePasswordScreenState();
}

class _ChangePasswordScreenState extends State<ChangePasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final _currentPasswordController = TextEditingController();
  final _newPasswordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();

  bool _isLoading = false;
  String? _error;
  String _newPassword = '';
  String _confirmPassword = '';
  bool _showNewPasswordChecklist = false;
  bool _showConfirmPasswordValidation = false;
  bool _isFormValid = false;

  @override
  void initState() {
    super.initState();
    _newPasswordController.addListener(_onNewPasswordChanged);
    _confirmPasswordController.addListener(_onConfirmPasswordChanged);
  }

  @override
  void dispose() {
    _currentPasswordController.dispose();
    _newPasswordController.removeListener(_onNewPasswordChanged);
    _newPasswordController.dispose();
    _confirmPasswordController.removeListener(_onConfirmPasswordChanged);
    _confirmPasswordController.dispose();
    super.dispose();
  }

  void _onNewPasswordChanged() {
    setState(() {
      _newPassword = _newPasswordController.text;
      _showNewPasswordChecklist = _newPassword.isNotEmpty;
    });
    _validateForm();
  }

  void _onConfirmPasswordChanged() {
    setState(() {
      _confirmPassword = _confirmPasswordController.text;
      _showConfirmPasswordValidation = _confirmPassword.isNotEmpty;
    });
    _validateForm();
  }

  void _validateForm() {
    final isCurrentPasswordValid = _currentPasswordController.text.isNotEmpty;
    final isNewPasswordValid =
        PasswordHelper.isPasswordStrong(_newPassword) &&
        _newPassword != _currentPasswordController.text;
    final isConfirmPasswordValid = _confirmPassword == _newPassword;

    setState(() {
      _isFormValid =
          isCurrentPasswordValid &&
          isNewPasswordValid &&
          isConfirmPasswordValid;
    });
  }

  void _clearError() {
    if (_error != null) {
      setState(() {
        _error = null;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Change Password'),
        backgroundColor: Theme.of(context).colorScheme.surface,
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Card(
                elevation: 2,
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Icon(
                            Icons.security,
                            color: Theme.of(context).colorScheme.primary,
                            size: 24,
                          ),
                          const SizedBox(width: 8),
                          Text(
                            'Password Security',
                            style: TextStyle(
                              fontSize: 18,
                              fontWeight: FontWeight.bold,
                              color: Theme.of(context).colorScheme.primary,
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 8),
                      Text(
                        'Change your account password to keep your account secure. Follow the password guidelines below.',
                        style: TextStyle(
                          color: Theme.of(context).colorScheme.onSurfaceVariant,
                          fontSize: 14,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 24),

              // Current Password Field
              Text(
                'Current Password',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                  color: Theme.of(context).colorScheme.onSurface,
                ),
              ),
              const SizedBox(height: 8),
              EnhancedTextField(
                controller: _currentPasswordController,
                labelText: 'Enter current password',
                prefixIcon: Icons.lock,
                isPassword: true,
                showValidationIcon: false,
                onChanged: (value) {
                  _clearError();
                  _validateForm();
                },
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Current password is required';
                  }
                  return null;
                },
                keyboardType: TextInputType.visiblePassword,
              ),
              const SizedBox(height: 24),

              // New Password Section
              Text(
                'New Password',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                  color: Theme.of(context).colorScheme.onSurface,
                ),
              ),
              const SizedBox(height: 8),
              EnhancedTextField(
                controller: _newPasswordController,
                labelText: 'Create a new secure password',
                prefixIcon: Icons.lock_outline,
                isPassword: true,
                showValidationIcon: false,
                onChanged: (value) {
                  _clearError();
                  _onNewPasswordChanged();
                },
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'New password is required';
                  }
                  if (value.length < 8) {
                    return 'Password must be at least 8 characters long';
                  }
                  if (!PasswordHelper.isPasswordStrong(value)) {
                    return 'Password does not meet security requirements';
                  }
                  if (value == _currentPasswordController.text) {
                    return 'New password must be different from current password';
                  }
                  return null;
                },
                keyboardType: TextInputType.visiblePassword,
              ),

              // Password Strength Checklist
              if (_showNewPasswordChecklist) ...[
                const SizedBox(height: 8),
                PasswordStrengthChecklist(
                  password: _newPassword,
                  isVisible: true,
                ),
              ],
              const SizedBox(height: 24),

              // Confirm Password Section
              Text(
                'Confirm New Password',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                  color: Theme.of(context).colorScheme.onSurface,
                ),
              ),
              const SizedBox(height: 8),
              EnhancedTextField(
                controller: _confirmPasswordController,
                labelText: 'Re-enter your new password',
                prefixIcon: Icons.lock_outline,
                isPassword: true,
                showValidationIcon: false,
                onChanged: (value) {
                  _clearError();
                  _onConfirmPasswordChanged();
                },
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please confirm your new password';
                  }
                  if (value != _newPasswordController.text) {
                    return 'Passwords do not match';
                  }
                  return null;
                },
                keyboardType: TextInputType.visiblePassword,
              ),

              // Confirm Password Validation
              if (_showConfirmPasswordValidation) ...[
                const SizedBox(height: 8),
                AnimatedContainer(
                  duration: const Duration(milliseconds: 200),
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: _confirmPassword == _newPassword
                        ? Colors.green.withValues(alpha: 0.1)
                        : Colors.red.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(
                      color: _confirmPassword == _newPassword
                          ? Colors.green.withValues(alpha: 0.3)
                          : Colors.red.withValues(alpha: 0.3),
                    ),
                  ),
                  child: Row(
                    children: [
                      Icon(
                        _confirmPassword == _newPassword
                            ? Icons.check_circle
                            : Icons.error,
                        size: 16,
                        color: _confirmPassword == _newPassword
                            ? Colors.green
                            : Colors.red,
                      ),
                      const SizedBox(width: 8),
                      Text(
                        _confirmPassword == _newPassword
                            ? 'Passwords match'
                            : 'Passwords do not match',
                        style: TextStyle(
                          fontSize: 12,
                          color: _confirmPassword == _newPassword
                              ? Colors.green
                              : Colors.red,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                ),
              ],

              const SizedBox(height: 24),

              // Error Display
              if (_error != null) ...[
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.red.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(
                      color: Colors.red.withValues(alpha: 0.3),
                    ),
                  ),
                  child: Row(
                    children: [
                      const Icon(Icons.error, color: Colors.red, size: 20),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          _error!,
                          style: const TextStyle(color: Colors.red),
                        ),
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 16),
              ],

              // Submit Button
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: _isLoading || !_isFormValid
                      ? null
                      : _changePassword,
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    backgroundColor: _isFormValid
                        ? Theme.of(context).colorScheme.primary
                        : Colors.grey,
                    foregroundColor: _isFormValid
                        ? Theme.of(context).colorScheme.onPrimary
                        : Colors.white54,
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(8),
                    ),
                  ),
                  child: _isLoading
                      ? const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            color: Colors.white,
                          ),
                        )
                      : const Text(
                          'Change Password',
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                ),
              ),

              const SizedBox(height: 16),

              // Info Card
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Theme.of(
                    context,
                  ).colorScheme.primary.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(
                    color: Theme.of(
                      context,
                    ).colorScheme.primary.withValues(alpha: 0.3),
                  ),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.info,
                      color: Theme.of(context).colorScheme.primary,
                      size: 20,
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        'After changing your password, you may need to log in again with your new password on other devices.',
                        style: TextStyle(
                          color: Theme.of(
                            context,
                          ).colorScheme.onPrimaryContainer,
                          fontSize: 12,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _changePassword() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) {
        setState(() {
          _error = 'No user is currently signed in. Please log in again.';
          _isLoading = false;
        });
        return;
      }

      // Re-authenticate user with current password
      final credential = EmailAuthProvider.credential(
        email: user.email!,
        password: _currentPasswordController.text,
      );

      await user.reauthenticateWithCredential(credential);

      // Update password
      await user.updatePassword(_newPasswordController.text);

      if (mounted) {
        // Show success message
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Row(
              children: [
                Icon(Icons.check_circle, color: Colors.white),
                SizedBox(width: 8),
                Text('Password changed successfully!'),
              ],
            ),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(8),
            ),
          ),
        );

        // Clear form
        _currentPasswordController.clear();
        _newPasswordController.clear();
        _confirmPasswordController.clear();
        setState(() {
          _newPassword = '';
          _confirmPassword = '';
          _showNewPasswordChecklist = false;
          _showConfirmPasswordValidation = false;
          _isFormValid = false;
        });

        // Navigate back
        Navigator.of(context).pop();
      }
    } on FirebaseAuthException catch (e) {
      String errorMessage;
      switch (e.code) {
        case 'wrong-password':
          errorMessage =
              'The current password you entered is incorrect. Please check your password and try again.';
          break;
        case 'weak-password':
          errorMessage =
              'The new password you entered is too weak. Please use a stronger password.';
          break;
        case 'requires-recent-login':
          errorMessage =
              'For security reasons, please log out and log in again before changing your password.';
          break;
        case 'network-request-failed':
          errorMessage =
              'Network error occurred. Please check your internet connection and try again.';
          break;
        case 'too-many-requests':
          errorMessage =
              'Too many failed attempts. Please wait a moment and try again.';
          break;
        default:
          errorMessage =
              'Failed to change password. Please try again or contact support if the problem persists.';
      }

      if (mounted) {
        setState(() {
          _error = errorMessage;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _error =
              'An unexpected error occurred. Please check your connection and try again.';
          _isLoading = false;
        });
      }
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\settings\components\create_user_dialog.dart
â•‘ SIZE: 8.29 KB
â•‘ MODIFIED: 09/28/2025 12:02:57
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/models/user_role.dart';
import 'package:prostock/providers/auth_provider.dart';

class CreateUserDialog extends StatefulWidget {
  const CreateUserDialog({super.key});

  @override
  State<CreateUserDialog> createState() => _CreateUserDialogState();
}

class _CreateUserDialogState extends State<CreateUserDialog> {
  final _formKey = GlobalKey<FormState>();
  final _usernameController = TextEditingController();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();

  UserRole _selectedRole = UserRole.user;
  bool _isLoading = false;
  bool _obscurePassword = true;
  bool _obscureConfirmPassword = true;

  @override
  void dispose() {
    _usernameController.dispose();
    _emailController.dispose();
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Create New User'),
      content: SingleChildScrollView(
        child: Form(
          key: _formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextFormField(
                controller: _usernameController,
                decoration: const InputDecoration(
                  labelText: 'Username',
                  prefixIcon: Icon(Icons.person),
                  border: OutlineInputBorder(),
                ),
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Username is required';
                  }
                  if (value.trim().length < 3) {
                    return 'Username must be at least 3 characters';
                  }
                  return null;
                },
                textInputAction: TextInputAction.next,
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _emailController,
                decoration: const InputDecoration(
                  labelText: 'Email',
                  prefixIcon: Icon(Icons.email),
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.emailAddress,
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Email is required';
                  }
                  if (!RegExp(
                    r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                  ).hasMatch(value.trim())) {
                    return 'Please enter a valid email';
                  }
                  return null;
                },
                textInputAction: TextInputAction.next,
              ),
              const SizedBox(height: 16),
              DropdownButtonFormField<UserRole>(
                initialValue: _selectedRole,
                decoration: const InputDecoration(
                  labelText: 'Role',
                  prefixIcon: Icon(Icons.admin_panel_settings),
                  border: OutlineInputBorder(),
                ),
                onChanged: (UserRole? newValue) {
                  if (newValue != null) {
                    setState(() {
                      _selectedRole = newValue;
                    });
                  }
                },
                items: UserRole.values.map((UserRole role) {
                  return DropdownMenuItem<UserRole>(
                    value: role,
                    child: Text(role.displayName),
                  );
                }).toList(),
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _passwordController,
                decoration: InputDecoration(
                  labelText: 'Password',
                  prefixIcon: const Icon(Icons.lock),
                  border: const OutlineInputBorder(),
                  suffixIcon: IconButton(
                    icon: Icon(
                      _obscurePassword
                          ? Icons.visibility
                          : Icons.visibility_off,
                    ),
                    onPressed: () {
                      setState(() {
                        _obscurePassword = !_obscurePassword;
                      });
                    },
                  ),
                ),
                obscureText: _obscurePassword,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Password is required';
                  }
                  if (value.length < 6) {
                    return 'Password must be at least 6 characters';
                  }
                  return null;
                },
                textInputAction: TextInputAction.next,
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _confirmPasswordController,
                decoration: InputDecoration(
                  labelText: 'Confirm Password',
                  prefixIcon: const Icon(Icons.lock_outline),
                  border: const OutlineInputBorder(),
                  suffixIcon: IconButton(
                    icon: Icon(
                      _obscureConfirmPassword
                          ? Icons.visibility
                          : Icons.visibility_off,
                    ),
                    onPressed: () {
                      setState(() {
                        _obscureConfirmPassword = !_obscureConfirmPassword;
                      });
                    },
                  ),
                ),
                obscureText: _obscureConfirmPassword,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please confirm password';
                  }
                  if (value != _passwordController.text) {
                    return 'Passwords do not match';
                  }
                  return null;
                },
                textInputAction: TextInputAction.done,
                onFieldSubmitted: (_) => _createUser(),
              ),
            ],
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        ElevatedButton(
          onPressed: _isLoading ? null : _createUser,
          child: _isLoading
              ? const SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : const Text('Create User'),
        ),
      ],
    );
  }

  Future<void> _createUser() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    setState(() {
      _isLoading = true;
    });

    try {
      final authProvider = context.read<AuthProvider>();
      final success = await authProvider.createUser(
        _usernameController.text.trim(),
        _emailController.text.trim(),
        _passwordController.text,
        _selectedRole,
      );

      if (mounted) {
        Navigator.of(context).pop();

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              success
                  ? 'User created successfully! Verification email sent to ${_emailController.text.trim()}'
                  : 'Failed to create user: ${authProvider.error ?? 'Unknown error'}',
            ),
            backgroundColor: success ? Colors.green : Colors.red,
            duration: const Duration(seconds: 5),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error creating user: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\settings\components\notification_test_screen.dart
â•‘ SIZE: 5.37 KB
â•‘ MODIFIED: 10/04/2025 06:16:59
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/utils/notification_tester.dart';

class NotificationTestScreen extends StatefulWidget {
  const NotificationTestScreen({super.key});

  @override
  State<NotificationTestScreen> createState() => _NotificationTestScreenState();
}

class _NotificationTestScreenState extends State<NotificationTestScreen> {
  bool _isLoading = false;

  Future<void> _runTest(
    String testName,
    Future<void> Function() testFunction,
  ) async {
    setState(() {
      _isLoading = true;
    });

    try {
      await testFunction();
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('$testName completed! Check your notifications.'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('$testName failed: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Test Notifications')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Text(
              'Test Notification System',
              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            const Text(
              'Use these buttons to test if notifications are working properly. You should receive push notifications like text messages.',
              style: TextStyle(fontSize: 16, color: Colors.grey),
            ),
            const SizedBox(height: 32),

            ElevatedButton.icon(
              onPressed: _isLoading
                  ? null
                  : () => _runTest(
                      'Direct Notification Test',
                      NotificationTester.testDirectNotifications,
                    ),
              icon: const Icon(Icons.notifications_active),
              label: const Text('Test Direct Notifications'),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.all(16),
              ),
            ),

            const SizedBox(height: 16),

            ElevatedButton.icon(
              onPressed: _isLoading
                  ? null
                  : () => _runTest(
                      'Customer Payment Check',
                      NotificationTester.testCustomerPaymentNotifications,
                    ),
              icon: const Icon(Icons.payment),
              label: const Text('Test Customer Payment Notifications'),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.all(16),
              ),
            ),

            const SizedBox(height: 16),

            ElevatedButton.icon(
              onPressed: _isLoading
                  ? null
                  : () => _runTest(
                      'Scheduled Notification Test',
                      NotificationTester.testScheduledNotification,
                    ),
              icon: const Icon(Icons.schedule),
              label: const Text('Test Scheduled Notification (10s delay)'),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.all(16),
              ),
            ),

            const SizedBox(height: 32),

            if (_isLoading) const Center(child: CircularProgressIndicator()),

            const Expanded(child: SizedBox()),

            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Colors.blue.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.blue.withValues(alpha: 0.3)),
              ),
              child: const Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'How to Test:',
                    style: TextStyle(fontWeight: FontWeight.bold),
                  ),
                  SizedBox(height: 8),
                  Text(
                    '1. Tap "Test Direct Notifications" - you should get 4 test notifications immediately',
                  ),
                  Text(
                    '2. Tap "Test Customer Payment Notifications" - checks your actual sales data',
                  ),
                  Text(
                    '3. Tap "Test Scheduled Notification" - you\'ll get a notification in 10 seconds',
                  ),
                  SizedBox(height: 8),
                  Text(
                    'If you don\'t receive notifications, check your device\'s notification permissions for ProStock.',
                    style: TextStyle(
                      fontStyle: FontStyle.italic,
                      color: Colors.orange,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\settings\components\printer_settings_screen.dart
â•‘ SIZE: 15.17 KB
â•‘ MODIFIED: 09/10/2025 11:40:22
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:esc_pos_utils_plus/esc_pos_utils_plus.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:provider/provider.dart';
import 'package:prostock/models/bluetooth_device.dart';
import 'package:prostock/services/printing_service.dart';

class PrinterSettingsScreen extends StatefulWidget {
  const PrinterSettingsScreen({super.key});

  @override
  State<PrinterSettingsScreen> createState() => _PrinterSettingsScreenState();
}

class _PrinterSettingsScreenState extends State<PrinterSettingsScreen> {
  late PrintingService _printingService;
  List<BluetoothDevice> _devices = [];
  bool _isLoading = false;
  bool _isConnecting = false;
  String? _defaultPrinterAddress;

  @override
  void initState() {
    super.initState();
    _printingService = Provider.of<PrintingService>(context, listen: false);
    _printingService.loadPaperSize();
    _loadDefaultPrinterAndScan();
  }

  Future<void> _loadDefaultPrinterAndScan() async {
    _defaultPrinterAddress = await _printingService.loadDefaultPrinter();
    if (mounted && _defaultPrinterAddress != null) {
      setState(() {});
      // Non-blocking call to attempt auto-reconnect
      _attemptAutoReconnect();
    }
    // Initial scan is now non-blocking
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        _scanForPrinters();
      }
    });
  }

  Future<void> _attemptAutoReconnect() async {
    if (_defaultPrinterAddress == null || _printingService.isConnected) return;

    await _scanForPrinters();

    BluetoothDevice? defaultDevice;

    for (final device in _devices) {
      if (device.address == _defaultPrinterAddress) {
        defaultDevice = device;
        break;
      }
    }

    if (defaultDevice != null) {
      await _selectPrinter(defaultDevice, showMessages: false);
    }
  }

  Future<void> _scanForPrinters() async {
    if (await _requestPermissions()) {
      setState(() => _isLoading = true);
      try {
        final devices = await _printingService.getBluetooths();
        if (kDebugMode) {
          print('Raw devices found: $devices');
        }
        setState(() {
          _devices = devices;
        });
      } catch (e) {
        if (kDebugMode) {
          print('Error scanning for printers: $e');
        }
        if (!mounted) return;
        _showSnackBar('Error scanning for printers: $e', isError: true);
      }
      setState(() => _isLoading = false);
    } else {
      _showSnackBar('Bluetooth permissions are required to scan for printers.',
          isError: true);
    }
  }

  Future<bool> _requestPermissions() async {
    var status = await Permission.bluetoothScan.status;
    if (status.isDenied) {
      await Permission.bluetoothScan.request();
    }
    status = await Permission.bluetoothConnect.status;
    if (status.isDenied) {
      await Permission.bluetoothConnect.request();
    }
    return await Permission.bluetoothScan.isGranted &&
        await Permission.bluetoothConnect.isGranted;
  }

  Future<void> _selectPrinter(
    BluetoothDevice device, {
    bool showMessages = true,
  }) async {
    if (_isConnecting) return;

    setState(() => _isConnecting = true);

    try {
      final bool connected = await _printingService.connect(device);
      if (connected && showMessages) {
        _showSnackBar('Connected to ${device.name}');
      } else if (!connected && showMessages) {
        _showSnackBar('Failed to connect to ${device.name}', isError: true);
      }
    } catch (e) {
      if (showMessages) {
        _showSnackBar('Error connecting: $e', isError: true);
      }
    } finally {
      setState(() => _isConnecting = false);
    }
  }

  void _showSnackBar(String message, {bool isError = false}) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: isError ? Colors.red : null,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<PrintingService>(
      builder: (context, printingService, child) {
        return Scaffold(
          appBar: AppBar(
            title: const Text('Printer Settings'),
            actions: [
              if (_isLoading)
                const Padding(
                  padding: EdgeInsets.only(right: 16.0),
                  child: Center(
                    child: SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(color: Colors.white),
                    ),
                  ),
                )
              else
                IconButton(
                  icon: const Icon(Icons.refresh),
                  onPressed: _scanForPrinters,
                  tooltip: 'Scan for Printers',
                ),
            ],
          ),
          body: Column(
            children: [
              _buildConnectedDeviceSection(printingService),
              const Divider(),
              const Padding(
                padding: EdgeInsets.all(16.0),
                child: Text(
                  'Available Devices',
                  style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                ),
              ),
              Expanded(
                child: _devices.isEmpty
                    ? Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            const Icon(
                              Icons.bluetooth_searching,
                              size: 64,
                              color: Colors.grey,
                            ),
                            const SizedBox(height: 16),
                            const Text('No devices found.'),
                            const SizedBox(height: 8),
                            ElevatedButton.icon(
                              onPressed: _scanForPrinters,
                              icon: const Icon(Icons.refresh),
                              label: const Text('Scan for Printers'),
                            ),
                          ],
                        ),
                      )
                    : ListView.builder(
                        itemCount: _devices.length,
                        itemBuilder: (context, index) {
                          final device = _devices[index];
                          final isConnected =
                              printingService.connectedDeviceAddress ==
                              device.address;
                          final isDefault =
                              _defaultPrinterAddress == device.address;

                          return Card(
                            margin: const EdgeInsets.symmetric(
                              horizontal: 16,
                              vertical: 4,
                            ),
                            child: ListTile(
                              leading: Icon(
                                Icons.bluetooth,
                                color: isConnected ? Colors.green : null,
                              ),
                              title: Row(
                                children: [
                                  Expanded(child: Text(device.name)),
                                  if (isDefault)
                                    const Icon(
                                      Icons.star,
                                      size: 16,
                                      color: Colors.orange,
                                    ),
                                ],
                              ),
                              subtitle: Text(
                                device.address.isEmpty
                                    ? 'No Address'
                                    : device.address,
                              ),
                              onTap: _isConnecting
                                  ? null
                                  : () => _selectPrinter(device),
                              trailing:
                                  _isConnecting &&
                                      device.address ==
                                          printingService.connectedDeviceAddress
                                  ? const SizedBox(
                                      width: 20,
                                      height: 20,
                                      child: CircularProgressIndicator(),
                                    )
                                  : isConnected
                                  ? const Icon(
                                      Icons.check_circle,
                                      color: Colors.green,
                                    )
                                  : null,
                            ),
                          );
                        },
                      ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildConnectedDeviceSection(PrintingService printingService) {
    final isConnected = printingService.isConnected;
    final address = printingService.connectedDeviceAddress;

    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Status',
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          if (isConnected && address != null) ...[
            Card(
              elevation: 2,
              color: Colors.green.withAlpha(26),
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  children: [
                    Row(
                      children: [
                        const Icon(
                          Icons.bluetooth_connected,
                          color: Colors.green,
                          size: 32,
                        ),
                        const SizedBox(width: 16),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                printingService.connectedDeviceName ??
                                    'Connected Printer',
                                style: const TextStyle(
                                  fontWeight: FontWeight.bold,
                                  fontSize: 16,
                                ),
                              ),
                              const SizedBox(height: 4),
                              Text(
                                address,
                                style: TextStyle(
                                  color: Colors.grey[600],
                                  fontSize: 12,
                                ),
                              ),
                              const SizedBox(height: 4),
                              Container(
                                padding: const EdgeInsets.symmetric(
                                  horizontal: 8,
                                  vertical: 2,
                                ),
                                decoration: BoxDecoration(
                                  color: Colors.green,
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                child: const Text(
                                  'Connected',
                                  style: TextStyle(
                                    color: Colors.white,
                                    fontSize: 10,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        OutlinedButton.icon(
                          onPressed: printingService.printTest,
                          icon: const Icon(Icons.print),
                          label: const Text('Test Print'),
                        ),
                        const SizedBox(width: 8),
                        ElevatedButton.icon(
                          onPressed: printingService.disconnect,
                          icon: const Icon(Icons.bluetooth_disabled),
                          label: const Text('Disconnect'),
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.red,
                            foregroundColor: Colors.white,
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ] else ...[
            Card(
              elevation: 2,
              color: Colors.grey.withAlpha(26),
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Row(
                  children: [
                    Icon(
                      Icons.bluetooth_disabled,
                      color: Colors.grey[600],
                      size: 32,
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          const Text(
                            'No printer connected',
                            style: TextStyle(
                              fontWeight: FontWeight.bold,
                              fontSize: 16,
                            ),
                          ),
                          const SizedBox(height: 4),
                          Text(
                            'Scan for devices and tap to connect',
                            style: TextStyle(
                              color: Colors.grey[600],
                              fontSize: 12,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
          const SizedBox(height: 16),
          Row(
            children: [
              const Text('Paper Size:'),
              const SizedBox(width: 16),
              DropdownButton<PaperSize>(
                value: printingService.paperSize,
                items: const [
                  DropdownMenuItem(value: PaperSize.mm58, child: Text('58 mm')),
                  DropdownMenuItem(value: PaperSize.mm80, child: Text('80 mm')),
                ],
                onChanged: (value) {
                  if (value != null) {
                    printingService.savePaperSize(value);
                  }
                },
              ),
            ],
          ),
        ],
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\settings\components\system_monitoring_widget.dart
â•‘ SIZE: 1.92 KB
â•‘ MODIFIED: 09/12/2025 20:21:25
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/models/user_activity.dart';
import 'package:prostock/services/firestore/activity_service.dart';

class SystemMonitoringWidget extends StatelessWidget {
  const SystemMonitoringWidget({super.key});

  @override
  Widget build(BuildContext context) {
    final activityService = Provider.of<ActivityService>(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'System Monitoring',
          style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 10),
        const Text('Recent User Activity:'),
        SizedBox(
          height: 200,
          child: StreamBuilder<List<UserActivity>>(
            stream: activityService.getAllUserActivitiesStream(),
            builder: (context, snapshot) {
              if (snapshot.connectionState == ConnectionState.waiting) {
                return const Center(child: CircularProgressIndicator());
              }
              if (snapshot.hasError) {
                return Center(child: Text('Error: \${snapshot.error}'));
              }
              if (!snapshot.hasData || snapshot.data!.isEmpty) {
                return const Center(child: Text('No recent activity.'));
              }

              final activities = snapshot.data!;

              return ListView.builder(
                itemCount: activities.length,
                itemBuilder: (context, index) {
                  final activity = activities[index];
                  return ListTile(
                    title: Text('\${activity.action} by \${activity.userId}'),
                    subtitle: Text(activity.details ?? ''),
                    trailing: Text(activity.timestamp.toString()),
                  );
                },
              );
            },
          ),
        ),
      ],
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\settings\components\tax_history_dialog.dart
â•‘ SIZE: 9.73 KB
â•‘ MODIFIED: 09/28/2025 19:53:22
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/services/tax_history_service.dart';
import 'package:prostock/models/tax_settings_history.dart';

class TaxHistoryDialog extends StatefulWidget {
  const TaxHistoryDialog({super.key});

  @override
  State<TaxHistoryDialog> createState() => _TaxHistoryDialogState();
}

class _TaxHistoryDialogState extends State<TaxHistoryDialog> {
  List<TaxSettingsHistory> _history = [];
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadHistory();
  }

  Future<void> _loadHistory() async {
    try {
      final history = await TaxHistoryService.getRecentHistory();
      if (mounted) {
        setState(() {
          _history = history;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('Failed to load history: $e')));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      child: Container(
        width: MediaQuery.of(context).size.width * 0.9,
        height: MediaQuery.of(context).size.height * 0.8,
        padding: const EdgeInsets.all(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: Text(
                    'Markup Settings History',
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                IconButton(
                  onPressed: () => Navigator.of(context).pop(),
                  icon: const Icon(Icons.close, size: 20),
                  padding: EdgeInsets.zero,
                  constraints: const BoxConstraints(
                    minWidth: 32,
                    minHeight: 32,
                  ),
                ),
              ],
            ),
            const Divider(),
            Expanded(
              child: _isLoading
                  ? const Center(child: CircularProgressIndicator())
                  : _history.isEmpty
                  ? const Center(
                      child: Text(
                        'No markup history available',
                        style: TextStyle(fontSize: 16, color: Colors.grey),
                      ),
                    )
                  : ListView.builder(
                      itemCount: _history.length,
                      itemBuilder: (context, index) {
                        final entry = _history[index];
                        return Card(
                          margin: const EdgeInsets.only(bottom: 6),
                          child: Padding(
                            padding: const EdgeInsets.all(8),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Row(
                                  children: [
                                    CircleAvatar(
                                      backgroundColor: _getSourceColor(
                                        entry.source,
                                      ),
                                      radius: 14,
                                      child: Icon(
                                        _getSourceIcon(entry.source),
                                        color: Colors.white,
                                        size: 14,
                                      ),
                                    ),
                                    const SizedBox(width: 8),
                                    Expanded(
                                      child: Text(
                                        entry.changeDescription,
                                        style: const TextStyle(
                                          fontWeight: FontWeight.w500,
                                          fontSize: 13,
                                        ),
                                        maxLines: 2,
                                        overflow: TextOverflow.ellipsis,
                                      ),
                                    ),
                                    const SizedBox(width: 4),
                                    Container(
                                      padding: const EdgeInsets.symmetric(
                                        horizontal: 6,
                                        vertical: 2,
                                      ),
                                      decoration: BoxDecoration(
                                        color: _getSourceColor(entry.source),
                                        borderRadius: BorderRadius.circular(8),
                                      ),
                                      child: Text(
                                        entry.source
                                            .replaceAll('_', ' ')
                                            .toUpperCase(),
                                        style: const TextStyle(
                                          fontSize: 9,
                                          color: Colors.white,
                                          fontWeight: FontWeight.bold,
                                        ),
                                      ),
                                    ),
                                  ],
                                ),
                                const SizedBox(height: 4),
                                Text(
                                  'By: ${entry.changedByUserName}',
                                  style: TextStyle(
                                    fontSize: 12,
                                    color: Colors.grey[600],
                                  ),
                                ),
                                Text(
                                  _formatDateTime(entry.timestamp),
                                  style: const TextStyle(
                                    fontSize: 11,
                                    color: Colors.grey,
                                  ),
                                ),
                              ],
                            ),
                          ),
                        );
                      },
                    ),
            ),
            if (_history.isNotEmpty)
              Padding(
                padding: const EdgeInsets.only(top: 8),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      'Showing ${_history.length} changes',
                      style: TextStyle(fontSize: 11, color: Colors.grey[600]),
                    ),
                    TextButton(
                      onPressed: () async {
                        final confirmed = await showDialog<bool>(
                          context: context,
                          builder: (context) => AlertDialog(
                            title: const Text('Clear History'),
                            content: const Text(
                              'Are you sure you want to clear all tax settings history? This action cannot be undone.',
                            ),
                            actions: [
                              TextButton(
                                onPressed: () =>
                                    Navigator.of(context).pop(false),
                                child: const Text('Cancel'),
                              ),
                              TextButton(
                                onPressed: () =>
                                    Navigator.of(context).pop(true),
                                child: const Text('Clear'),
                              ),
                            ],
                          ),
                        );

                        if (confirmed == true) {
                          await TaxHistoryService.clearHistory();
                          _loadHistory();
                        }
                      },
                      child: const Text('Clear'),
                    ),
                  ],
                ),
              ),
          ],
        ),
      ),
    );
  }

  Color _getSourceColor(String source) {
    switch (source) {
      case 'settings_screen':
        return Colors.blue;
      case 'admin':
        return Colors.red;
      case 'api':
        return Colors.green;
      default:
        return Colors.grey;
    }
  }

  IconData _getSourceIcon(String source) {
    switch (source) {
      case 'settings_screen':
        return Icons.settings;
      case 'admin':
        return Icons.admin_panel_settings;
      case 'api':
        return Icons.api;
      default:
        return Icons.edit;
    }
  }

  String _formatDateTime(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inDays > 0) {
      return '${difference.inDays} day${difference.inDays == 1 ? '' : 's'} ago';
    } else if (difference.inHours > 0) {
      return '${difference.inHours} hour${difference.inHours == 1 ? '' : 's'} ago';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes} minute${difference.inMinutes == 1 ? '' : 's'} ago';
    } else {
      return 'Just now';
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\settings\components\tax_rules_screen.dart
â•‘ SIZE: 29.42 KB
â•‘ MODIFIED: 10/26/2025 13:07:10
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/services/tax_service.dart';
import 'package:prostock/models/tax_rule.dart';
import 'package:prostock/models/product.dart';
import 'package:prostock/providers/inventory_provider.dart';
import 'package:prostock/utils/constants.dart';
import 'package:provider/provider.dart';

class TaxRulesScreen extends StatefulWidget {
  const TaxRulesScreen({super.key});

  @override
  State<TaxRulesScreen> createState() => _TaxRulesScreenState();
}

class _TaxRulesScreenState extends State<TaxRulesScreen> {
  List<TaxRule> _rules = [];
  bool _isLoading = true;
  String? _error;

  @override
  void initState() {
    super.initState();
    _loadRules();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // Reload when dependencies change to ensure we have latest product data
    _loadRules();
  }

  // Map to cache product names by ID
  final Map<String, String> _productNames = {};

  Future<void> _loadRules() async {
    setState(() => _isLoading = true);
    try {
      final rules = await TaxService.getAllTaxRules();

      // Load product names for product-specific rules
      final productIds = rules
          .where((rule) => rule.isProduct && rule.productId != null)
          .map((rule) => rule.productId!)
          .toSet()
          .toList();

      if (productIds.isNotEmpty && mounted) {
        final inventoryProvider = context.read<InventoryProvider>();
        for (final productId in productIds) {
          final product = inventoryProvider.getProductById(productId);
          if (product != null) {
            _productNames[productId] = product.name;
          }
        }
      }

      if (mounted) {
        setState(() {
          _rules = rules;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _error = 'Failed to load tax rules: $e';
          _isLoading = false;
        });
      }
    }
  }

  Future<void> _addRule() async {
    final result = await showDialog<TaxRule>(
      context: context,
      builder: (context) => const AddTaxRuleDialog(),
    );

    if (result != null) {
      // Check for conflicts using the service method
      final conflictRule = await TaxService.checkForConflicts(result);

      if (conflictRule != null) {
        // Determine the scope for the confirmation dialog
        String scope = 'Rule';
        if (result.isGlobal) {
          scope = 'Global';
        } else if (result.isCategory) {
          scope = 'Category (${result.categoryName})';
        } else if (result.isProduct) {
          scope = 'Product';
        }

        if (!mounted) return;
        final confirmed = await showDialog<bool>(
          context: context,
          builder: (context) => AlertDialog(
            title: Text('Replace $scope Rule'),
            content: Text(
              'A $scope markup rule already exists with tubo amount ₱${conflictRule.tubo.toStringAsFixed(2)}.\n\n'
              'Do you want to replace it with the new rule (₱${result.tubo.toStringAsFixed(2)})?',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(false),
                child: const Text('Cancel'),
              ),
              TextButton(
                onPressed: () => Navigator.of(context).pop(true),
                child: const Text('Replace'),
              ),
            ],
          ),
        );

        if (confirmed != true) {
          return; // User cancelled
        }
      }

      final success = await TaxService.addTaxRule(result);
      if (success) {
        _loadRules();
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                result.isGlobal
                    ? 'Global rule replaced successfully!'
                    : result.isCategory
                    ? 'Category rule replaced successfully!'
                    : result.isProduct
                    ? 'Product rule replaced successfully!'
                    : 'Tax rule added successfully!',
              ),
              backgroundColor: Colors.green,
            ),
          );
        }
      } else {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to add tax rule'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    }
  }

  Future<void> _editRule(TaxRule rule) async {
    final result = await showDialog<TaxRule>(
      context: context,
      builder: (context) => AddTaxRuleDialog(rule: rule),
    );

    if (result != null) {
      // Show confirmation dialog for updating rule
      if (!mounted) return;
      final confirmed = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Update Markup Rule'),
          content: Text(
            'Are you sure you want to update this markup rule?\n\n'
            'Current: ${rule.description} (₱${rule.tubo.toStringAsFixed(2)})\n'
            'New: ${result.description} (₱${result.tubo.toStringAsFixed(2)})\n\n'
            'This will affect pricing for all products using this rule.',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: const Text('Update'),
            ),
          ],
        ),
      );

      if (confirmed == true) {
        final success = await TaxService.updateTaxRule(result);
        if (success) {
          _loadRules();
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Tax rule updated successfully!'),
                backgroundColor: Colors.green,
              ),
            );
          }
        } else {
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Failed to update tax rule'),
                backgroundColor: Colors.red,
              ),
            );
          }
        }
      }
    }
  }

  Future<void> _deleteRule(TaxRule rule) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Markup Rule'),
        content: Text(
          'Are you sure you want to delete this markup rule?\n\n'
          'Rule: ${rule.description}\n'
          'Tubo Amount: ₱${rule.tubo.toStringAsFixed(2)}\n\n'
          'This will affect pricing for all products using this rule. '
          'Products will fall back to the next applicable rule or global settings.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('Delete'),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      final success = await TaxService.deleteTaxRule(rule.id);
      if (success) {
        _loadRules();
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Tax rule deleted successfully!'),
              backgroundColor: Colors.green,
            ),
          );
        }
      } else {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to delete tax rule'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Markup Rules'),
        actions: [
          IconButton(
            onPressed: _loadRules,
            icon: const Icon(Icons.refresh),
            tooltip: 'Refresh',
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _error != null
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.error_outline, size: 64, color: Colors.red[300]),
                  const SizedBox(height: 16),
                  Text(
                    _error!,
                    style: TextStyle(fontSize: 16, color: Colors.red[600]),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: _loadRules,
                    child: const Text('Retry'),
                  ),
                ],
              ),
            )
          : _rules.isEmpty
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.rule, size: 64, color: Colors.grey[400]),
                  const SizedBox(height: 16),
                  Text(
                    'No tax rules configured',
                    style: TextStyle(fontSize: 18, color: Colors.grey[600]),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Add rules for different categories or products',
                    style: TextStyle(fontSize: 14, color: Colors.grey[500]),
                  ),
                ],
              ),
            )
          : ListView.builder(
              padding: const EdgeInsets.all(16),
              itemCount: _rules.length,
              itemBuilder: (context, index) {
                final rule = _rules[index];
                return Card(
                  margin: const EdgeInsets.only(bottom: 8),
                  child: ListTile(
                    leading: CircleAvatar(
                      backgroundColor: _getRuleColor(rule),
                      child: Icon(
                        _getRuleIcon(rule),
                        color: Colors.white,
                        size: 20,
                      ),
                    ),
                    title: Text(
                      _getRuleDisplayName(rule),
                      style: const TextStyle(fontWeight: FontWeight.w500),
                    ),
                    subtitle: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('Tubo: ₱${rule.tubo.toStringAsFixed(2)}'),
                        // Method removed; sari-sari pricing always adds tubo on top
                        Text('Priority: ${rule.priority}'),
                      ],
                    ),
                    trailing: PopupMenuButton(
                      itemBuilder: (context) => [
                        const PopupMenuItem(
                          value: 'edit',
                          child: Row(
                            children: [
                              Icon(Icons.edit),
                              SizedBox(width: 8),
                              Text('Edit'),
                            ],
                          ),
                        ),
                        const PopupMenuItem(
                          value: 'delete',
                          child: Row(
                            children: [
                              Icon(Icons.delete, color: Colors.red),
                              SizedBox(width: 8),
                              Text(
                                'Delete',
                                style: TextStyle(color: Colors.red),
                              ),
                            ],
                          ),
                        ),
                      ],
                      onSelected: (value) {
                        if (value == 'edit') {
                          _editRule(rule);
                        } else if (value == 'delete') {
                          _deleteRule(rule);
                        }
                      },
                    ),
                  ),
                );
              },
            ),
      floatingActionButton: FloatingActionButton(
        onPressed: _addRule,
        child: const Icon(Icons.add),
      ),
    );
  }

  Color _getRuleColor(TaxRule rule) {
    if (rule.isProduct) {
      return Colors.purple;
    } else if (rule.isCategory) {
      return Colors.blue;
    } else {
      return Colors.grey;
    }
  }

  // Get a user-friendly display name for the rule
  String _getRuleDisplayName(TaxRule rule) {
    if (rule.isProduct && rule.productId != null) {
      // Return product name if available, fallback to generic description with ID
      return _productNames.containsKey(rule.productId)
          ? 'Product: ${_productNames[rule.productId]}'
          : 'Product: (Unknown - ID: ${rule.productId})';
    } else if (rule.isCategory && rule.categoryName != null) {
      return 'Category: ${rule.categoryName}';
    } else {
      return 'Global rule';
    }
  }

  IconData _getRuleIcon(TaxRule rule) {
    if (rule.isProduct) {
      return Icons.inventory;
    } else if (rule.isCategory) {
      return Icons.category;
    } else {
      return Icons.settings;
    }
  }
}

class _ProductSearchDialog extends StatefulWidget {
  final List<Product> products;

  const _ProductSearchDialog({required this.products});

  @override
  State<_ProductSearchDialog> createState() => _ProductSearchDialogState();
}

class _ProductSearchDialogState extends State<_ProductSearchDialog> {
  final TextEditingController _searchController = TextEditingController();
  List<Product> _filteredProducts = [];

  @override
  void initState() {
    super.initState();
    _filteredProducts = widget.products;
    _searchController.addListener(_filterProducts);
  }

  void _filterProducts() {
    final query = _searchController.text.toLowerCase();
    setState(() {
      _filteredProducts = widget.products
          .where((product) => product.name.toLowerCase().contains(query))
          .toList();
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      child: Container(
        width: MediaQuery.of(context).size.width * 0.9,
        height: MediaQuery.of(context).size.height * 0.7,
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            Text(
              'Select Product',
              style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _searchController,
              decoration: const InputDecoration(
                labelText: 'Search products...',
                prefixIcon: Icon(Icons.search),
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            Expanded(
              child: _filteredProducts.isEmpty
                  ? const Center(
                      child: Text(
                        'No products found',
                        style: TextStyle(
                          color: Colors.grey,
                          fontStyle: FontStyle.italic,
                        ),
                      ),
                    )
                  : ListView.builder(
                      itemCount: _filteredProducts.length,
                      itemBuilder: (context, index) {
                        final product = _filteredProducts[index];
                        return ListTile(
                          leading: const Icon(Icons.inventory),
                          title: Text(product.name),
                          subtitle: Text('Category: ${product.category}'),
                          onTap: () {
                            Navigator.of(context).pop(product);
                          },
                        );
                      },
                    ),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: const Text('Cancel'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

class AddTaxRuleDialog extends StatefulWidget {
  final TaxRule? rule;

  const AddTaxRuleDialog({super.key, this.rule});

  @override
  State<AddTaxRuleDialog> createState() => _AddTaxRuleDialogState();
}

class _AddTaxRuleDialogState extends State<AddTaxRuleDialog> {
  final _formKey = GlobalKey<FormState>();
  final _tuboController = TextEditingController();
  final _categoryController = TextEditingController();
  final _productController = TextEditingController();

  String _ruleType = 'global'; // 'global', 'category', 'product'
  // Inclusive removed; always add on top.
  bool _isLoading = false;

  // For category dropdown
  String? _selectedCategory;
  List<String> _availableCategories = [];

  @override
  void initState() {
    super.initState();
    _loadCategories();
    _setupProductSearch();

    if (widget.rule != null) {
      _ruleType = widget.rule!.isProduct
          ? 'product'
          : widget.rule!.isCategory
          ? 'category'
          : 'global';
      _tuboController.text = widget.rule!.tubo.toStringAsFixed(2);
      // Ignore any stored inclusive flag; not used anymore.
      _selectedCategory = widget.rule!.categoryName;
      _categoryController.text = widget.rule!.categoryName ?? '';

      // For product rules, look up the product name from the ID
      if (widget.rule!.productId != null) {
        final inventoryProvider = context.read<InventoryProvider>();
        final product = inventoryProvider.getProductById(
          widget.rule!.productId!,
        );
        _productController.text = product?.name ?? 'Unknown Product';
      }
    }
  }

  Future<void> _loadCategories() async {
    try {
      // Only use predefined categories from AppConstants
      final predefinedCategories = AppConstants.productCategories;

      // Sort categories alphabetically
      final sortedCategories = List<String>.from(predefinedCategories)..sort();

      if (mounted) {
        setState(() {
          _availableCategories = sortedCategories;
        });
      }
    } catch (e) {
      // Fallback to empty list if there's an error
      if (mounted) {
        setState(() {
          _availableCategories = [];
        });
      }
    }
  }

  void _setupProductSearch() {
    // No longer needed since we use a separate dialog
  }

  void _showProductSearchDialog() async {
    final inventoryProvider = context.read<InventoryProvider>();

    // Ensure products are loaded
    if (inventoryProvider.products.isEmpty) {
      await inventoryProvider.loadProducts();
    }

    if (!mounted) return;

    final products = inventoryProvider.products;

    final selectedProduct = await showDialog<Product>(
      context: context,
      builder: (context) => _ProductSearchDialog(products: products),
    );

    if (selectedProduct != null) {
      setState(() {
        _productController.text = selectedProduct.name;
      });
    }
  }

  @override
  void dispose() {
    _tuboController.dispose();
    _categoryController.dispose();
    _productController.dispose();
    super.dispose();
  }

  Future<void> _saveRule() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      final tubo = double.parse(_tuboController.text);
      final now = DateTime.now();

      // For product rules, we need to find the product ID from the name
      String? productId;
      if (_ruleType == 'product') {
        try {
          final inventoryProvider = context.read<InventoryProvider>();
          final products = inventoryProvider.products;
          final product = products.firstWhere(
            (p) => p.name == _productController.text.trim(),
            orElse: () => throw StateError('Product not found'),
          );
          productId = product.id;
        } catch (e) {
          // Handle error
        }
      }

      final rule = TaxRule(
        id: widget.rule?.id ?? now.millisecondsSinceEpoch.toString(),
        categoryName: _ruleType == 'category' ? _selectedCategory : null,
        productId: productId,
        tubo: tubo,
        isInclusive: false,
        priority: _getPriority(),
        createdAt: widget.rule?.createdAt ?? now,
        updatedAt: now,
      );

      Navigator.of(context).pop(rule);
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('Error: $e')));
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  int _getPriority() {
    switch (_ruleType) {
      case 'product':
        return 100;
      case 'category':
        return 50;
      default:
        return 0;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      insetPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 24),
      child: ConstrainedBox(
        constraints: BoxConstraints(
          maxWidth: MediaQuery.of(context).size.width * 0.95,
          maxHeight: MediaQuery.of(context).size.height * 0.85,
        ),
        child: Padding(
          padding: EdgeInsets.only(
            left: 16,
            right: 16,
            top: 16,
            bottom: 16 + MediaQuery.of(context).viewInsets.bottom,
          ),
          child: SingleChildScrollView(
            physics: const BouncingScrollPhysics(),
            child: Form(
              key: _formKey,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    widget.rule == null
                        ? 'Add Markup Rule'
                        : 'Edit Markup Rule',
                    style: const TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 16),

                  // Rule Type
                  const Text(
                    'Rule Type',
                    style: TextStyle(fontWeight: FontWeight.w500),
                  ),
                  const SizedBox(height: 8),
                  RadioGroup<String>(
                    groupValue: _ruleType,
                    onChanged: (value) {
                      setState(() {
                        _ruleType = value ?? 'global';
                      });
                    },
                    child: Column(
                      children: [
                        RadioListTile<String>(
                          title: const Text('Global'),
                          subtitle: const Text('Applies to all products'),
                          value: 'global',
                        ),
                        RadioListTile<String>(
                          title: const Text('Category'),
                          subtitle: const Text('Applies to specific category'),
                          value: 'category',
                        ),
                        RadioListTile<String>(
                          title: const Text('Product'),
                          subtitle: const Text('Applies to specific product'),
                          value: 'product',
                        ),
                      ],
                    ),
                  ),

                  const SizedBox(height: 16),

                  // Category/Product fields
                  if (_ruleType == 'category') ...[
                    DropdownButtonFormField<String>(
                      initialValue: _selectedCategory,
                      decoration: const InputDecoration(
                        labelText: 'Select Category',
                        border: OutlineInputBorder(),
                        prefixIcon: Icon(Icons.category),
                      ),
                      items: _availableCategories.map((category) {
                        return DropdownMenuItem<String>(
                          value: category,
                          child: Text(
                            category,
                            overflow: TextOverflow.ellipsis,
                            maxLines: 1,
                          ),
                        );
                      }).toList(),
                      onChanged: (value) {
                        setState(() {
                          _selectedCategory = value;
                          _categoryController.text = value ?? '';
                        });
                      },
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please select a category';
                        }
                        return null;
                      },
                      isExpanded: true,
                    ),
                    const SizedBox(height: 16),
                  ],

                  if (_ruleType == 'product') ...[
                    TextFormField(
                      controller: _productController,
                      decoration: const InputDecoration(
                        labelText: 'Search Product',
                        hintText: 'Type product name...',
                        border: OutlineInputBorder(),
                        prefixIcon: Icon(Icons.search),
                        suffixIcon: Icon(Icons.inventory),
                      ),
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) {
                          return 'Please select a product';
                        }
                        return null;
                      },
                      onTap: () {
                        _showProductSearchDialog();
                      },
                      readOnly: true,
                    ),
                    const SizedBox(height: 16),
                  ],

                  // Tubo Amount
                  TextFormField(
                    controller: _tuboController,
                    decoration: const InputDecoration(
                      labelText: 'Tubo Amount (₱)',
                      border: OutlineInputBorder(),
                      isDense: true,
                      suffixText: '₱',
                    ),
                    keyboardType: TextInputType.numberWithOptions(
                      decimal: true,
                    ),
                    textInputAction: TextInputAction.done,
                    maxLines: 1,
                    expands: false,
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Tubo amount is required';
                      }
                      final amount = double.tryParse(value);
                      if (amount == null || amount < 0) {
                        return 'Tubo amount must be 0 or greater';
                      }
                      return null;
                    },
                  ),

                  const SizedBox(height: 16),

                  // Sari-sari pricing always adds tubo on top; method selector removed
                  const SizedBox(height: 24),

                  // Buttons
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      TextButton(
                        onPressed: _isLoading
                            ? null
                            : () => Navigator.of(context).pop(),
                        child: const Text('Cancel'),
                      ),
                      const SizedBox(width: 8),
                      ElevatedButton(
                        onPressed: _isLoading ? null : _saveRule,
                        child: _isLoading
                            ? const SizedBox(
                                width: 16,
                                height: 16,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                ),
                              )
                            : Text(widget.rule == null ? 'Add' : 'Update'),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\settings\components\tax_settings_screen.dart
â•‘ SIZE: 18.32 KB
â•‘ MODIFIED: 09/29/2025 14:38:44
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/services/tax_service.dart';
import 'package:prostock/providers/auth_provider.dart';
import 'package:provider/provider.dart';
import 'tax_history_dialog.dart';

// Deprecated: Use Markup Rules screen instead. This screen is no longer used.
class TaxSettingsScreen extends StatefulWidget {
  const TaxSettingsScreen({super.key});

  @override
  State<TaxSettingsScreen> createState() => _TaxSettingsScreenState();
}

class _TaxSettingsScreenState extends State<TaxSettingsScreen> {
  final _formKey = GlobalKey<FormState>();
  final _tuboAmountController = TextEditingController();

  double _tuboAmount = 2.0; // Default ₱2
  bool _tuboInclusive = true;
  bool _isLoading = false;
  String? _error;

  @override
  void initState() {
    super.initState();
    _loadTaxSettings();
  }

  @override
  void dispose() {
    _tuboAmountController.dispose();
    super.dispose();
  }

  Future<void> _loadTaxSettings() async {
    setState(() => _isLoading = true);

    try {
      // Load tubo settings using TaxService
      _tuboAmount = await TaxService.getTuboAmount();
      _tuboAmountController.text = _tuboAmount.toStringAsFixed(2);

      _tuboInclusive = await TaxService.isTuboInclusive();

      setState(() {});
    } catch (e) {
      setState(() {
        _error = 'Failed to load tubo settings: $e';
      });
    } finally {
      setState(() => _isLoading = false);
    }
  }

  Future<void> _saveTaxSettings() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      final authProvider = context.read<AuthProvider>();
      final currentUser = authProvider.currentUser;

      if (currentUser == null) {
        throw Exception('User not authenticated');
      }

      // Save tubo settings using TaxService with history tracking
      final amountSuccess = await TaxService.setTuboAmount(
        _tuboAmount,
        changedByUserId: currentUser.id ?? 'unknown',
        changedByUserName: currentUser.username,
        source: 'settings_screen',
      );

      final inclusiveSuccess = await TaxService.setTuboInclusive(
        _tuboInclusive,
        changedByUserId: currentUser.id ?? 'unknown',
        changedByUserName: currentUser.username,
        source: 'settings_screen',
      );

      if (amountSuccess && inclusiveSuccess) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Tubo settings saved successfully!'),
              backgroundColor: Colors.green,
            ),
          );
        }
      } else {
        throw Exception('Failed to save one or more settings');
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _error = 'Failed to save tubo settings: $e';
        });
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  void _updateTuboAmount(String value) {
    final amount = double.tryParse(value);
    if (amount != null && amount >= 0) {
      setState(() {
        _tuboAmount = amount;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Markup Settings'),
        actions: [
          IconButton(
            onPressed: () {
              showDialog(
                context: context,
                builder: (context) => const TaxHistoryDialog(),
              );
            },
            icon: const Icon(Icons.history),
            tooltip: 'View History',
          ),
          if (!_isLoading)
            TextButton(
              onPressed: _saveTaxSettings,
              child: const Text('Save', style: TextStyle(color: Colors.white)),
            ),
        ],
      ),
      body: _isLoading && _tuboAmountController.text.isEmpty
          ? const Center(child: CircularProgressIndicator())
          : SingleChildScrollView(
              padding: const EdgeInsets.all(16.0),
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Tubo Amount Section
                    Card(
                      child: Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const Row(
                              children: [
                                Icon(Icons.attach_money, color: Colors.blue),
                                SizedBox(width: 8),
                                Text(
                                  'Tubo Configuration',
                                  style: TextStyle(
                                    fontSize: 18,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ],
                            ),
                            const SizedBox(height: 16),
                            TextFormField(
                              controller: _tuboAmountController,
                              decoration: InputDecoration(
                                labelText: 'Tubo Amount (₱)',
                                border: const OutlineInputBorder(),
                                suffixText: '₱',
                                helperText: 'Enter fixed tubo amount in pesos',
                              ),
                              keyboardType: TextInputType.numberWithOptions(
                                decimal: true,
                              ),
                              onChanged: _updateTuboAmount,
                              validator: (value) {
                                if (value == null || value.isEmpty) {
                                  return 'Tubo amount is required';
                                }
                                final amount = double.tryParse(value);
                                if (amount == null) {
                                  return 'Please enter a valid number';
                                }
                                if (amount < 0) {
                                  return 'Tubo amount must be 0 or greater';
                                }
                                return null;
                              },
                            ),
                            const SizedBox(height: 16),
                            Container(
                              padding: const EdgeInsets.all(12),
                              decoration: BoxDecoration(
                                color: Colors.blue.withValues(alpha: 0.1),
                                borderRadius: BorderRadius.circular(8),
                                border: Border.all(
                                  color: Colors.blue.withValues(alpha: 0.3),
                                ),
                              ),
                              child: Row(
                                children: [
                                  const Icon(
                                    Icons.info,
                                    color: Colors.blue,
                                    size: 20,
                                  ),
                                  const SizedBox(width: 8),
                                  Expanded(
                                    child: Text(
                                      'Current tubo: ₱${_tuboAmount.toStringAsFixed(2)}',
                                      style: const TextStyle(
                                        color: Colors.blue,
                                        fontWeight: FontWeight.w500,
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                    const SizedBox(height: 24),

                    // Pricing Method Section
                    Card(
                      child: Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const Row(
                              children: [
                                Icon(Icons.calculate, color: Colors.green),
                                SizedBox(width: 8),
                                Text(
                                  'Tubo Method',
                                  style: TextStyle(
                                    fontSize: 18,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ],
                            ),
                            const SizedBox(height: 16),
                            RadioGroup<bool>(
                              groupValue: _tuboInclusive,
                              onChanged: (value) {
                                setState(() {
                                  _tuboInclusive = value ?? true;
                                });
                              },
                              child: Column(
                                children: [
                                  RadioListTile<bool>(
                                    title: const Text('Tubo Inclusive'),
                                    subtitle: const Text(
                                      'Selling price equals cost (tubo included)',
                                    ),
                                    value: true,
                                  ),
                                  RadioListTile<bool>(
                                    title: const Text('Tubo Added on Top'),
                                    subtitle: const Text(
                                      'Tubo is added to the cost',
                                    ),
                                    value: false,
                                  ),
                                ],
                              ),
                            ),
                            const SizedBox(height: 16),
                            Container(
                              padding: const EdgeInsets.all(12),
                              decoration: BoxDecoration(
                                color: Colors.green.withValues(alpha: 0.1),
                                borderRadius: BorderRadius.circular(8),
                                border: Border.all(
                                  color: Colors.green.withValues(alpha: 0.3),
                                ),
                              ),
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Row(
                                    children: [
                                      Icon(
                                        _tuboInclusive
                                            ? Icons.check_circle
                                            : Icons.add_circle,
                                        color: Colors.green,
                                        size: 20,
                                      ),
                                      const SizedBox(width: 8),
                                      Text(
                                        _tuboInclusive
                                            ? 'Tubo Inclusive'
                                            : 'Tubo Added on Top',
                                        style: const TextStyle(
                                          color: Colors.green,
                                          fontWeight: FontWeight.w500,
                                        ),
                                      ),
                                    ],
                                  ),
                                  const SizedBox(height: 8),
                                  Text(
                                    _tuboInclusive
                                        ? 'Example: Cost ₱100 → Selling ₱100 (tubo included)'
                                        : 'Example: Cost ₱100 → Selling ₱${(100 + _tuboAmount).toStringAsFixed(0)} (₱100 + ₱${_tuboAmount.toStringAsFixed(0)} tubo)',
                                    style: const TextStyle(
                                      color: Colors.green,
                                      fontSize: 12,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                    const SizedBox(height: 24),

                    // Tax Information Section
                    Card(
                      child: Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const Row(
                              children: [
                                Icon(Icons.info_outline, color: Colors.orange),
                                SizedBox(width: 8),
                                Text(
                                  'Tubo Information',
                                  style: TextStyle(
                                    fontSize: 18,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ],
                            ),
                            const SizedBox(height: 16),
                            _buildTaxInfoRow(
                              'Current Tubo',
                              '₱${_tuboAmount.toStringAsFixed(2)}',
                            ),
                            _buildTaxInfoRow(
                              'Tubo Method',
                              _tuboInclusive
                                  ? 'Tubo Inclusive'
                                  : 'Tubo Added on Top',
                            ),
                            _buildTaxInfoRow(
                              'Tubo Application',
                              _tuboInclusive
                                  ? 'Included in price'
                                  : 'Added on top of cost',
                            ),
                            _buildTaxInfoRow(
                              'Receipt Display',
                              'Profit shown via tubo settings',
                            ),
                          ],
                        ),
                      ),
                    ),

                    if (_error != null) ...[
                      const SizedBox(height: 16),
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.red.withValues(alpha: 0.1),
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(
                            color: Colors.red.withValues(alpha: 0.3),
                          ),
                        ),
                        child: Row(
                          children: [
                            const Icon(
                              Icons.error,
                              color: Colors.red,
                              size: 20,
                            ),
                            const SizedBox(width: 8),
                            Expanded(
                              child: Text(
                                _error!,
                                style: const TextStyle(color: Colors.red),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],

                    const SizedBox(height: 24),
                    SizedBox(
                      width: double.infinity,
                      child: ElevatedButton(
                        onPressed: _isLoading ? null : _saveTaxSettings,
                        style: ElevatedButton.styleFrom(
                          padding: const EdgeInsets.symmetric(vertical: 16),
                        ),
                        child: _isLoading
                            ? const SizedBox(
                                height: 20,
                                width: 20,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                ),
                              )
                            : const Text(
                                'Save Markup Settings',
                                style: TextStyle(fontSize: 16),
                              ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
    );
  }

  Widget _buildTaxInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(label, style: const TextStyle(fontWeight: FontWeight.w500)),
          const SizedBox(height: 2),
          Text(
            value,
            style: TextStyle(
              color: Colors.grey[600],
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\settings\components\user_management_screen.dart
â•‘ SIZE: 26.22 KB
â•‘ MODIFIED: 09/28/2025 12:30:21
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/models/app_user.dart';
import 'package:prostock/models/user_role.dart';
import 'package:prostock/providers/auth_provider.dart';
import 'package:prostock/screens/settings/components/app_update_widget.dart';
import 'package:prostock/screens/settings/components/create_user_dialog.dart';

class UserManagementScreen extends StatefulWidget {
  const UserManagementScreen({super.key});

  @override
  State<UserManagementScreen> createState() => _UserManagementScreenState();
}

class _UserManagementScreenState extends State<UserManagementScreen> {
  bool _showInactiveUsers = false;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('User Management'),
        actions: [
          Consumer<AuthProvider>(
            builder: (context, authProvider, child) {
              if (authProvider.isAdmin) {
                return IconButton(
                  icon: const Icon(Icons.person_add),
                  onPressed: () => _showCreateUserDialog(context),
                  tooltip: 'Add New User',
                );
              }
              return const SizedBox.shrink();
            },
          ),
        ],
      ),
      body: Consumer<AuthProvider>(
        builder: (context, authProvider, child) {
          // SECURITY CHECK - Only admins can access user management
          if (!authProvider.isAdmin) {
            return const Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.lock_outline, size: 64, color: Colors.grey),
                  SizedBox(height: 16),
                  Text(
                    'Access Denied',
                    style: TextStyle(
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                      color: Colors.grey,
                    ),
                  ),
                  SizedBox(height: 8),
                  Text(
                    'You do not have permission to access this page.',
                    style: TextStyle(fontSize: 16, color: Colors.grey),
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            );
          }

          return SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      const Text(
                        'User Accounts',
                        style: TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Row(
                        children: [
                          Switch(
                            value: _showInactiveUsers,
                            onChanged: (value) {
                              setState(() {
                                _showInactiveUsers = value;
                              });
                            },
                          ),
                          const Text('Show Inactive'),
                        ],
                      ),
                    ],
                  ),
                  const SizedBox(height: 10),
                  StreamBuilder<List<AppUser>>(
                    stream: authProvider.getAllUsers(),
                    builder: (context, snapshot) {
                      if (snapshot.connectionState == ConnectionState.waiting) {
                        return const Center(child: CircularProgressIndicator());
                      }
                      if (snapshot.hasError) {
                        return Center(child: Text('Error: ${snapshot.error}'));
                      }
                      if (!snapshot.hasData || snapshot.data!.isEmpty) {
                        return const Center(child: Text('No users found.'));
                      }

                      final allUsers = snapshot.data!;
                      final users = _showInactiveUsers
                          ? allUsers
                          : allUsers.where((user) => user.isActive).toList();

                      return ListView.builder(
                        shrinkWrap: true,
                        physics: const NeverScrollableScrollPhysics(),
                        itemCount: users.length,
                        itemBuilder: (context, index) {
                          final user = users[index];
                          final isCurrentUser =
                              user.id == authProvider.currentUser?.id;
                          final isLastAdmin =
                              user.role == UserRole.admin &&
                              allUsers
                                      .where(
                                        (u) =>
                                            u.role == UserRole.admin &&
                                            u.isActive,
                                      )
                                      .length ==
                                  1;

                          return Card(
                            margin: const EdgeInsets.only(bottom: 8),
                            color: !user.isActive ? Colors.grey[100] : null,
                            child: ListTile(
                              leading: CircleAvatar(
                                backgroundColor: user.role == UserRole.admin
                                    ? Colors.blue
                                    : Colors.grey,
                                child: Icon(
                                  user.role == UserRole.admin
                                      ? Icons.admin_panel_settings
                                      : Icons.person,
                                  color: Colors.white,
                                ),
                              ),
                              title: Text(
                                user.username,
                                style: const TextStyle(
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                              subtitle: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(user.email),
                                  Row(
                                    children: [
                                      Container(
                                        padding: const EdgeInsets.symmetric(
                                          horizontal: 8,
                                          vertical: 2,
                                        ),
                                        decoration: BoxDecoration(
                                          color: user.role == UserRole.admin
                                              ? Colors.blue.withValues(
                                                  alpha: 0.1,
                                                )
                                              : Colors.grey.withValues(
                                                  alpha: 0.1,
                                                ),
                                          borderRadius: BorderRadius.circular(
                                            12,
                                          ),
                                        ),
                                        child: Text(
                                          user.role.displayName,
                                          style: TextStyle(
                                            fontSize: 12,
                                            color: user.role == UserRole.admin
                                                ? Colors.blue
                                                : Colors.grey[600],
                                            fontWeight: FontWeight.w500,
                                          ),
                                        ),
                                      ),
                                      if (isCurrentUser) ...[
                                        const SizedBox(width: 8),
                                        Container(
                                          padding: const EdgeInsets.symmetric(
                                            horizontal: 8,
                                            vertical: 2,
                                          ),
                                          decoration: BoxDecoration(
                                            color: Colors.green.withValues(
                                              alpha: 0.1,
                                            ),
                                            borderRadius: BorderRadius.circular(
                                              12,
                                            ),
                                          ),
                                          child: const Text(
                                            'You',
                                            style: TextStyle(
                                              fontSize: 12,
                                              color: Colors.green,
                                              fontWeight: FontWeight.w500,
                                            ),
                                          ),
                                        ),
                                      ],
                                      if (!user.isActive) ...[
                                        const SizedBox(width: 8),
                                        Container(
                                          padding: const EdgeInsets.symmetric(
                                            horizontal: 8,
                                            vertical: 2,
                                          ),
                                          decoration: BoxDecoration(
                                            color: Colors.red.withValues(
                                              alpha: 0.1,
                                            ),
                                            borderRadius: BorderRadius.circular(
                                              12,
                                            ),
                                          ),
                                          child: const Text(
                                            'Inactive',
                                            style: TextStyle(
                                              fontSize: 12,
                                              color: Colors.red,
                                              fontWeight: FontWeight.w500,
                                            ),
                                          ),
                                        ),
                                      ],
                                    ],
                                  ),
                                ],
                              ),
                              trailing: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  if (!isCurrentUser) ...[
                                    if (user.isActive) ...[
                                      IconButton(
                                        icon: const Icon(Icons.edit),
                                        onPressed: () =>
                                            _editUserRole(context, user),
                                        tooltip: 'Edit Role',
                                      ),
                                      IconButton(
                                        icon: Icon(
                                          isLastAdmin
                                              ? Icons.block
                                              : Icons.delete,
                                          color: isLastAdmin
                                              ? Colors.grey
                                              : null,
                                        ),
                                        onPressed: isLastAdmin
                                            ? null
                                            : () => _deleteUser(context, user),
                                        tooltip: isLastAdmin
                                            ? 'Cannot delete last admin'
                                            : 'Deactivate User',
                                      ),
                                    ] else ...[
                                      IconButton(
                                        icon: const Icon(Icons.restore),
                                        onPressed: () =>
                                            _restoreUser(context, user),
                                        tooltip: 'Restore User',
                                      ),
                                      IconButton(
                                        icon: const Icon(Icons.delete_forever),
                                        onPressed: () =>
                                            _hardDeleteUser(context, user),
                                        tooltip: 'Permanently Delete',
                                      ),
                                    ],
                                  ],
                                  IconButton(
                                    icon: const Icon(Icons.vpn_key),
                                    onPressed: () =>
                                        _resetPassword(context, user),
                                    tooltip: 'Reset Password',
                                  ),
                                ],
                              ),
                            ),
                          );
                        },
                      );
                    },
                  ),
                  const SizedBox(height: 20),
                  const AppUpdateWidget(),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  void _editUserRole(BuildContext context, AppUser user) async {
    UserRole selectedRole = user.role;
    final authProvider = context.read<AuthProvider>();
    final scaffoldMessenger = ScaffoldMessenger.of(context);

    final result = await showDialog<bool>(
      context: context,
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setState) {
            return AlertDialog(
              title: Text('Edit Role for ${user.username}'),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    'Current role: ${user.role.displayName}',
                    style: const TextStyle(fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 16),
                  DropdownButtonFormField<UserRole>(
                    initialValue: selectedRole,
                    decoration: const InputDecoration(
                      labelText: 'Select New Role',
                      border: OutlineInputBorder(),
                    ),
                    onChanged: (UserRole? newValue) {
                      if (newValue != null) {
                        setState(() {
                          selectedRole = newValue;
                        });
                      }
                    },
                    items: UserRole.values.map((UserRole role) {
                      return DropdownMenuItem<UserRole>(
                        value: role,
                        child: Text(role.displayName),
                      );
                    }).toList(),
                  ),
                ],
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(false),
                  child: const Text('Cancel'),
                ),
                ElevatedButton(
                  onPressed: selectedRole != user.role
                      ? () => Navigator.of(context).pop(true)
                      : null,
                  child: const Text('Update Role'),
                ),
              ],
            );
          },
        );
      },
    );

    if (result == true && selectedRole != user.role) {
      final success = await authProvider.updateUserRole(user, selectedRole);

      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(
              success
                  ? 'User role updated successfully'
                  : 'Failed to update user role',
            ),
            backgroundColor: success ? Colors.green : Colors.red,
          ),
        );
      }
    }
  }

  void _deleteUser(BuildContext context, AppUser user) async {
    final authProvider = context.read<AuthProvider>();
    final scaffoldMessenger = ScaffoldMessenger.of(context);

    final result = await showDialog<bool>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Delete User'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('Are you sure you want to delete this user?'),
              const SizedBox(height: 8),
              Text(
                'Username: ${user.username}',
                style: const TextStyle(fontWeight: FontWeight.bold),
              ),
              Text('Email: ${user.email}'),
              Text('Role: ${user.role.displayName}'),
              const SizedBox(height: 16),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.red.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.red.withValues(alpha: 0.3)),
                ),
                child: const Row(
                  children: [
                    Icon(Icons.warning, color: Colors.red, size: 20),
                    SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        'This action cannot be undone!',
                        style: TextStyle(
                          color: Colors.red,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () => Navigator.of(context).pop(true),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.red,
                foregroundColor: Colors.white,
              ),
              child: const Text('Delete User'),
            ),
          ],
        );
      },
    );

    if (result == true) {
      final success = await authProvider.deleteUser(user);

      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(
              success ? 'User deleted successfully' : 'Failed to delete user',
            ),
            backgroundColor: success ? Colors.green : Colors.red,
          ),
        );
      }
    }
  }

  void _resetPassword(BuildContext context, AppUser user) async {
    final authProvider = context.read<AuthProvider>();
    final scaffoldMessenger = ScaffoldMessenger.of(context);

    final result = await showDialog<bool>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Reset Password'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('Send password reset email to:'),
              const SizedBox(height: 8),
              Text(
                user.email,
                style: const TextStyle(
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                ),
              ),
              const SizedBox(height: 16),
              const Text(
                'The user will receive an email with instructions to reset their password.',
                style: TextStyle(color: Colors.grey),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: const Text('Send Reset Email'),
            ),
          ],
        );
      },
    );

    if (result == true) {
      final error = await authProvider.sendPasswordResetEmail(user.email);

      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(
              error == null
                  ? 'Password reset email sent to ${user.email}'
                  : 'Failed to send password reset email: $error',
            ),
            backgroundColor: error == null ? Colors.green : Colors.red,
          ),
        );
      }
    }
  }

  void _restoreUser(BuildContext context, AppUser user) async {
    final authProvider = context.read<AuthProvider>();
    final scaffoldMessenger = ScaffoldMessenger.of(context);

    final result = await showDialog<bool>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Restore User'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('Are you sure you want to restore this user?'),
              const SizedBox(height: 8),
              Text(
                'Username: ${user.username}',
                style: const TextStyle(fontWeight: FontWeight.bold),
              ),
              Text('Email: ${user.email}'),
              Text('Role: ${user.role.displayName}'),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () => Navigator.of(context).pop(true),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.green,
                foregroundColor: Colors.white,
              ),
              child: const Text('Restore User'),
            ),
          ],
        );
      },
    );

    if (result == true) {
      final success = await authProvider.restoreUser(user);

      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(
              success ? 'User restored successfully' : 'Failed to restore user',
            ),
            backgroundColor: success ? Colors.green : Colors.red,
          ),
        );
      }
    }
  }

  void _hardDeleteUser(BuildContext context, AppUser user) async {
    final authProvider = context.read<AuthProvider>();
    final scaffoldMessenger = ScaffoldMessenger.of(context);

    final result = await showDialog<bool>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Permanently Delete User'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('Are you sure you want to PERMANENTLY delete this user?'),
              const SizedBox(height: 8),
              Text(
                'Username: ${user.username}',
                style: const TextStyle(fontWeight: FontWeight.bold),
              ),
              Text('Email: ${user.email}'),
              Text('Role: ${user.role.displayName}'),
              const SizedBox(height: 16),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.red.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.red.withValues(alpha: 0.3)),
                ),
                child: const Row(
                  children: [
                    Icon(Icons.warning, color: Colors.red, size: 20),
                    SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        'This action is IRREVERSIBLE! The user will be permanently removed from the system.',
                        style: TextStyle(
                          color: Colors.red,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () => Navigator.of(context).pop(true),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.red,
                foregroundColor: Colors.white,
              ),
              child: const Text('Delete Forever'),
            ),
          ],
        );
      },
    );

    if (result == true) {
      final success = await authProvider.hardDeleteUser(user);

      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(
              success ? 'User permanently deleted' : 'Failed to delete user',
            ),
            backgroundColor: success ? Colors.green : Colors.red,
          ),
        );
      }
    }
  }

  void _showCreateUserDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => const CreateUserDialog(),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\user\user_profile.dart
â•‘ SIZE: 9.96 KB
â•‘ MODIFIED: 10/26/2025 13:05:50
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/providers/auth_provider.dart';
import 'package:prostock/models/user_role.dart';
import 'package:prostock/providers/theme_provider.dart';
import 'package:prostock/screens/settings/components/change_password_screen.dart';
import 'package:prostock/screens/user/profile/components/profile_action.dart';

class UserProfile extends StatelessWidget {
  const UserProfile({super.key});

  @override
  Widget build(BuildContext context) {
    return Consumer<AuthProvider>(
      builder: (context, authProvider, child) {
        return SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            children: [
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(24),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.surface,
                  borderRadius: BorderRadius.circular(16),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withAlpha(26),
                      blurRadius: 8,
                      offset: const Offset(0, 2),
                    ),
                  ],
                ),
                child: Column(
                  children: [
                    CircleAvatar(
                      radius: 40,
                      backgroundColor:
                          Theme.of(context).brightness == Brightness.dark
                          ? Colors.teal.withValues(alpha: 0.3)
                          : Colors.teal[100],
                      child: Icon(
                        Icons.person,
                        size: 40,
                        color: Theme.of(context).brightness == Brightness.dark
                            ? Colors.teal[200]
                            : Colors.teal[600],
                      ),
                    ),
                    const SizedBox(height: 16),
                    Text(
                      authProvider.username ?? 'User',
                      style: const TextStyle(
                        fontSize: 24,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 12,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color:
                            (authProvider.userRole ?? UserRole.user) ==
                                UserRole.admin
                            ? Theme.of(context).brightness == Brightness.dark
                                  ? Colors.blue.withValues(alpha: 0.2)
                                  : Colors.blue.withValues(alpha: 0.1)
                            : Theme.of(context).brightness == Brightness.dark
                            ? Colors.grey.withValues(alpha: 0.2)
                            : Colors.grey.withValues(alpha: 0.1),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        (authProvider.userRole ?? UserRole.user).displayName,
                        style: TextStyle(
                          color:
                              (authProvider.userRole ?? UserRole.user) ==
                                  UserRole.admin
                              ? Theme.of(context).brightness == Brightness.dark
                                    ? Colors.blue[300]
                                    : Colors.blue
                              : Theme.of(context).brightness == Brightness.dark
                              ? Colors.grey[400]
                              : Colors.grey[600],
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 24),
              ProfileAction(
                title: 'Change Password',
                subtitle: 'Update your account password',
                icon: Icons.lock,
                onTap: () => _showChangePasswordDialog(context),
              ),
              const SizedBox(height: 12),
              ProfileAction(
                title: 'Appearance',
                subtitle: 'Customize app theme',
                icon: Icons.palette_outlined,
                onTap: () => _showAppearanceDialog(context),
              ),
              const SizedBox(height: 12),
              ProfileAction(
                title: 'Help & Support',
                subtitle: 'Get help with using the app',
                icon: Icons.help,
                onTap: () => _showHelpDialog(context),
              ),
              const SizedBox(height: 24),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton.icon(
                  onPressed: () async {
                    await authProvider.logout();
                    if (context.mounted) {
                      Navigator.of(context).pushReplacementNamed('/login');
                    }
                  },
                  icon: const Icon(Icons.logout),
                  label: const Text('Logout'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.red,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 16),
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  void _showChangePasswordDialog(BuildContext context) {
    Navigator.of(context).push(
      MaterialPageRoute(builder: (context) => const ChangePasswordScreen()),
    );
  }

  void _showHelpDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Help & Support'),
        content: const Text(
          'For assistance, please contact your system administrator.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  void _showAppearanceDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) {
        final themeProvider = Provider.of<ThemeProvider>(
          context,
          listen: false,
        );
        return AlertDialog(
          title: const Text('Appearance'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              _buildThemeOption(
                context: context,
                title: 'Light Mode',
                icon: Icons.light_mode,
                isSelected: themeProvider.themeMode == ThemeMode.light,
                onTap: () {
                  themeProvider.setThemeMode(ThemeMode.light);
                  Navigator.of(context).pop();
                },
              ),
              const SizedBox(height: 8),
              _buildThemeOption(
                context: context,
                title: 'Dark Mode',
                icon: Icons.dark_mode,
                isSelected: themeProvider.themeMode == ThemeMode.dark,
                onTap: () {
                  themeProvider.setThemeMode(ThemeMode.dark);
                  Navigator.of(context).pop();
                },
              ),
              const SizedBox(height: 8),
              _buildThemeOption(
                context: context,
                title: 'System Default',
                icon: Icons.brightness_auto,
                isSelected: themeProvider.themeMode == ThemeMode.system,
                onTap: () {
                  themeProvider.setThemeMode(ThemeMode.system);
                  Navigator.of(context).pop();
                },
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('Cancel'),
            ),
          ],
        );
      },
    );
  }

  Widget _buildThemeOption({
    required BuildContext context,
    required String title,
    required IconData icon,
    required bool isSelected,
    required VoidCallback onTap,
  }) {
    final isDarkMode = Theme.of(context).brightness == Brightness.dark;
    final primaryColor = Theme.of(context).primaryColor;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(8),
          color: isSelected
              ? primaryColor.withValues(alpha: isDarkMode ? 0.2 : 0.1)
              : isDarkMode
              ? Colors.grey[800]
              : null,
          border: isSelected
              ? Border.all(color: primaryColor)
              : Border.all(
                  color: isDarkMode
                      ? Colors.grey[700]!.withValues(alpha: 0.5)
                      : Colors.grey.withValues(alpha: 0.2),
                ),
        ),
        child: Row(
          children: [
            Icon(icon, color: isSelected ? primaryColor : null),
            const SizedBox(width: 16),
            Text(
              title,
              style: TextStyle(
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                color: isSelected ? primaryColor : null,
              ),
            ),
            const Spacer(),
            if (isSelected) Icon(Icons.check_circle, color: primaryColor),
          ],
        ),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\user\user_screen.dart
â•‘ SIZE: 2.37 KB
â•‘ MODIFIED: 10/04/2025 04:57:01
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/screens/user/dashboard/user_dashboard.dart';
import 'package:prostock/screens/user/stock/stock_management.dart';
import 'package:prostock/screens/user/user_profile.dart';
import '../../providers/auth_provider.dart';
import '../../widgets/sync_status_indicator.dart';
import '../pos/pos_screen.dart';

class UserScreen extends StatefulWidget {
  const UserScreen({super.key});

  @override
  State<UserScreen> createState() => _UserScreenState();
}

class _UserScreenState extends State<UserScreen> {
  int _selectedIndex = 0;

  void changeTab(int index) {
    setState(() {
      _selectedIndex = index;
    });
  }

  List<Widget> get _screens => [
    UserDashboard(onNavigateToTab: (index) => changeTab(index)),
    const POSScreen(),
    const StockManagement(),
    const UserProfile(),
  ];

  @override
  Widget build(BuildContext context) {
    final authProvider = context.watch<AuthProvider>();

    return Scaffold(
      backgroundColor: Colors.grey[50],
      appBar: AppBar(
        title: Text('Welcome, ${authProvider.username}'),
        backgroundColor: Colors.teal[600],
        foregroundColor: Colors.white,
        elevation: 0,
        actions: [
          const SyncStatusIndicator(color: Colors.white),
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () async {
              await authProvider.logout();
              if (context.mounted) {
                Navigator.of(context).pushReplacementNamed('/login');
              }
            },
          ),
        ],
      ),
      body: _screens[_selectedIndex],
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _selectedIndex,
        onTap: (index) => setState(() => _selectedIndex = index),
        type: BottomNavigationBarType.fixed,
        selectedItemColor: Colors.teal[600],
        unselectedItemColor: Colors.grey[600],
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.dashboard),
            label: 'Dashboard',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.point_of_sale),
            label: 'POS',
          ),
          BottomNavigationBarItem(icon: Icon(Icons.inventory), label: 'Stock'),
          BottomNavigationBarItem(icon: Icon(Icons.person), label: 'Profile'),
        ],
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\user\dashboard\user_dashboard.dart
â•‘ SIZE: 6.53 KB
â•‘ MODIFIED: 10/04/2025 00:09:02
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/providers/auth_provider.dart';
import 'package:prostock/screens/user/dashboard/components/action_card.dart';
import 'package:prostock/screens/user/dashboard/components/activity_item.dart';
import 'package:prostock/services/firestore/activity_service.dart';
import 'package:prostock/widgets/barcode_scanner_widget.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

class UserDashboard extends StatelessWidget {
  final Function(int) onNavigateToTab;

  const UserDashboard({super.key, required this.onNavigateToTab});

  @override
  Widget build(BuildContext context) {
    final authProvider = context.watch<AuthProvider>();
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(20),
            decoration: BoxDecoration(
              gradient: LinearGradient(
                colors: [Colors.teal[600]!, Colors.teal[400]!],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
              ),
              borderRadius: BorderRadius.circular(16),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Quick Actions',
                  style: TextStyle(
                    color: Theme.of(context).colorScheme.onSurface,
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  'Make sales and manage inventory',
                  style: TextStyle(
                    color: Theme.of(
                      context,
                    ).colorScheme.onSurface.withAlpha(230),
                    fontSize: 16,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 24),
          Row(
            children: [
              Expanded(
                child: ActionCard(
                  title: 'Make Sale',
                  subtitle: 'Process customer transactions',
                  icon: Icons.point_of_sale,
                  color: Colors.blue,
                  onTap: () => onNavigateToTab(1),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: ActionCard(
                  title: 'Scan Barcode',
                  subtitle: 'Scan items for stock management',
                  icon: Icons.qr_code_scanner,
                  color: Colors.green,
                  onTap: () => onNavigateToTab(2),
                ),
              ),
            ],
          ),
          if (authProvider.isAdmin) ...[
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: ActionCard(
                    title: 'Receive Stock',
                    subtitle: 'Scan items to add to inventory',
                    icon: Icons.add_box,
                    color: Colors.green,
                    onTap: () =>
                        _openBarcodeScanner(context, ScannerMode.receiveStock),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: ActionCard(
                    title: 'Remove Stock',
                    subtitle: 'Scan items to remove from inventory',
                    icon: Icons.remove_circle,
                    color: Colors.red,
                    onTap: () =>
                        _openBarcodeScanner(context, ScannerMode.removeStock),
                  ),
                ),
              ],
            ),
          ],
          const SizedBox(height: 24),
          const Text(
            'Your Recent Activity',
            style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 16),
          Consumer<AuthProvider>(
            builder: (context, authProvider, child) {
              return FutureBuilder<List<Map<String, dynamic>>>(
                future: _getUserRecentActivity(authProvider.currentUser?.id),
                builder: (context, snapshot) {
                  if (snapshot.connectionState == ConnectionState.waiting) {
                    return const Center(child: CircularProgressIndicator());
                  }

                  if (!snapshot.hasData || snapshot.data!.isEmpty) {
                    return Container(
                      padding: const EdgeInsets.all(32),
                      decoration: BoxDecoration(
                        color: Colors.white,
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: const Center(
                        child: Column(
                          children: [
                            Icon(Icons.history, size: 48, color: Colors.grey),
                            SizedBox(height: 16),
                            Text(
                              'No recent activity',
                              style: TextStyle(
                                fontSize: 16,
                                color: Colors.grey,
                              ),
                            ),
                          ],
                        ),
                      ),
                    );
                  }

                  final activities = snapshot.data!.take(5).toList();
                  return Column(
                    children: activities
                        .map((activity) => ActivityItem(activity: activity))
                        .toList(),
                  );
                },
              );
            },
          ),
        ],
      ),
    );
  }

  Future<List<Map<String, dynamic>>> _getUserRecentActivity(
    String? userId,
  ) async {
    if (userId == null) return [];

    try {
      final activityService = ActivityService(FirebaseFirestore.instance);
      final activities = await activityService.getUserActivitiesPaginated(
        role: 'user',
        limit: 10,
      );
      return activities.items.map((activity) => activity.toMap()).toList();
    } catch (e) {
      return [];
    }
  }

  void _openBarcodeScanner(BuildContext context, ScannerMode mode) {
    Navigator.of(context).push(
      MaterialPageRoute(builder: (context) => BarcodeScannerWidget(mode: mode)),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\user\dashboard\components\action_card.dart
â•‘ SIZE: 1.64 KB
â•‘ MODIFIED: 10/04/2025 00:09:02
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';

class ActionCard extends StatelessWidget {
  final String title;
  final String subtitle;
  final IconData icon;
  final Color color;
  final VoidCallback onTap;

  const ActionCard({
    super.key,
    required this.title,
    required this.subtitle,
    required this.icon,
    required this.color,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.all(20),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withAlpha(26),
              blurRadius: 8,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Column(
          children: [
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: color.withAlpha(26),
                borderRadius: BorderRadius.circular(12),
              ),
              child: Icon(icon, color: color, size: 32),
            ),
            const SizedBox(height: 16),
            Text(
              title,
              style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              subtitle,
              style: TextStyle(fontSize: 12, color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\user\dashboard\components\activity_item.dart
â•‘ SIZE: 2.91 KB
â•‘ MODIFIED: 10/04/2025 00:09:02
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';

class ActivityItem extends StatelessWidget {
  final Map<String, dynamic> activity;

  const ActivityItem({super.key, required this.activity});

  @override
  Widget build(BuildContext context) {
    final timestamp = DateTime.parse(activity['timestamp']);
    final timeAgo = _getTimeAgo(timestamp);

    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey[200]!),
      ),
      child: Row(
        children: [
          CircleAvatar(
            backgroundColor: _getActionColor(activity['action']),
            radius: 16,
            child: Icon(
              _getActionIcon(activity['action']),
              color: Theme.of(context).colorScheme.onSurface,
              size: 16,
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  activity['action'].toString().replaceAll('_', ' '),
                  style: const TextStyle(
                    fontWeight: FontWeight.w500,
                    fontSize: 14,
                  ),
                ),
                if (activity['product_name'] != null)
                  Text(
                    activity['product_name'],
                    style: TextStyle(color: Colors.grey[600], fontSize: 12),
                  ),
              ],
            ),
          ),
          Text(
            timeAgo,
            style: TextStyle(color: Colors.grey[500], fontSize: 11),
          ),
        ],
      ),
    );
  }

  Color _getActionColor(String action) {
    switch (action.toUpperCase()) {
      case 'STOCK_RECEIVED':
        return Colors.green;
      case 'STOCK_REMOVED':
        return Colors.red;
      case 'PRODUCT_SCANNED':
        return Colors.blue;
      case 'SALE_MADE':
        return Colors.blue;
      default:
        return Colors.grey;
    }
  }

  IconData _getActionIcon(String action) {
    switch (action.toUpperCase()) {
      case 'STOCK_RECEIVED':
        return Icons.add_box;
      case 'STOCK_REMOVED':
        return Icons.remove_circle;
      case 'PRODUCT_SCANNED':
        return Icons.qr_code_scanner;
      case 'SALE_MADE':
        return Icons.point_of_sale;
      default:
        return Icons.help_outline;
    }
  }

  String _getTimeAgo(DateTime timestamp) {
    final now = DateTime.now();
    final difference = now.difference(timestamp);

    if (difference.inDays > 0) {
      return '${difference.inDays}d ago';
    } else if (difference.inHours > 0) {
      return '${difference.inHours}h ago';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes}m ago';
    } else {
      return 'Now';
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\user\profile\components\profile_action.dart
â•‘ SIZE: 2.27 KB
â•‘ MODIFIED: 10/26/2025 13:07:29
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';

class ProfileAction extends StatelessWidget {
  final String title;
  final String subtitle;
  final IconData icon;
  final VoidCallback onTap;

  const ProfileAction({
    super.key,
    required this.title,
    required this.subtitle,
    required this.icon,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final isDarkMode = Theme.of(context).brightness == Brightness.dark;

    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Theme.of(context).colorScheme.surface,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: isDarkMode ? Colors.grey[700]! : Colors.grey[200]!,
          ),
        ),
        child: Row(
          children: [
            Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: isDarkMode
                    ? Colors.teal.withValues(alpha: 0.2)
                    : Colors.teal[50],
                borderRadius: BorderRadius.circular(8),
              ),
              child: Icon(
                icon,
                color: isDarkMode ? Colors.teal[200] : Colors.teal[600],
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    title,
                    style: const TextStyle(
                      fontWeight: FontWeight.w500,
                      fontSize: 16,
                    ),
                  ),
                  Text(
                    subtitle,
                    style: TextStyle(
                      color: isDarkMode ? Colors.grey[400] : Colors.grey[600],
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
            ),
            Icon(
              Icons.chevron_right,
              color: isDarkMode ? Colors.grey[500] : Colors.grey[400],
            ),
          ],
        ),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\user\stock\stock_management.dart
â•‘ SIZE: 4.9 KB
â•‘ MODIFIED: 08/29/2025 21:05:07
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/providers/auth_provider.dart';
import 'package:prostock/providers/inventory_provider.dart';
import 'package:prostock/screens/user/stock/components/product_card.dart';
import 'package:prostock/widgets/barcode_scanner_widget.dart';

class StockManagement extends StatefulWidget {
  const StockManagement({super.key});

  @override
  State<StockManagement> createState() => _StockManagementState();
}

class _StockManagementState extends State<StockManagement> {
  String _searchQuery = '';

  @override
  Widget build(BuildContext context) {
    final authProvider = context.watch<AuthProvider>();
    return Column(
      children: [
        Container(
          padding: const EdgeInsets.all(16),
          child: Column(
            children: [
              TextField(
                decoration: InputDecoration(
                  hintText: 'Search products...',
                  prefixIcon: const Icon(Icons.search),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                  filled: true,
                  fillColor: Colors.white,
                ),
                onChanged: (value) {
                  setState(() => _searchQuery = value);
                },
              ),
              if (authProvider.isAdmin) ...[
                const SizedBox(height: 16),
                Row(
                  children: [
                    Expanded(
                      child: ElevatedButton.icon(
                        onPressed: () => _openBarcodeScanner(
                          context,
                          ScannerMode.receiveStock,
                        ),
                        icon: const Icon(Icons.add_box),
                        label: const Text('Receive Stock'),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.green,
                          foregroundColor: Colors.white,
                          padding: const EdgeInsets.symmetric(vertical: 12),
                        ),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: ElevatedButton.icon(
                        onPressed: () => _openBarcodeScanner(
                          context,
                          ScannerMode.removeStock,
                        ),
                        icon: const Icon(Icons.remove_circle),
                        label: const Text('Remove Stock'),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.red,
                          foregroundColor: Colors.white,
                          padding: const EdgeInsets.symmetric(vertical: 12),
                        ),
                      ),
                    ),
                  ],
                ),
              ],
            ],
          ),
        ),
        Expanded(
          child: Consumer<InventoryProvider>(
            builder: (context, inventoryProvider, child) {
              final products = _searchQuery.isEmpty
                  ? inventoryProvider.products
                  : inventoryProvider.products
                        .where(
                          (product) =>
                              product.name.toLowerCase().contains(
                                _searchQuery.toLowerCase(),
                              ) ||
                              (product.barcode?.toLowerCase().contains(
                                    _searchQuery.toLowerCase(),
                                  ) ??
                                  false),
                        )
                        .toList();

              if (products.isEmpty) {
                return const Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.inventory_2, size: 64, color: Colors.grey),
                      SizedBox(height: 16),
                      Text(
                        'No products found',
                        style: TextStyle(fontSize: 18, color: Colors.grey),
                      ),
                    ],
                  ),
                );
              }

              return ListView.builder(
                padding: const EdgeInsets.symmetric(horizontal: 16),
                itemCount: products.length,
                itemBuilder: (context, index) {
                  final product = products[index];
                  return ProductCard(product: product);
                },
              );
            },
          ),
        ),
      ],
    );
  }

  void _openBarcodeScanner(BuildContext context, ScannerMode mode) {
    Navigator.of(context).push(
      MaterialPageRoute(builder: (context) => BarcodeScannerWidget(mode: mode)),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\screens\user\stock\components\product_card.dart
â•‘ SIZE: 4.27 KB
â•‘ MODIFIED: 10/02/2025 12:23:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/models/product.dart';
import 'package:prostock/utils/currency_utils.dart';
import 'package:prostock/services/tax_service.dart';

class ProductCard extends StatelessWidget {
  final Product product;

  const ProductCard({super.key, required this.product});

  @override
  Widget build(BuildContext context) {
    final isLowStock = product.stock <= product.minStock;

    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: [
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: isLowStock ? Colors.red[50] : Colors.teal[50],
                borderRadius: BorderRadius.circular(8),
              ),
              child: Icon(
                Icons.inventory_2,
                color: isLowStock ? Colors.red : Colors.teal,
                size: 24,
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    product.name,
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 16,
                    ),
                  ),
                  if (product.barcode != null) ...[
                    const SizedBox(height: 4),
                    Text(
                      'Barcode: ${product.barcode}',
                      style: TextStyle(color: Colors.grey[600], fontSize: 12),
                    ),
                  ],
                  const SizedBox(height: 4),
                  FutureBuilder<double>(
                    future: TaxService.calculateSellingPriceWithRule(
                      product.cost,
                      productId: product.id,
                      categoryName: product.category,
                    ),
                    builder: (context, snapshot) {
                      if (snapshot.hasData) {
                        return Text(
                          CurrencyUtils.formatCurrency(snapshot.data!),
                          style: TextStyle(
                            color: Colors.teal[600],
                            fontWeight: FontWeight.w500,
                          ),
                        );
                      }
                      return Text(
                        'Calculating...',
                        style: TextStyle(
                          color: Colors.teal[600],
                          fontWeight: FontWeight.w500,
                        ),
                      );
                    },
                  ),
                ],
              ),
            ),
            Column(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 8,
                    vertical: 4,
                  ),
                  decoration: BoxDecoration(
                    color: isLowStock ? Colors.red[100] : Colors.grey[100],
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    'Stock: ${product.stock}',
                    style: TextStyle(
                      color: isLowStock ? Colors.red[700] : Colors.grey[700],
                      fontWeight: FontWeight.w500,
                      fontSize: 12,
                    ),
                  ),
                ),
                if (isLowStock) ...[
                  const SizedBox(height: 4),
                  Text(
                    'Low Stock!',
                    style: TextStyle(
                      color: Colors.red[600],
                      fontSize: 10,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ],
              ],
            ),
          ],
        ),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\background_sync_service.dart
â•‘ SIZE: 4.78 KB
â•‘ MODIFIED: 09/23/2025 11:32:40
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:developer';

import 'package:background_fetch/background_fetch.dart';
import 'package:prostock/providers/sync_failure_provider.dart';
import 'package:prostock/services/credit_check_service.dart';
import 'package:prostock/services/demand_analysis_service.dart';
import 'package:prostock/services/local_database_service.dart';
import 'package:prostock/services/notification_service.dart';
import 'package:prostock/services/offline_manager.dart';
import 'package:prostock/utils/error_logger.dart';
import 'package:prostock/models/product.dart';

const _backgroundFetchTaskId = 'com.prostock.background_fetch';

class BackgroundSyncService {
  static late OfflineManager _offlineManager;
  static late CreditCheckService _creditCheckService;
  static late DemandAnalysisService _demandService;

  static Future<void> init(
    OfflineManager offlineManager,
    CreditCheckService creditCheckService,
  ) async {
    _offlineManager = offlineManager;
    _creditCheckService = creditCheckService;
    _demandService = DemandAnalysisService(
      LocalDatabaseService.instance,
      NotificationService(),
    );
    BackgroundFetch.configure(
          BackgroundFetchConfig(
            minimumFetchInterval: 15,
            stopOnTerminate: false,
            enableHeadless: true,
            startOnBoot: true,
            requiredNetworkType: NetworkType.ANY,
          ),
          _onBackgroundFetch,
          _onBackgroundFetchTimeout,
        )
        .then((int status) {
          log('[BackgroundFetch] configure success: $status');
        })
        .catchError((e) {
          log('[BackgroundFetch] configure ERROR: $e');
        });
  }

  static void _onBackgroundFetch(String taskId) async {
    if (taskId == _backgroundFetchTaskId) {
      try {
        await _offlineManager.syncPendingOperations();
        await _creditCheckService.checkDuePaymentsAndNotify();
        // Run demand analysis once per day implicitly by BackgroundFetch cadence
        await _demandService.runDailyAndNotify();

        // Low/Out-of-stock background check
        final db = LocalDatabaseService.instance;
        final products = await db.getAllProducts();
        await _checkStockLevelsAndNotify(products);
      } catch (e, s) {
        ErrorLogger.logError(
          'Error in background fetch',
          error: e,
          stackTrace: s,
          context: 'BackgroundSyncService._onBackgroundFetch',
        );
      }
    }
    BackgroundFetch.finish(taskId);
  }

  static void _onBackgroundFetchTimeout(String taskId) {
    BackgroundFetch.finish(taskId);
  }
}

void backgroundFetchHeadlessTask(HeadlessTask task) async {
  String taskId = task.taskId;
  bool isTimeout = task.timeout;
  if (isTimeout) {
    // This task has exceeded its allowed running-time.
    // You must stop what you're doing and immediately call `BackgroundFetch.finish(taskId)`.
    BackgroundFetch.finish(taskId);
    return;
  }

  if (taskId == _backgroundFetchTaskId) {
    try {
      // This is not ideal, but we need to create a new instance of OfflineManager
      // to be able to sync in the background.
      final syncFailureProvider = SyncFailureProvider();
      final offlineManager = OfflineManager(syncFailureProvider);
      final localDatabaseService = LocalDatabaseService.instance;
      final notificationService = NotificationService();
      final creditCheckService = CreditCheckService(
        localDatabaseService,
        notificationService,
      );
      final demandService = DemandAnalysisService(
        localDatabaseService,
        notificationService,
      );
      await offlineManager.initialize();
      await offlineManager.syncPendingOperations();
      await creditCheckService.checkDuePaymentsAndNotify();
      await demandService.runDailyAndNotify();

      // Low/Out-of-stock background check in headless mode
      final products = await localDatabaseService.getAllProducts();
      await _checkStockLevelsAndNotify(products);
    } catch (e, s) {
      ErrorLogger.logError(
        'Error in background fetch headless task',
        error: e,
        stackTrace: s,
        context: 'backgroundFetchHeadlessTask',
      );
    }
  }

  BackgroundFetch.finish(taskId);
}

Future<void> _checkStockLevelsAndNotify(List<Product> products) async {
  final notificationService = NotificationService();
  for (final p in products) {
    final isOut = p.stock == 0;
    final isLow = !isOut && p.stock <= p.minStock;
    if (isOut) {
      await notificationService.showNotification(
        p.id.hashCode,
        'Out of stock',
        '${p.name} is out of stock',
        'bg_out_of_stock:${p.id}',
      );
    } else if (isLow) {
      await notificationService.showNotification(
        p.id.hashCode ^ 3,
        'Low stock',
        '${p.name} is low on stock (${p.stock} left)',
        'bg_low_stock:${p.id}',
      );
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\batch_service.dart
â•‘ SIZE: 8.2 KB
â•‘ MODIFIED: 10/25/2025 14:35:59
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:math';
import 'package:prostock/models/batch_allocation.dart';
import 'package:prostock/models/inventory_batch.dart';
import 'package:prostock/services/local_database_service.dart';
import 'package:prostock/utils/error_logger.dart';
import 'package:uuid/uuid.dart';

/// Service for managing inventory batches with FIFO logic
class BatchService {
  final LocalDatabaseService _db = LocalDatabaseService.instance;

  /// Generate a unique batch number
  String generateBatchNumber({String? productId}) {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final random = Random().nextInt(999);
    final prefix = productId != null
        ? productId.substring(0, min(4, productId.length)).toUpperCase()
        : 'BATCH';
    return '$prefix-$timestamp-$random';
  }

  /// Get all batches for a product ordered by FIFO (oldest first)
  Future<List<InventoryBatch>> getBatchesByFIFO(String productId) async {
    try {
      final maps = await _db.database.then(
        (db) => db.query(
          'inventory_batches',
          where: 'product_id = ? AND quantity_remaining > 0',
          whereArgs: [productId],
          orderBy: 'date_received ASC', // FIFO: oldest first
        ),
      );

      return maps.map((map) => InventoryBatch.fromMap(map)).toList();
    } catch (e) {
      ErrorLogger.logError(
        'Error getting batches by FIFO',
        error: e,
        context: 'BatchService.getBatchesByFIFO',
      );
      return [];
    }
  }

  /// Get all batches for a product (including depleted)
  Future<List<InventoryBatch>> getAllBatches(String productId) async {
    try {
      final maps = await _db.database.then(
        (db) => db.query(
          'inventory_batches',
          where: 'product_id = ?',
          whereArgs: [productId],
          orderBy: 'date_received DESC', // Newest first for display
        ),
      );

      return maps.map((map) => InventoryBatch.fromMap(map)).toList();
    } catch (e) {
      ErrorLogger.logError(
        'Error getting all batches',
        error: e,
        context: 'BatchService.getAllBatches',
      );
      return [];
    }
  }

  /// Allocate stock using FIFO method
  /// Returns list of batch allocations needed to fulfill the quantity
  /// Throws InsufficientStockException if not enough stock available
  Future<List<BatchAllocation>> allocateStockFIFO(
    String productId,
    int quantityNeeded,
  ) async {
    try {
      final batches = await getBatchesByFIFO(productId);

      List<BatchAllocation> allocations = [];
      int remainingQty = quantityNeeded;

      for (final batch in batches) {
        if (remainingQty <= 0) break;
        if (!batch.hasStock) continue;

        // Take from this batch
        final qtyFromBatch = min(batch.quantityRemaining, remainingQty);

        allocations.add(
          BatchAllocation(
            batchId: batch.id,
            batchNumber: batch.batchNumber,
            quantity: qtyFromBatch,
            unitCost: batch.unitCost,
            dateReceived: batch.dateReceived,
          ),
        );

        remainingQty -= qtyFromBatch;
      }

      // Check if we have enough stock
      if (remainingQty > 0) {
        final available = quantityNeeded - remainingQty;
        throw InsufficientStockException(
          message:
              'Insufficient stock. Need $quantityNeeded, only $available available',
          requested: quantityNeeded,
          available: available,
        );
      }

      return allocations;
    } catch (e) {
      if (e is InsufficientStockException) rethrow;

      ErrorLogger.logError(
        'Error allocating stock FIFO',
        error: e,
        context: 'BatchService.allocateStockFIFO',
      );
      rethrow;
    }
  }

  /// Create a new batch
  Future<InventoryBatch> createBatch({
    required String productId,
    required int quantity,
    required double unitCost,
    String? supplierId,
    String? notes,
    String? customBatchNumber,
  }) async {
    try {
      final batch = InventoryBatch(
        id: const Uuid().v4(),
        productId: productId,
        batchNumber:
            customBatchNumber ?? generateBatchNumber(productId: productId),
        quantityReceived: quantity,
        quantityRemaining: quantity,
        unitCost: unitCost,
        dateReceived: DateTime.now(),
        supplierId: supplierId,
        notes: notes,
      );

      await _db.database.then(
        (db) => db.insert('inventory_batches', batch.toMap()),
      );

      return batch;
    } catch (e) {
      ErrorLogger.logError(
        'Error creating batch',
        error: e,
        context: 'BatchService.createBatch',
      );
      rethrow;
    }
  }

  /// Reduce batch quantity (called during sales)
  Future<void> reduceBatchQuantity(String batchId, int quantity) async {
    try {
      final db = await _db.database;

      // Get current batch
      final maps = await db.query(
        'inventory_batches',
        where: 'id = ?',
        whereArgs: [batchId],
      );

      if (maps.isEmpty) {
        throw Exception('Batch not found: $batchId');
      }

      final batch = InventoryBatch.fromMap(maps.first);

      if (batch.quantityRemaining < quantity) {
        throw Exception(
          'Insufficient batch stock. Batch ${batch.batchNumber} has ${batch.quantityRemaining}, need $quantity',
        );
      }

      final newQuantity = batch.quantityRemaining - quantity;

      await db.update(
        'inventory_batches',
        {
          'quantity_remaining': newQuantity,
          'updated_at': DateTime.now().toIso8601String(),
        },
        where: 'id = ?',
        whereArgs: [batchId],
      );
    } catch (e) {
      ErrorLogger.logError(
        'Error reducing batch quantity',
        error: e,
        context: 'BatchService.reduceBatchQuantity',
      );
      rethrow;
    }
  }

  /// Get total available stock for a product across all batches
  Future<int> getTotalAvailableStock(String productId) async {
    try {
      final batches = await getBatchesByFIFO(productId);
      return batches.fold<int>(
        0,
        (sum, batch) => sum + batch.quantityRemaining,
      );
    } catch (e) {
      ErrorLogger.logError(
        'Error getting total available stock',
        error: e,
        context: 'BatchService.getTotalAvailableStock',
      );
      return 0;
    }
  }

  /// Calculate weighted average cost across all batches
  Future<double> calculateAverageCost(String productId) async {
    try {
      final batches = await getBatchesByFIFO(productId);

      if (batches.isEmpty) return 0.0;

      double totalValue = 0.0;
      int totalQuantity = 0;

      for (final batch in batches) {
        totalValue += batch.quantityRemaining * batch.unitCost;
        totalQuantity += batch.quantityRemaining;
      }

      return totalQuantity > 0 ? totalValue / totalQuantity : 0.0;
    } catch (e) {
      ErrorLogger.logError(
        'Error calculating average cost',
        error: e,
        context: 'BatchService.calculateAverageCost',
      );
      return 0.0;
    }
  }

  /// Get batch by ID
  Future<InventoryBatch?> getBatchById(String batchId) async {
    try {
      final maps = await _db.database.then(
        (db) => db.query(
          'inventory_batches',
          where: 'id = ?',
          whereArgs: [batchId],
        ),
      );

      if (maps.isEmpty) return null;
      return InventoryBatch.fromMap(maps.first);
    } catch (e) {
      ErrorLogger.logError(
        'Error getting batch by ID',
        error: e,
        context: 'BatchService.getBatchById',
      );
      return null;
    }
  }

  /// Delete a batch (only if not referenced in sales)
  Future<void> deleteBatch(String batchId) async {
    try {
      await _db.database.then(
        (db) => db.delete(
          'inventory_batches',
          where: 'id = ?',
          whereArgs: [batchId],
        ),
      );
    } catch (e) {
      ErrorLogger.logError(
        'Error deleting batch',
        error: e,
        context: 'BatchService.deleteBatch',
      );
      rethrow;
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\cloudinary_service.dart
â•‘ SIZE: 2.06 KB
â•‘ MODIFIED: 08/27/2025 07:24:45
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:developer';
import 'dart:io';
import 'package:cloudinary_public/cloudinary_public.dart';
import '../utils/error_logger.dart';

class CloudinaryService {
  static final CloudinaryService instance = CloudinaryService._init();
  CloudinaryService._init();

  static const String _cloudName = 'dnhynbh5i';

  final CloudinaryPublic _cloudinary = CloudinaryPublic(
    _cloudName,
    'ml_default', // This can be configured in your Cloudinary account
    cache: false,
  );

  Future<String?> uploadImage(File imageFile) async {
    try {
      final response = await _cloudinary.uploadFile(
        CloudinaryFile.fromFile(
          imageFile.path,
          resourceType: CloudinaryResourceType.Image,
        ),
      );
      return response.secureUrl;
    } on CloudinaryException catch (e, s) {
      ErrorLogger.logError(
        'Error uploading to Cloudinary',
        error: e,
        stackTrace: s,
        context: 'CloudinaryService.uploadImage',
        metadata: {'statusCode': e.statusCode, 'message': e.message},
      );
      return null;
    }
  }

  Future<void> deleteImage(String publicId) async {
    try {
      // The cloudinary_public package does not support image deletion directly.
      // You would typically need to make a signed API request from your backend
      // to delete images. For now, this method will be a placeholder.
      log('Deleting image with publicId: $publicId');
      // In a real app, you would make a call to your backend here.
    } catch (e, s) {
      ErrorLogger.logError(
        'Error deleting image from Cloudinary',
        error: e,
        stackTrace: s,
        context: 'CloudinaryService.deleteImage',
      );
    }
  }

  String? getPublicIdFromUrl(String imageUrl) {
    try {
      final uri = Uri.parse(imageUrl);
      final pathSegments = uri.pathSegments;
      if (pathSegments.length >= 2) {
        final publicIdWithExtension = pathSegments.last;
        final publicId = publicIdWithExtension.split('.').first;
        return publicId;
      }
      return null;
    } catch (e) {
      return null;
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\cost_history_service.dart
â•‘ SIZE: 4.22 KB
â•‘ MODIFIED: 10/04/2025 06:07:02
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:prostock/models/cost_history.dart';
import 'package:prostock/services/firestore/firestore_exception.dart';
import 'package:prostock/utils/constants.dart';

class CostHistoryService {
  final FirebaseFirestore _firestore;

  CostHistoryService(this._firestore);

  CollectionReference get costHistoryCollection =>
      _firestore.collection(AppConstants.costHistoryCollection);

  /// Insert a new cost history record
  Future<String> insertCostHistory(String productId, double cost) async {
    try {
      final costHistoryData = {
        'productId': productId,
        'cost': cost,
        'timestamp': FieldValue.serverTimestamp(),
      };

      final docRef = await costHistoryCollection.add(costHistoryData);
      return docRef.id;
    } catch (e) {
      throw FirestoreException('Failed to insert cost history: $e');
    }
  }

  /// Get cost history for a specific product
  Future<List<CostHistory>> getCostHistoryByProduct(String productId) async {
    try {
      final snapshot = await costHistoryCollection
          .where('productId', isEqualTo: productId)
          .orderBy('timestamp', descending: true)
          .get();

      return snapshot.docs.map(_costHistoryFromDocument).toList();
    } catch (e) {
      throw FirestoreException('Failed to get cost history by product: $e');
    }
  }

  /// Get cost history for multiple products
  Future<List<CostHistory>> getCostHistoryByProducts(
    List<String> productIds,
  ) async {
    try {
      if (productIds.isEmpty) return [];

      final snapshot = await costHistoryCollection
          .where('productId', whereIn: productIds)
          .orderBy('timestamp', descending: true)
          .get();

      return snapshot.docs.map(_costHistoryFromDocument).toList();
    } catch (e) {
      throw FirestoreException('Failed to get cost history by products: $e');
    }
  }

  /// Get cost history within a date range
  Future<List<CostHistory>> getCostHistoryByDateRange(
    DateTime startDate,
    DateTime endDate, {
    String? productId,
  }) async {
    try {
      Query query = costHistoryCollection
          .where(
            'timestamp',
            isGreaterThanOrEqualTo: Timestamp.fromDate(startDate),
          )
          .where('timestamp', isLessThanOrEqualTo: Timestamp.fromDate(endDate));

      if (productId != null) {
        query = query.where('productId', isEqualTo: productId);
      }

      final snapshot = await query.orderBy('timestamp', descending: true).get();
      return snapshot.docs.map(_costHistoryFromDocument).toList();
    } catch (e) {
      throw FirestoreException('Failed to get cost history by date range: $e');
    }
  }

  /// Get the cost at a specific point in time for a product
  Future<double?> getCostAtTime(String productId, DateTime timestamp) async {
    try {
      final snapshot = await costHistoryCollection
          .where('productId', isEqualTo: productId)
          .where(
            'timestamp',
            isLessThanOrEqualTo: Timestamp.fromDate(timestamp),
          )
          .orderBy('timestamp', descending: true)
          .limit(1)
          .get();

      if (snapshot.docs.isNotEmpty) {
        return (snapshot.docs.first.data() as Map<String, dynamic>)['cost']
            as double?;
      }
      return null;
    } catch (e) {
      throw FirestoreException('Failed to get cost at time: $e');
    }
  }

  /// Get the latest cost for a product
  Future<double?> getLatestCost(String productId) async {
    try {
      final snapshot = await costHistoryCollection
          .where('productId', isEqualTo: productId)
          .orderBy('timestamp', descending: true)
          .limit(1)
          .get();

      if (snapshot.docs.isNotEmpty) {
        return (snapshot.docs.first.data() as Map<String, dynamic>)['cost']
            as double?;
      }
      return null;
    } catch (e) {
      throw FirestoreException('Failed to get latest cost: $e');
    }
  }

  CostHistory _costHistoryFromDocument(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    data['id'] = doc.id;
    return CostHistory.fromMap(data);
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\credit_check_service.dart
â•‘ SIZE: 3.17 KB
â•‘ MODIFIED: 10/03/2025 21:23:14
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/models/sale.dart';
import 'package:prostock/services/local_database_service.dart';
import 'package:prostock/services/notification_service.dart';

class CreditCheckService {
  final LocalDatabaseService _localDatabaseService;
  final NotificationService _notificationService;

  CreditCheckService(this._localDatabaseService, this._notificationService);

  Future<void> checkDuePaymentsAndNotify() async {
    final db = await _localDatabaseService.database;
    final sales = await db.query('sales');

    final List<Sale> allSales = sales.map((s) => Sale.fromMap(s)).toList();

    final today = DateTime.now();
    final todayStart = DateTime(today.year, today.month, today.day);
    // Almost due: 1-2 days from now
    final almostDueStart = todayStart.add(const Duration(days: 1));
    final almostDueEnd = todayStart.add(const Duration(days: 3));

    final List<Sale> almostDue = [];
    final List<Sale> due = [];
    final List<Sale> overdue = [];

    for (final sale in allSales) {
      if (sale.dueDate != null && sale.customerId != null) {
        final dueDate = sale.dueDate!;
        final dueDateStart = DateTime(dueDate.year, dueDate.month, dueDate.day);

        if (dueDateStart.isBefore(todayStart)) {
          // Overdue: due date has passed
          overdue.add(sale);
        } else if (dueDateStart.isAtSameMomentAs(todayStart)) {
          // Due today
          due.add(sale);
        } else if ((dueDateStart.isAtSameMomentAs(almostDueStart) ||
                dueDateStart.isAfter(almostDueStart)) &&
            dueDateStart.isBefore(almostDueEnd)) {
          // Almost due: 1-2 days from now
          almostDue.add(sale);
        }
      }
    }

    if (almostDue.isNotEmpty) {
      final customerNames = await _getCustomerNames(almostDue);
      _notificationService.showNotification(
        0,
        'Almost Due Payments',
        '${almostDue.length} payment(s) almost due: ${customerNames.join(', ')}',
        'almost_due',
      );
    }

    if (due.isNotEmpty) {
      final customerNames = await _getCustomerNames(due);
      _notificationService.showNotification(
        1,
        'Due Payments',
        '${due.length} payment(s) due today: ${customerNames.join(', ')}',
        'due',
      );
    }

    if (overdue.isNotEmpty) {
      final customerNames = await _getCustomerNames(overdue);
      _notificationService.showNotification(
        2,
        'Overdue Payments',
        '${overdue.length} payment(s) overdue: ${customerNames.join(', ')}',
        'overdue',
      );
    }
  }

  Future<List<String>> _getCustomerNames(List<Sale> sales) async {
    final db = await _localDatabaseService.database;
    final customerIds = sales
        .map((s) => s.customerId)
        .where((id) => id != null)
        .toSet();

    if (customerIds.isEmpty) return ['Unknown Customer'];

    final customers = await db.query(
      'customers',
      where: 'id IN (${customerIds.map((_) => '?').join(',')})',
      whereArgs: customerIds.toList(),
    );

    final customerMap = {for (var c in customers) c['id']: c['name'] as String};

    return sales
        .map((s) => customerMap[s.customerId] ?? 'Unknown Customer')
        .toSet()
        .toList();
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\customer_status_monitor.dart
â•‘ SIZE: 7.92 KB
â•‘ MODIFIED: 10/04/2025 05:17:34
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/models/customer.dart';
import 'package:prostock/services/notification_service.dart';
import 'package:prostock/services/local_database_service.dart';

enum CustomerStatus {
  good, // Green - no balance or within credit limit
  warning, // Orange - has balance but not overdue
  almostDue, // Yellow - payment due within 1-2 days
  overdue, // Red - overdue payments
}

class CustomerStatusMonitor {
  static final CustomerStatusMonitor _instance =
      CustomerStatusMonitor._internal();
  factory CustomerStatusMonitor() => _instance;
  CustomerStatusMonitor._internal();

  final NotificationService _notificationService = NotificationService();
  final LocalDatabaseService _localDatabaseService =
      LocalDatabaseService.instance;

  // Track previous customer statuses to detect changes
  final Map<String, CustomerStatus> _previousStatuses = {};

  /// Initialize the monitor with current customer statuses
  Future<void> initialize() async {
    await _loadCurrentStatuses();
  }

  /// Check for customer status changes and send notifications
  Future<void> checkStatusChanges(List<Customer> customers) async {
    final today = DateTime.now();
    final todayStart = DateTime(today.year, today.month, today.day);

    for (final customer in customers) {
      final currentStatus = await _determineCustomerStatus(
        customer,
        todayStart,
      );
      final previousStatus = _previousStatuses[customer.id];

      // Only notify if status actually changed
      if (previousStatus != null && previousStatus != currentStatus) {
        await _sendStatusChangeNotification(
          customer,
          previousStatus,
          currentStatus,
        );
      }

      // Update the stored status
      _previousStatuses[customer.id] = currentStatus;
    }
  }

  /// Determine the current status of a customer
  Future<CustomerStatus> _determineCustomerStatus(
    Customer customer,
    DateTime todayStart,
  ) async {
    // Check if customer has overdue payments (2 days past due date)
    final db = await _localDatabaseService.database;
    final overdueThreshold = todayStart.subtract(const Duration(days: 2));
    final overdueSales = await db.query(
      'sales',
      where: 'customer_id = ? AND due_date < ? AND due_date IS NOT NULL',
      whereArgs: [customer.id, overdueThreshold.toIso8601String()],
    );

    if (overdueSales.isNotEmpty) {
      return CustomerStatus.overdue;
    }

    // Get all sales with due dates for this customer
    final allSalesWithDueDates = await db.query(
      'sales',
      where: 'customer_id = ? AND due_date IS NOT NULL',
      whereArgs: [customer.id],
      orderBy: 'due_date ASC',
    );

    if (allSalesWithDueDates.isEmpty) {
      // No sales with due dates, check if customer has balance
      if (customer.balance > 0) {
        return CustomerStatus.warning;
      }
      return CustomerStatus.good;
    }

    // Find the earliest due date among all sales
    final earliestDueDate = DateTime.parse(
      allSalesWithDueDates.first['due_date'] as String,
    );
    final daysUntilDue = earliestDueDate.difference(todayStart).inDays;

    // Determine status based on earliest due date
    if (daysUntilDue <= -2) {
      // Overdue (2+ days past due date)
      return CustomerStatus.overdue;
    } else if (daysUntilDue <= 2) {
      // Due within 1-2 days (including due today and 1 day past due)
      return CustomerStatus.almostDue;
    } else if (customer.balance > 0) {
      // Has balance but not due soon
      return CustomerStatus.warning;
    }

    return CustomerStatus.good;
  }

  /// Send notification when customer status changes
  Future<void> _sendStatusChangeNotification(
    Customer customer,
    CustomerStatus oldStatus,
    CustomerStatus newStatus,
  ) async {
    String title;
    String body;
    int notificationId = customer.id.hashCode;

    switch (newStatus) {
      case CustomerStatus.overdue:
        title = '🚨 Customer Overdue Alert';
        body = '${customer.name} has overdue payments and needs attention';
        break;
      case CustomerStatus.almostDue:
        title = '⏰ Payment Due Soon';
        body = await _getAlmostDueMessage(customer);
        break;
      case CustomerStatus.warning:
        title = '⚠️ Customer Balance Alert';
        body =
            '${customer.name} has an outstanding balance of ₱${customer.balance.toStringAsFixed(2)}';
        break;
      case CustomerStatus.good:
        title = '✅ Customer Status Updated';
        body = '${customer.name} is now in good standing';
        break;
    }

    await _notificationService.showNotification(
      notificationId,
      title,
      body,
      'customer_status:${customer.id}:${newStatus.name}',
    );
  }

  /// Get detailed message for almost due status
  Future<String> _getAlmostDueMessage(Customer customer) async {
    final db = await _localDatabaseService.database;
    final todayStart = DateTime.now();
    final almostDueStart = todayStart.subtract(
      const Duration(days: 1),
    ); // Include 1 day past due
    final almostDueEnd = todayStart.add(
      const Duration(days: 2),
    ); // Include 2 days from now

    final almostDueSales = await db.query(
      'sales',
      where:
          'customer_id = ? AND due_date >= ? AND due_date <= ? AND due_date IS NOT NULL',
      whereArgs: [
        customer.id,
        almostDueStart.toIso8601String(),
        almostDueEnd.toIso8601String(),
      ],
      orderBy: 'due_date ASC',
    );

    if (almostDueSales.isEmpty) {
      return '${customer.name} has payments due within 1-2 days';
    }

    final earliestDueDate = DateTime.parse(
      almostDueSales.first['due_date'] as String,
    );
    final daysUntilDue = earliestDueDate.difference(todayStart).inDays;

    if (daysUntilDue == 0) {
      return '${customer.name} has payment due today (₱${customer.balance.toStringAsFixed(2)})';
    } else if (daysUntilDue == 1) {
      return '${customer.name} has payment due tomorrow (₱${customer.balance.toStringAsFixed(2)})';
    } else if (daysUntilDue == -1) {
      return '${customer.name} has payment 1 day overdue (₱${customer.balance.toStringAsFixed(2)})';
    } else if (daysUntilDue > 0) {
      return '${customer.name} has payment due in $daysUntilDue days (₱${customer.balance.toStringAsFixed(2)})';
    } else {
      return '${customer.name} has payment ${-daysUntilDue} days overdue (₱${customer.balance.toStringAsFixed(2)})';
    }
  }

  /// Load current customer statuses from database
  Future<void> _loadCurrentStatuses() async {
    final db = await _localDatabaseService.database;
    final customers = await db.query('customers');
    final today = DateTime.now();
    final todayStart = DateTime(today.year, today.month, today.day);

    for (final customerData in customers) {
      final customer = Customer.fromMap(customerData);
      final status = await _determineCustomerStatus(customer, todayStart);
      _previousStatuses[customer.id] = status;
    }
  }

  /// Get status color for UI display
  static Color getStatusColor(CustomerStatus status) {
    switch (status) {
      case CustomerStatus.good:
        return Colors.green;
      case CustomerStatus.warning:
        return Colors.orange;
      case CustomerStatus.almostDue:
        return Colors.amber;
      case CustomerStatus.overdue:
        return Colors.red;
    }
  }

  /// Get status description for UI display
  static String getStatusDescription(CustomerStatus status) {
    switch (status) {
      case CustomerStatus.good:
        return 'Good Standing';
      case CustomerStatus.warning:
        return 'Has Balance';
      case CustomerStatus.almostDue:
        return 'Due Soon';
      case CustomerStatus.overdue:
        return 'Overdue';
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\customer_status_test.dart
â•‘ SIZE: 1.17 KB
â•‘ MODIFIED: 10/04/2025 05:06:57
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/services/customer_status_monitor.dart';
import 'package:prostock/models/customer.dart';

/// Test utility for customer status monitoring
class CustomerStatusTest {
  static Future<void> testStatusChanges() async {
    final monitor = CustomerStatusMonitor();
    await monitor.initialize();

    // Create test customers with different statuses
    final testCustomers = [
      Customer(
        id: 'test1',
        name: 'Test Customer 1',
        balance: 0.0,
        creditLimit: 1000.0,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      ),
      Customer(
        id: 'test2',
        name: 'Test Customer 2',
        balance: 500.0,
        creditLimit: 1000.0,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      ),
      Customer(
        id: 'test3',
        name: 'Test Customer 3',
        balance: 1200.0,
        creditLimit: 1000.0,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      ),
    ];

    // Test status monitoring
    await monitor.checkStatusChanges(testCustomers);

    print('Customer status monitoring test completed');
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\demand_analysis_service.dart
â•‘ SIZE: 9.34 KB
â•‘ MODIFIED: 09/30/2025 15:29:43
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:math';

import 'package:prostock/models/product.dart';
import 'package:prostock/services/local_database_service.dart';
import 'package:prostock/services/notification_service.dart';
import 'package:shared_preferences/shared_preferences.dart';

class DemandSuggestion {
  final Product product;
  final double velocityPerDay;
  final int currentThreshold;
  final int suggestedThreshold;

  DemandSuggestion({
    required this.product,
    required this.velocityPerDay,
    required this.currentThreshold,
    required this.suggestedThreshold,
  });
}

class DemandAnalysisService {
  final LocalDatabaseService _db;
  final NotificationService _notificationService;

  DemandAnalysisService(this._db, this._notificationService);

  static const String _prefsSnoozeKey =
      'demand_snooze_until'; // map<productId, isoString>
  static const String _prefsLastSuggestedAtKey =
      'demand_last_suggested_at'; // map<productId, isoString>
  static const String _prefsLastAcceptedAtKey =
      'demand_last_accepted_at'; // map<productId, isoString>

  Future<List<DemandSuggestion>> computeSuggestions({
    int windowDays = 7,
    int fallbackWindowDays = 30,
    double highDemandThresholdPerDay = 10.0,
    int leadTimeDays = 2,
    int minDeltaUnits = 5,
    double minDeltaPercent = 0.2,
  }) async {
    final products = await _db.getAllProducts();

    // Load sales within fallback window
    final since = DateTime.now().subtract(Duration(days: fallbackWindowDays));
    final sales = await _db.getSalesSince(since);
    final saleIds = sales.map((s) => s['id'].toString()).toList();
    final saleItems = await _db.getSaleItemsBySaleIds(saleIds);

    // Aggregate quantities by productId -> dateString -> qty
    final Map<String, Map<String, int>> perDay = {};
    for (final item in saleItems) {
      final saleId = item['saleId']?.toString();
      final sale = sales.firstWhere(
        (s) => s['id'].toString() == saleId,
        orElse: () => {},
      );
      if (sale.isEmpty) continue;
      final createdAt = DateTime.tryParse(sale['created_at']?.toString() ?? '');
      if (createdAt == null) continue;
      if (createdAt.isBefore(since)) continue;
      final productId = item['productId']?.toString();
      if (productId == null) continue;
      final dateKey = DateTime(
        createdAt.year,
        createdAt.month,
        createdAt.day,
      ).toIso8601String();
      final qty = (item['quantity'] as int?) ?? 0;
      perDay.putIfAbsent(productId, () => {});
      perDay[productId]![dateKey] = (perDay[productId]![dateKey] ?? 0) + qty;
    }

    // Compute velocity and suggestions
    final Map<String, Product> productMap = {
      for (final p in products)
        if (p.id != null) p.id!: p,
    };
    final List<DemandSuggestion> suggestions = [];

    final now = DateTime.now();

    for (final entry in perDay.entries) {
      final productId = entry.key;
      final product = productMap[productId];
      if (product == null) continue;

      // Build series for windowDays; if sparse, extend to fallbackWindowDays
      double totalQtyWindow = 0;
      int daysCounted = 0;
      for (int i = 0; i < windowDays; i++) {
        final d = DateTime(
          now.year,
          now.month,
          now.day,
        ).subtract(Duration(days: i));
        final k = DateTime(d.year, d.month, d.day).toIso8601String();
        final dayQty = (entry.value[k] ?? 0).toDouble();
        totalQtyWindow += dayQty;
        daysCounted += 1;
      }
      double velocity = daysCounted > 0 ? (totalQtyWindow / daysCounted) : 0.0;

      // Special case: Check if today's sales alone meet the threshold
      final todayKey = DateTime(now.year, now.month, now.day).toIso8601String();
      final todayQty = (entry.value[todayKey] ?? 0).toDouble();

      if (todayQty >= highDemandThresholdPerDay) {
        velocity = todayQty; // Use today's sales as velocity
      } else if (velocity < highDemandThresholdPerDay) {
        // Try fallback window if within 30 days the avg could qualify
        double totalQtyFallback = 0;
        for (int i = 0; i < fallbackWindowDays; i++) {
          final d = DateTime(
            now.year,
            now.month,
            now.day,
          ).subtract(Duration(days: i));
          final k = DateTime(d.year, d.month, d.day).toIso8601String();
          totalQtyFallback += (entry.value[k] ?? 0).toDouble();
        }
        final velocityFallback = totalQtyFallback / max(1, fallbackWindowDays);
        velocity = velocityFallback;
      }

      if (velocity >= highDemandThresholdPerDay) {
        final suggested = (velocity * (leadTimeDays + 1)).ceil();
        final current = product.minStock;
        final deltaUnits = suggested - current;
        final deltaPercent = current > 0 ? deltaUnits / current : 1.0;

        if (deltaUnits >= minDeltaUnits || deltaPercent >= minDeltaPercent) {
          final isEligible = await _isEligibleToSuggest(productId, now);

          if (isEligible) {
            final suggestion = DemandSuggestion(
              product: product,
              velocityPerDay: velocity,
              currentThreshold: current,
              suggestedThreshold: min(
                current + max(deltaUnits, 0),
                current + max(5, (current * 0.5).ceil()),
              ),
            );
            suggestions.add(suggestion);
          }
        }
      }
    }

    // Sort by biggest gap first
    suggestions.sort(
      (a, b) => (b.suggestedThreshold - b.currentThreshold).compareTo(
        a.suggestedThreshold - a.currentThreshold,
      ),
    );

    return suggestions;
  }

  Future<bool> _isEligibleToSuggest(String productId, DateTime now) async {
    final prefs = await SharedPreferences.getInstance();
    final snoozeMap = Map<String, String>.from(
      (prefs.getStringList(_prefsSnoozeKey) ?? []).fold<Map<String, String>>(
        {},
        (m, s) {
          final parts = s.split('|');
          if (parts.length == 2) m[parts[0]] = parts[1];
          return m;
        },
      ),
    );
    final snoozedUntilStr = snoozeMap[productId];
    if (snoozedUntilStr != null) {
      final snoozedUntil = DateTime.tryParse(snoozedUntilStr);
      if (snoozedUntil != null && snoozedUntil.isAfter(now)) return false;
    }
    // Cooldown after accept: 30 days
    final acceptedMap = Map<String, String>.from(
      (prefs.getStringList(_prefsLastAcceptedAtKey) ?? [])
          .fold<Map<String, String>>({}, (m, s) {
            final parts = s.split('|');
            if (parts.length == 2) m[parts[0]] = parts[1];
            return m;
          }),
    );
    final acceptedAtStr = acceptedMap[productId];
    if (acceptedAtStr != null) {
      final acceptedAt = DateTime.tryParse(acceptedAtStr);
      if (acceptedAt != null &&
          acceptedAt.isAfter(now.subtract(const Duration(days: 30)))) {
        return false;
      }
    }
    return true;
  }

  Future<void> markSuggestedNow(List<String> productIds) async {
    final prefs = await SharedPreferences.getInstance();
    final list = prefs.getStringList(_prefsLastSuggestedAtKey) ?? [];
    final Map<String, String> map = {};
    for (final s in list) {
      final parts = s.split('|');
      if (parts.length == 2) map[parts[0]] = parts[1];
    }
    final now = DateTime.now().toIso8601String();
    for (final id in productIds) {
      map[id] = now;
    }
    prefs.setStringList(
      _prefsLastSuggestedAtKey,
      map.entries.map((e) => '${e.key}|${e.value}').toList(),
    );
  }

  Future<void> snooze(
    String productId, {
    Duration duration = const Duration(days: 7),
  }) async {
    final prefs = await SharedPreferences.getInstance();
    final list = prefs.getStringList(_prefsSnoozeKey) ?? [];
    final Map<String, String> map = {};
    for (final s in list) {
      final parts = s.split('|');
      if (parts.length == 2) map[parts[0]] = parts[1];
    }
    map[productId] = DateTime.now().add(duration).toIso8601String();
    prefs.setStringList(
      _prefsSnoozeKey,
      map.entries.map((e) => '${e.key}|${e.value}').toList(),
    );
  }

  Future<void> acceptSuggestion(String productId, int newThreshold) async {
    // Update local DB min_stock; queue remote via OfflineManager is handled elsewhere
    await _db.updateProductMinStock(productId, newThreshold);
    final prefs = await SharedPreferences.getInstance();
    final list = prefs.getStringList(_prefsLastAcceptedAtKey) ?? [];
    final Map<String, String> map = {};
    for (final s in list) {
      final parts = s.split('|');
      if (parts.length == 2) map[parts[0]] = parts[1];
    }
    map[productId] = DateTime.now().toIso8601String();
    prefs.setStringList(
      _prefsLastAcceptedAtKey,
      map.entries.map((e) => '${e.key}|${e.value}').toList(),
    );
  }

  Future<int> runDailyAndNotify() async {
    final suggestions = await computeSuggestions();
    if (suggestions.isNotEmpty) {
      await markSuggestedNow(suggestions.map((s) => s.product.id!).toList());
      await _notificationService.showNotification(
        4001,
        'High demand detected',
        'Review ${suggestions.length} product(s) to adjust low-stock thresholds',
        'inventory_suggestions',
      );
    }
    return suggestions.length;
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\historical_cost_service.dart
â•‘ SIZE: 3 KB
â•‘ MODIFIED: 10/04/2025 06:07:02
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/models/sale_item.dart';
import 'package:prostock/models/cost_history.dart';
import 'package:prostock/services/cost_history_service.dart';
import 'package:prostock/services/local_database_service.dart';
import 'package:prostock/models/product.dart';

class HistoricalCostService {
  final CostHistoryService _costHistoryService;
  final LocalDatabaseService _localDatabaseService;

  HistoricalCostService(this._costHistoryService, this._localDatabaseService);

  /// Get historical cost for a sale item at the time of sale
  Future<double> getHistoricalCostForSaleItem(
    SaleItem saleItem,
    DateTime saleDate,
  ) async {
    try {
      // First try to get cost from cost history at the time of sale
      final costAtTime = await _costHistoryService.getCostAtTime(
        saleItem.productId,
        saleDate,
      );

      if (costAtTime != null) {
        return costAtTime;
      }

      // Fallback to current product cost if no historical data
      final products = await _localDatabaseService.getAllProducts();
      final product = products.firstWhere(
        (p) => p.id == saleItem.productId,
        orElse: () => Product(
          id: saleItem.productId,
          name: 'Unknown Product',
          cost: 0.0,
          stock: 0,
          minStock: 0,
          category: 'Unknown',
          version: 0,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ),
      );

      return product.cost;
    } catch (e) {
      // Fallback to current product cost on error
      final products = await _localDatabaseService.getAllProducts();
      final product = products.firstWhere(
        (p) => p.id == saleItem.productId,
        orElse: () => Product(
          id: saleItem.productId,
          name: 'Unknown Product',
          cost: 0.0,
          stock: 0,
          minStock: 0,
          category: 'Unknown',
          version: 0,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ),
      );

      return product.cost;
    }
  }

  /// Get historical costs for multiple sale items
  Future<Map<String, double>> getHistoricalCostsForSaleItems(
    List<SaleItem> saleItems,
    DateTime saleDate,
  ) async {
    final Map<String, double> costs = {};

    for (final item in saleItems) {
      costs[item.id] = await getHistoricalCostForSaleItem(item, saleDate);
    }

    return costs;
  }

  /// Get cost history for a product within a date range
  Future<List<CostHistory>> getCostHistoryForProduct(
    String productId,
    DateTime startDate,
    DateTime endDate,
  ) async {
    return await _costHistoryService.getCostHistoryByDateRange(
      startDate,
      endDate,
      productId: productId,
    );
  }

  /// Get all cost history for multiple products
  Future<List<CostHistory>> getCostHistoryForProducts(
    List<String> productIds,
  ) async {
    return await _costHistoryService.getCostHistoryByProducts(productIds);
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\local_database_service.dart
â•‘ SIZE: 13.92 KB
â•‘ MODIFIED: 10/27/2025 08:49:05
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/models/sale.dart';
import 'package:prostock/models/sale_item.dart';
import 'package:prostock/models/product.dart';
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';

class LocalDatabaseService {
  static final LocalDatabaseService instance = LocalDatabaseService._init();
  static Database? _database;

  LocalDatabaseService._init();

  Future<Database> get database async {
    if (_database != null) return _database!;

    _database = await _initDB('prostock.db');
    return _database!;
  }

  Future<Database> _initDB(String filePath) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, filePath);

    return await openDatabase(
      path,
      version: 10, // Increment version to backfill unitCost for old sales
      onCreate: _createDB,
      onUpgrade: _onUpgrade,
    );
  }

  Future _createDB(Database db, int version) async {
    await _createTables(db);
  }

  Future<void> _createTables(Database db) async {
    const textType = 'TEXT NOT NULL';
    const integerType = 'INTEGER NOT NULL';
    const doubleType = 'REAL NOT NULL';

    await db.execute('''
CREATE TABLE IF NOT EXISTS customers (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  phone TEXT,
  email TEXT,
  address TEXT,
  imageUrl TEXT,
  localImagePath TEXT,
  balance REAL NOT NULL,
  credit_limit REAL NOT NULL,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  version INTEGER NOT NULL DEFAULT 1
)
''');

    await db.execute('''
CREATE TABLE IF NOT EXISTS products (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  barcode TEXT,
  cost REAL NOT NULL,
  selling_price REAL,
  stock INTEGER NOT NULL,
  min_stock INTEGER NOT NULL,
  category TEXT,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  version INTEGER NOT NULL
)
''');

    await db.execute('''
CREATE TABLE IF NOT EXISTS sales (
  id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  customer_id TEXT,
  total_amount REAL NOT NULL,
  payment_method TEXT NOT NULL,
  status TEXT NOT NULL,
  created_at TEXT NOT NULL,
  due_date TEXT,
  is_synced INTEGER NOT NULL DEFAULT 0
)
''');

    await db.execute('''
CREATE TABLE IF NOT EXISTS sale_items (
  id $textType,
  saleId $textType,
  productId $textType,
  batchId TEXT,
  quantity $integerType,
  unitPrice $doubleType,
  unitCost $doubleType,
  batchCost $doubleType,
  totalPrice $doubleType
)
''');

    // Credit transactions local cache
    await db.execute('''
CREATE TABLE IF NOT EXISTS credit_transactions (
  id TEXT PRIMARY KEY,
  customerId TEXT NOT NULL,
  amount REAL NOT NULL,
  date TEXT NOT NULL,
  createdAt TEXT,
  type TEXT NOT NULL,
  notes TEXT,
  items TEXT
)
''');

    // Inventory batches for FIFO tracking
    await db.execute('''
CREATE TABLE IF NOT EXISTS inventory_batches (
  id TEXT PRIMARY KEY,
  product_id TEXT NOT NULL,
  batch_number TEXT NOT NULL,
  quantity_received INTEGER NOT NULL,
  quantity_remaining INTEGER NOT NULL,
  unit_cost REAL NOT NULL,
  date_received TEXT NOT NULL,
  supplier_id TEXT,
  notes TEXT,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  FOREIGN KEY (product_id) REFERENCES products (id) ON DELETE CASCADE
)
''');

    // Indexes for batch queries
    await db.execute('''
CREATE INDEX IF NOT EXISTS idx_batches_product 
ON inventory_batches(product_id)
''');

    await db.execute('''
CREATE INDEX IF NOT EXISTS idx_batches_date 
ON inventory_batches(date_received)
''');

    await db.execute('''
CREATE INDEX IF NOT EXISTS idx_batches_remaining 
ON inventory_batches(quantity_remaining)
''');

    await db.execute('''
CREATE TABLE IF NOT EXISTS losses (
  id TEXT PRIMARY KEY,
  productId TEXT NOT NULL,
  quantity INTEGER NOT NULL,
  totalCost REAL NOT NULL,
  reason TEXT NOT NULL,
  timestamp TEXT NOT NULL,
  recordedBy TEXT
)
''');

    await db.execute('''
CREATE TABLE IF NOT EXISTS offline_operations (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  operation_id TEXT NOT NULL,
  operation_type TEXT NOT NULL,
  collection_name TEXT NOT NULL,
  document_id TEXT,
  data TEXT NOT NULL,
  timestamp TEXT NOT NULL,
  retry_count INTEGER NOT NULL DEFAULT 0,
  version INTEGER
)
''');

    await db.execute('''
CREATE TABLE IF NOT EXISTS dead_letter_operations (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  operation_id TEXT NOT NULL,
  operation_type TEXT NOT NULL,
  collection_name TEXT NOT NULL,
  document_id TEXT,
  data TEXT NOT NULL,
  timestamp TEXT NOT NULL,
  error TEXT NOT NULL
)
''');
  }

  Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
    if (oldVersion < 2) {
      try {
        await db.execute(
          "ALTER TABLE sale_items ADD COLUMN saleId TEXT NOT NULL DEFAULT ''",
        );
      } catch (e) {
        // Column might already exist, ignore
      }
    }
    if (oldVersion < 3) {
      try {
        await db.execute(
          "ALTER TABLE sales ADD COLUMN is_synced INTEGER NOT NULL DEFAULT 0",
        );
      } catch (e) {
        // Column might already exist, ignore
      }
    }
    if (oldVersion < 4) {
      await db.execute('''
CREATE TABLE IF NOT EXISTS offline_operations (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  operation_id TEXT NOT NULL,
  operation_type TEXT NOT NULL,
  collection_name TEXT NOT NULL,
  document_id TEXT,
  data TEXT NOT NULL,
  timestamp TEXT NOT NULL,
  retry_count INTEGER NOT NULL DEFAULT 0,
  version INTEGER
)
''');
    }
    if (oldVersion < 5) {
      await db.execute('''
CREATE TABLE IF NOT EXISTS losses (
  id TEXT PRIMARY KEY,
  productId TEXT NOT NULL,
  quantity INTEGER NOT NULL,
  totalCost REAL NOT NULL,
  reason TEXT NOT NULL,
  timestamp TEXT NOT NULL,
  recordedBy TEXT
)
''');
    }
    if (oldVersion < 6) {
      try {
        await db.execute(
          "ALTER TABLE customers ADD COLUMN version INTEGER NOT NULL DEFAULT 1",
        );
      } catch (e) {
        // Column might already exist, ignore
      }
    }
    // Ensure credit_transactions table exists/updated for older installs
    if (oldVersion < 7) {
      await db.execute('''
CREATE TABLE IF NOT EXISTS credit_transactions (
  id TEXT PRIMARY KEY,
  customerId TEXT NOT NULL,
  amount REAL NOT NULL,
  date TEXT NOT NULL,
  createdAt TEXT,
  type TEXT NOT NULL,
  notes TEXT,
  items TEXT
)
''');
    }
    // Add unitCost column to sale_items for accurate COGS tracking
    if (oldVersion < 8) {
      try {
        await db.execute(
          "ALTER TABLE sale_items ADD COLUMN unitCost REAL NOT NULL DEFAULT 0.0",
        );
      } catch (e) {
        // Column might already exist, ignore
      }
    }

    // Add FIFO batch tracking system
    if (oldVersion < 9) {
      // Add selling_price to products
      try {
        await db.execute("ALTER TABLE products ADD COLUMN selling_price REAL");
      } catch (e) {
        // Column might already exist, ignore
      }

      // Add batch tracking fields to sale_items
      try {
        await db.execute("ALTER TABLE sale_items ADD COLUMN batchId TEXT");
      } catch (e) {
        // Column might already exist, ignore
      }

      try {
        await db.execute(
          "ALTER TABLE sale_items ADD COLUMN batchCost REAL NOT NULL DEFAULT 0.0",
        );
      } catch (e) {
        // Column might already exist, ignore
      }

      // Create inventory_batches table
      await db.execute('''
CREATE TABLE IF NOT EXISTS inventory_batches (
  id TEXT PRIMARY KEY,
  product_id TEXT NOT NULL,
  batch_number TEXT NOT NULL,
  quantity_received INTEGER NOT NULL,
  quantity_remaining INTEGER NOT NULL,
  unit_cost REAL NOT NULL,
  date_received TEXT NOT NULL,
  supplier_id TEXT,
  notes TEXT,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  FOREIGN KEY (product_id) REFERENCES products (id) ON DELETE CASCADE
)
''');

      // Create indexes
      await db.execute('''
CREATE INDEX IF NOT EXISTS idx_batches_product 
ON inventory_batches(product_id)
''');

      await db.execute('''
CREATE INDEX IF NOT EXISTS idx_batches_date 
ON inventory_batches(date_received)
''');

      await db.execute('''
CREATE INDEX IF NOT EXISTS idx_batches_remaining 
ON inventory_batches(quantity_remaining)
''');

      // Migrate existing stock to initial batches
      final products = await db.query('products');
      for (final product in products) {
        final stock = product['stock'] as int;
        if (stock > 0) {
          final now = DateTime.now().toIso8601String();
          await db.insert('inventory_batches', {
            'id': '${product['id']}-INITIAL',
            'product_id': product['id'],
            'batch_number': 'INITIAL-${product['id']}',
            'quantity_received': stock,
            'quantity_remaining': stock,
            'unit_cost': product['cost'],
            'date_received': now,
            'notes': 'Initial stock migration to FIFO system',
            'created_at': now,
            'updated_at': now,
          });
        }
      }
    }

    // Backfill unitCost for old sale items (pre-FIFO sales)
    if (oldVersion < 10) {
      // Get all sale items with zero or null unitCost
      final saleItems = await db.query(
        'sale_items',
        where: 'unitCost IS NULL OR unitCost = 0.0',
      );

      if (saleItems.isNotEmpty) {
        // Get current product costs for fallback
        final products = await db.query('products');
        final productCostMap = {for (var p in products) p['id']: p['cost']};

        // Update each sale item with the product's current cost
        for (final item in saleItems) {
          final productId = item['productId'] as String?;
          if (productId != null && productCostMap.containsKey(productId)) {
            final cost = productCostMap[productId] as double;
            await db.update(
              'sale_items',
              {
                'unitCost': cost,
                'batchCost': cost, // Also update batchCost for consistency
              },
              where: 'id = ?',
              whereArgs: [item['id']],
            );
          }
        }
      }
    }
  }

  Future<List<Map<String, dynamic>>> getSales() async {
    final db = await instance.database;
    return await db.query('sales');
  }

  Future<List<Map<String, dynamic>>> getSalesSince(DateTime since) async {
    final db = await instance.database;
    return await db.query(
      'sales',
      where: 'created_at >= ?',
      whereArgs: [since.toIso8601String()],
      orderBy: 'created_at DESC',
    );
  }

  Future<int> insertSale(Sale sale) async {
    final db = await instance.database;
    return await db.insert('sales', sale.toMap());
  }

  Future<int> insertSaleItem(SaleItem saleItem) async {
    final db = await instance.database;
    return await db.insert('sale_items', saleItem.toMap());
  }

  // Credit transactions local cache methods
  Future<int> insertCreditTransaction(Map<String, dynamic> tx) async {
    final db = await instance.database;
    return await db.insert(
      'credit_transactions',
      tx,
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  Future<List<Map<String, dynamic>>> getCreditTransactionsByCustomer(
    String customerId,
  ) async {
    final db = await instance.database;
    return await db.query(
      'credit_transactions',
      where: 'customerId = ?',
      whereArgs: [customerId],
      orderBy: 'date DESC',
    );
  }

  Future<List<Map<String, dynamic>>> getAllCreditTransactions() async {
    final db = await instance.database;
    return await db.query('credit_transactions', orderBy: 'date DESC');
  }

  Future<List<Map<String, dynamic>>> getSaleItems(String saleId) async {
    final db = await instance.database;
    // Aggregate duplicates that may exist due to offline queue + sync overlap
    return await db.rawQuery(
      'SELECT productId, saleId, '
      'SUM(quantity) AS quantity, '
      'ROUND(SUM(totalPrice), 2) AS totalPrice, '
      // Derive unitPrice from summed totals to keep consistency
      'CASE WHEN SUM(quantity) > 0 THEN ROUND(SUM(totalPrice)/SUM(quantity), 2) ELSE 0 END AS unitPrice '
      'FROM sale_items WHERE saleId = ? '
      'GROUP BY saleId, productId',
      [saleId],
    );
  }

  Future<List<Map<String, dynamic>>> getSaleItemsBySaleIds(
    List<String> saleIds,
  ) async {
    final db = await instance.database;
    if (saleIds.isEmpty) {
      return [];
    }
    final ids = saleIds.map((id) => '?').join(',');
    return await db.rawQuery(
      'SELECT productId, saleId, '
      'SUM(quantity) AS quantity, '
      'ROUND(SUM(totalPrice), 2) AS totalPrice, '
      'CASE WHEN SUM(quantity) > 0 THEN ROUND(SUM(totalPrice)/SUM(quantity), 2) ELSE 0 END AS unitPrice '
      'FROM sale_items WHERE saleId IN ($ids) '
      'GROUP BY saleId, productId',
      saleIds,
    );
  }

  Future<void> markSaleAsSynced(String saleId) async {
    final db = await instance.database;
    await db.update(
      'sales',
      {'is_synced': 1},
      where: 'id = ?',
      whereArgs: [saleId],
    );
  }

  Future<List<Product>> getAllProducts() async {
    final db = await instance.database;
    final rows = await db.query('products');
    return rows.map((m) => Product.fromMap(m)).toList();
  }

  Future<void> updateProductMinStock(String productId, int newMinStock) async {
    final db = await instance.database;
    await db.update(
      'products',
      {
        'min_stock': newMinStock,
        'updated_at': DateTime.now().toIso8601String(),
      },
      where: 'id = ?',
      whereArgs: [productId],
    );
  }

  Future<List<Map<String, dynamic>>> getLosses() async {
    final db = await instance.database;
    return await db.query('losses', orderBy: 'timestamp DESC');
  }

  Future close() async {
    final db = await instance.database;
    db.close();
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\notification_service.dart
â•‘ SIZE: 3.86 KB
â•‘ MODIFIED: 09/23/2025 10:46:03
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:io';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:timezone/timezone.dart' as tz;

class NotificationService {
  static final NotificationService _notificationService =
      NotificationService._internal();

  factory NotificationService() {
    return _notificationService;
  }

  NotificationService._internal();

  final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
      FlutterLocalNotificationsPlugin();

  Future<void> init() async {
    const AndroidInitializationSettings initializationSettingsAndroid =
        AndroidInitializationSettings('@mipmap/ic_launcher');

    const DarwinInitializationSettings initializationSettingsIOS =
        DarwinInitializationSettings(
          requestSoundPermission: true,
          requestBadgePermission: true,
          requestAlertPermission: true,
        );

    const InitializationSettings initializationSettings =
        InitializationSettings(
          android: initializationSettingsAndroid,
          iOS: initializationSettingsIOS,
        );

    await flutterLocalNotificationsPlugin.initialize(initializationSettings);
  }

  /// Requests notification permission at runtime.
  ///
  /// On Android 13+ this requests POST_NOTIFICATIONS.
  /// On iOS this requests alert/badge/sound using the plugin API.
  /// Returns true if permission is granted.
  Future<bool> requestPermission() async {
    if (Platform.isAndroid) {
      // Only needed on Android 13+
      final status = await Permission.notification.request();
      return status.isGranted;
    }

    if (Platform.isIOS) {
      final iosPlugin = flutterLocalNotificationsPlugin
          .resolvePlatformSpecificImplementation<
            IOSFlutterLocalNotificationsPlugin
          >();
      final granted =
          await iosPlugin?.requestPermissions(
            alert: true,
            badge: true,
            sound: true,
          ) ??
          false;
      return granted;
    }

    return true; // Other platforms
  }

  Future<void> showNotification(
    int id,
    String title,
    String body,
    String payload,
  ) async {
    const AndroidNotificationDetails androidPlatformChannelSpecifics =
        AndroidNotificationDetails(
          'prostock_channel_id',
          'ProStock Channel',
          channelDescription: 'ProStock Channel for notifications',
          importance: Importance.max,
          priority: Priority.high,
          showWhen: true,
          enableVibration: true,
          playSound: true,
        );
    const NotificationDetails platformChannelSpecifics = NotificationDetails(
      android: androidPlatformChannelSpecifics,
    );
    await flutterLocalNotificationsPlugin.show(
      id,
      title,
      body,
      platformChannelSpecifics,
      payload: payload,
    );
  }

  Future<void> scheduleNotification({
    required int id,
    required String title,
    required String body,
    required DateTime scheduledDate,
    String? payload,
  }) async {
    const AndroidNotificationDetails androidPlatformChannelSpecifics =
        AndroidNotificationDetails(
          'prostock_scheduled_channel_id',
          'ProStock Scheduled Notifications',
          channelDescription: 'Scheduled notifications for due payments',
          importance: Importance.max,
          priority: Priority.high,
          showWhen: true,
          enableVibration: true,
          playSound: true,
        );
    const NotificationDetails platformChannelSpecifics = NotificationDetails(
      android: androidPlatformChannelSpecifics,
    );

    await flutterLocalNotificationsPlugin.zonedSchedule(
      id,
      title,
      body,
      tz.TZDateTime.from(scheduledDate, tz.local),
      platformChannelSpecifics,
      payload: payload,
      androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\offline_manager.dart
â•‘ SIZE: 3.49 KB
â•‘ MODIFIED: 10/02/2025 12:09:41
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:prostock/models/offline_operation.dart';
import 'package:prostock/models/sale.dart';
import 'package:prostock/providers/sync_failure_provider.dart';
import 'package:prostock/services/local_database_service.dart';
import 'package:prostock/services/offline/cache_service.dart';
import 'package:prostock/services/offline/connectivity_service.dart';
import 'package:prostock/services/offline/operation_queue_service.dart';
import 'package:prostock/services/offline/sync_service.dart';

class OfflineManager with ChangeNotifier {
  final SyncFailureProvider _syncFailureProvider;

  final ConnectivityService _connectivityService = ConnectivityService();
  final CacheService _cacheService = CacheService();
  final OperationQueueService _queueService = OperationQueueService(
    LocalDatabaseService.instance,
  );
  late final SyncService _syncService = SyncService(
    _queueService,
    LocalDatabaseService.instance,
    _syncFailureProvider,
  )..setProgressCallback(_updateSyncProgress);

  bool _isSyncing = false;
  DateTime? _lastSyncTime;
  List<OfflineOperation> _pendingOperations = [];
  int _syncProgress = 0;
  int _totalOperationsToSync = 0;

  OfflineManager(this._syncFailureProvider);

  bool get isOnline => _connectivityService.isOnline;
  bool get isSyncing => _isSyncing;
  DateTime? get lastSyncTime => _lastSyncTime;
  List<OfflineOperation> get pendingOperations =>
      List.unmodifiable(_pendingOperations);
  int get pendingOperationsCount => _pendingOperations.length;
  int get syncProgress => _syncProgress;
  int get totalOperationsToSync => _totalOperationsToSync;

  Future<void> initialize() async {
    await _connectivityService.initialize();
    _connectivityService.addListener(_onConnectivityChanged);
    _pendingOperations = await _queueService.getPendingOperations();
    notifyListeners();
    if (isOnline) {
      await syncPendingOperations();
    }
  }

  void _onConnectivityChanged() async {
    if (isOnline) {
      await syncPendingOperations();
    }
    notifyListeners();
  }

  Future<void> queueOperation(OfflineOperation operation) async {
    await _queueService.queueOperation(operation);
    _pendingOperations = await _queueService.getPendingOperations();
    notifyListeners();
    if (isOnline) {
      await syncPendingOperations();
    }
  }

  Future<void> syncPendingOperations() async {
    if (isSyncing) return;

    _isSyncing = true;
    _pendingOperations = await _queueService.getPendingOperations();
    _totalOperationsToSync = _pendingOperations.length;
    _syncProgress = 0;
    notifyListeners();

    await _syncService.syncPendingOperations();

    _pendingOperations = await _queueService.getPendingOperations();
    _isSyncing = false;
    _syncProgress = 0;
    _totalOperationsToSync = 0;
    _lastSyncTime = DateTime.now();
    await _cacheService.saveLastSyncTime(_lastSyncTime!);
    notifyListeners();
  }

  Future<List<Sale>> getPendingSales() async {
    return await _queueService.getPendingSales();
  }

  Future<void> clearCache() async {
    await _cacheService.clearCache();
  }

  void _updateSyncProgress(int completed, int total) {
    _syncProgress = completed;
    _totalOperationsToSync = total;
    notifyListeners();
  }

  @override
  void dispose() {
    _connectivityService.removeListener(_onConnectivityChanged);
    _connectivityService.dispose();
    super.dispose();
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\pdf_report_service.dart
â•‘ SIZE: 43.85 KB
â•‘ MODIFIED: 10/24/2025 08:08:24
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:async';
import 'dart:io';
import 'dart:math' as math;
import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:prostock/utils/error_logger.dart';

class PdfReportSection {
  final String title;
  final List<List<String>> rows; // [ [label, value], ... ]

  PdfReportSection({required this.title, required this.rows});

  // Create a copy with limited rows
  PdfReportSection copyWithLimitedRows(int maxRows) {
    if (rows.length <= maxRows) {
      return this;
    }

    // Take some rows from the beginning and end
    final firstHalfCount = maxRows ~/ 2;
    final secondHalfCount = maxRows - firstHalfCount;

    final firstHalf = rows.take(firstHalfCount).toList();
    final secondHalf = rows.skip(rows.length - secondHalfCount).toList();

    // Add a summary row in the middle with the same number of columns as the other rows
    List<String> summaryRow = [];
    if (rows.isNotEmpty) {
      int columnCount = rows.first.length;
      summaryRow = List.filled(columnCount, '');
      summaryRow[0] =
          '... (${rows.length - maxRows} more entries not shown) ...';
    }

    return PdfReportSection(
      title: title,
      rows: [...firstHalf, summaryRow, ...secondHalf],
    );
  }
}

class PdfCalculationSection {
  final String title;
  final String formula;
  final String calculation;
  final String result;

  PdfCalculationSection({
    required this.title,
    required this.formula,
    required this.calculation,
    required this.result,
  });
}

class PdfSummarySection {
  final String title;
  final String value;

  PdfSummarySection({required this.title, required this.value});
}

// Data structure for passing PDF generation parameters to isolate
class PdfGenerationParams {
  final String reportTitle;
  final DateTime? startDate;
  final DateTime? endDate;
  final List<PdfReportSection> sections;
  final List<PdfCalculationSection>? calculations;
  final List<PdfSummarySection>? summaries;

  PdfGenerationParams({
    required this.reportTitle,
    this.startDate,
    this.endDate,
    required this.sections,
    this.calculations,
    this.summaries,
  });
}

// Simple semaphore implementation to limit concurrent operations
class _PdfSemaphore {
  final int maxConcurrent;
  int _currentCount = 0;
  final List<Completer<void>> _waiters = [];

  _PdfSemaphore({required this.maxConcurrent});

  Future<void> acquire() async {
    if (_currentCount < maxConcurrent) {
      _currentCount++;
      return Future.value();
    }

    final completer = Completer<void>();
    _waiters.add(completer);
    return completer.future;
  }

  void release() {
    if (_waiters.isNotEmpty) {
      final completer = _waiters.removeAt(0);
      completer.complete();
    } else {
      _currentCount = math.max(0, _currentCount - 1);
    }
  }
}

class PdfReportService {
  // Singleton instance to manage concurrent PDF generations
  static final PdfReportService _instance = PdfReportService._internal();
  factory PdfReportService() => _instance;
  PdfReportService._internal();

  // Semaphore to limit concurrent PDF operations
  static final _semaphore = _PdfSemaphore(maxConcurrent: 2);

  /// Tests if we can write to storage by creating a small test file
  /// Returns the directory that works, or throws an exception if no writable directory is found
  Future<Directory> _testStorage() async {
    try {
      debugPrint('[PDF] Testing storage write access');

      List<Directory> dirsToTry = [];

      // First try: User's requested path for downloads
      if (Platform.isAndroid) {
        // Try the requested path first (most visible to users)
        dirsToTry.add(Directory('/My Phone/Internal Storage/Download'));
        dirsToTry.add(Directory('/storage/emulated/0/Download'));
        dirsToTry.add(Directory('/sdcard/Download'));
      }

      try {
        // Next try: Application documents directory
        final docsDir = await getApplicationDocumentsDirectory();
        dirsToTry.add(docsDir);

        // Then: Application support directory
        final supportDir = await getApplicationSupportDirectory();
        dirsToTry.add(supportDir);

        // Last: Temporary directory
        final tempDir = await getTemporaryDirectory();
        dirsToTry.add(tempDir);
      } catch (e) {
        debugPrint('[PDF] Error getting standard directories: $e');
        // If all else fails, try hard-coded paths
        if (Platform.isAndroid) {
          dirsToTry.add(
            Directory('/data/user/0/com.example.prostock/app_flutter'),
          );
          dirsToTry.add(Directory('/data/user/0/com.example.prostock/files'));
          dirsToTry.add(Directory('/data/user/0/com.example.prostock/cache'));
        }
      }

      // Try each directory until one works
      for (var dir in dirsToTry) {
        try {
          debugPrint('[PDF] Trying directory: ${dir.path}');

          if (!await dir.exists()) {
            await dir.create(recursive: true);
          }

          final testFile = File('${dir.path}/test_write_access.txt');
          await testFile.writeAsString('Test write access: ${DateTime.now()}');

          if (await testFile.exists()) {
            // Clean up
            await testFile.delete();

            debugPrint('[PDF] Found writable directory: ${dir.path}');
            return dir;
          }
        } catch (e) {
          debugPrint('[PDF] Directory not writable: ${dir.path}, error: $e');
          // Continue to next directory
        }
      }

      throw Exception('No writable storage directory found');
    } catch (e) {
      debugPrint('[PDF] Failed to find writable storage: $e');
      rethrow;
    }
  }

  /// Generate PDF in the background using Flutter's compute function
  Future<File> generatePdfInBackground({
    required String reportTitle,
    required DateTime? startDate,
    required DateTime? endDate,
    required List<PdfReportSection> sections,
    List<PdfCalculationSection>? calculations,
    List<PdfSummarySection>? summaries,
  }) async {
    // Acquire semaphore to limit concurrent PDF operations
    await _semaphore.acquire();

    try {
      ErrorLogger.logInfo(
        'Starting PDF generation in background',
        context: 'PdfReportService.generatePdfInBackground',
        metadata: {
          'reportTitle': reportTitle,
          'sectionsCount': sections.length,
          'startDate': startDate?.toIso8601String() ?? 'null',
          'endDate': endDate?.toIso8601String() ?? 'null',
        },
      );

      // Apply stricter limits to avoid TooManyPagesException
      // For large reports, automatically use paginated PDFs
      if (sections.length > 5 ||
          sections.any((s) => s.rows.length > 50) ||
          (calculations?.length ?? 0) > 5) {
        try {
          final files = await generatePaginatedPDFsInBackground(
            reportTitle: reportTitle,
            startDate: startDate,
            endDate: endDate,
            sections: applyDataLimits(
              sections,
              maxRowsPerSection: 50,
            ), // Stricter limit
            calculations: calculations,
            summaries: summaries,
            sectionsPerPdf: 3, // Fewer sections per PDF
          );
          return files.first; // Return the first file as a fallback
        } catch (e, stack) {
          ErrorLogger.logError(
            'Paginated PDF generation fallback failed',
            error: e,
            stackTrace: stack,
            context: 'PdfReportService.generatePdfInBackground',
          );
          rethrow;
        }
      }

      // For smaller reports, try the normal approach
      final params = PdfGenerationParams(
        reportTitle: reportTitle,
        startDate: startDate,
        endDate: endDate,
        sections: applyDataLimits(
          sections,
          maxRowsPerSection: 50,
        ), // Apply stricter limit
        calculations: calculations,
        summaries: summaries,
      );

      try {
        return await compute(_generatePdfInIsolate, params);
      } catch (e, stack) {
        ErrorLogger.logError(
          'PDF generation in background failed',
          error: e,
          stackTrace: stack,
          context: 'PdfReportService.generatePdfInBackground',
          metadata: {
            'reportTitle': reportTitle,
            'sectionsCount': sections.length,
          },
        );

        // If we get a TooManyPagesException, try with even stricter limits
        if (e.toString().contains('TooManyPagesException')) {
          ErrorLogger.logInfo(
            'Retrying with stricter data limits',
            context: 'PdfReportService.generatePdfInBackground',
          );

          try {
            final files = await generatePaginatedPDFsInBackground(
              reportTitle: reportTitle,
              startDate: startDate,
              endDate: endDate,
              sections: applyDataLimits(
                sections,
                maxRowsPerSection: 20,
              ), // Much stricter limit
              calculations: calculations
                  ?.take(3)
                  .toList(), // Limit calculations too
              summaries: summaries,
              sectionsPerPdf: 2, // Even fewer sections per PDF
            );
            return files.first; // Return the first file
          } catch (e2, stack2) {
            ErrorLogger.logError(
              'Final PDF generation attempt failed',
              error: e2,
              stackTrace: stack2,
              context: 'PdfReportService.generatePdfInBackground',
            );
            rethrow;
          }
        }

        rethrow;
      }
    } finally {
      // Always release the semaphore when done
      _semaphore.release();
    }
  }

  /// Generate paginated PDFs in background using Flutter's compute function
  Future<List<File>> generatePaginatedPDFsInBackground({
    required String reportTitle,
    required DateTime? startDate,
    required DateTime? endDate,
    required List<PdfReportSection> sections,
    List<PdfCalculationSection>? calculations,
    List<PdfSummarySection>? summaries,
    int sectionsPerPdf = 5,
    int maxRowsPerSection = 50, // New parameter to control rows per section
  }) async {
    // Acquire semaphore to limit concurrent operations
    await _semaphore.acquire();

    try {
      ErrorLogger.logInfo(
        'Starting paginated PDF generation in background',
        context: 'PdfReportService.generatePaginatedPDFsInBackground',
        metadata: {
          'reportTitle': reportTitle,
          'sectionsCount': sections.length,
          'sectionsPerPdf': sectionsPerPdf,
          'maxRowsPerSection': maxRowsPerSection,
        },
      );

      // Apply row limits to all sections first to avoid TooManyPagesException
      final limitedSections = applyDataLimits(
        sections,
        maxRowsPerSection: maxRowsPerSection,
      );

      // For very large reports, split large sections into multiple sections
      if (limitedSections.any((section) => section.rows.length > 100)) {
        List<PdfReportSection> splitSections = [];

        for (var section in limitedSections) {
          if (section.rows.length > 100) {
            // Split this section into multiple smaller sections
            final totalSplits = (section.rows.length / 50).ceil();

            for (int i = 0; i < totalSplits; i++) {
              final start = i * 50;
              final end = (start + 50 < section.rows.length)
                  ? start + 50
                  : section.rows.length;

              splitSections.add(
                PdfReportSection(
                  title: '${section.title} (Part ${i + 1} of $totalSplits)',
                  rows: section.rows.sublist(start, end),
                ),
              );
            }
          } else {
            // Keep section as is
            splitSections.add(section);
          }
        }

        // Replace with the split sections
        limitedSections.clear();
        limitedSections.addAll(splitSections);
      }

      // Calculate how many PDFs we'll need
      int totalPdfs = (limitedSections.length / sectionsPerPdf).ceil();
      List<File> pdfFiles = [];

      // Generate PDFs sequentially instead of in parallel to avoid resource contention
      for (int i = 0; i < limitedSections.length; i += sectionsPerPdf) {
        int end = (i + sectionsPerPdf < limitedSections.length)
            ? i + sectionsPerPdf
            : limitedSections.length;
        List<PdfReportSection> sectionChunk = limitedSections.sublist(i, end);

        int pageNumber = (i ~/ sectionsPerPdf) + 1;

        // Log progress
        ErrorLogger.logInfo(
          'Generating PDF $pageNumber of $totalPdfs',
          context: 'PdfReportService.generatePaginatedPDFsInBackground',
        );

        // For calculations, distribute them across PDFs if there are many
        List<PdfCalculationSection>? pdfCalculations;
        if (calculations != null && calculations.isNotEmpty) {
          if (pageNumber == 1 || calculations.length <= 3) {
            // For short calculation lists or first PDF, include all or the first few
            pdfCalculations = pageNumber == 1
                ? (calculations.length > 4
                      ? calculations.sublist(0, 4)
                      : calculations)
                : null;
          } else if (totalPdfs > 1 && calculations.length > 4) {
            // Distribute remaining calculations across PDFs
            final calcPerPdf = (calculations.length - 4) ~/ (totalPdfs - 1);
            final startIdx = 4 + (pageNumber - 2) * calcPerPdf;
            final endIdx = pageNumber == totalPdfs
                ? calculations.length
                : math.min(startIdx + calcPerPdf, calculations.length);

            if (startIdx < endIdx) {
              pdfCalculations = calculations.sublist(startIdx, endIdx);
            }
          }
        }

        final params = PdfGenerationParams(
          reportTitle: '$reportTitle - Part $pageNumber of $totalPdfs',
          startDate: startDate,
          endDate: endDate,
          sections: sectionChunk,
          calculations: pdfCalculations,
          summaries: pageNumber == totalPdfs
              ? summaries
              : null, // Only include in last PDF
        );

        // Insert a delay between PDF generations to avoid resource contention
        if (i > 0) {
          await Future.delayed(const Duration(milliseconds: 300));
        }

        try {
          File pdfFile = await compute(_generatePdfInIsolate, params);
          pdfFiles.add(pdfFile);

          // Log success
          ErrorLogger.logInfo(
            'PDF $pageNumber of $totalPdfs generated successfully',
            context: 'PdfReportService.generatePaginatedPDFsInBackground',
          );
        } catch (e, stack) {
          ErrorLogger.logError(
            'Failed to generate PDF $pageNumber of $totalPdfs',
            error: e,
            stackTrace: stack,
            context: 'PdfReportService.generatePaginatedPDFsInBackground',
          );

          // Continue with other PDFs instead of failing completely
          continue;
        }
      }

      return pdfFiles;
    } finally {
      // Always release the semaphore when done
      _semaphore.release();
    }
  }

  /// Static method to be executed in isolate
  /// Method to be executed in isolate
  static Future<File> _generatePdfInIsolate(PdfGenerationParams params) async {
    try {
      // We'll skip Firebase initialization in the isolate and avoid using
      // Firebase-dependent code in the PDF generation

      debugPrint(
        '[PDF ISOLATE] Starting PDF generation: ${params.reportTitle}',
      );

      final service = PdfReportService();
      final file = await service.generateFinancialReport(
        reportTitle: params.reportTitle,
        startDate: params.startDate,
        endDate: params.endDate,
        sections: params.sections,
        calculations: params.calculations,
        summaries: params.summaries,
      );

      debugPrint(
        '[PDF ISOLATE] PDF generation completed: ${params.reportTitle}',
      );

      return file;
    } catch (e, stack) {
      debugPrint('[CRITICAL ERROR] PDF generation in isolate failed: $e');
      debugPrint('[CRITICAL ERROR] Stack trace: $stack');
      rethrow;
    } finally {
      // Clean up resources after PDF generation
      debugPrint(
        '[PDF ISOLATE] Cleaning up resources for: ${params.reportTitle}',
      );
    }
  }

  /// Apply data limits to all sections to prevent TooManyPagesException
  List<PdfReportSection> applyDataLimits(
    List<PdfReportSection> sections, {
    int maxRowsPerSection = 100,
    bool summaryOnly = false,
  }) {
    // Calculate total rows to gauge complexity
    int totalRows = sections.fold(
      0,
      (sum, section) => sum + section.rows.length,
    );

    // For extremely large data sets (>1000 rows), automatically apply summary mode
    if (totalRows > 1000 && !summaryOnly) {
      ErrorLogger.logInfo(
        'Applying summary-only mode due to large dataset ($totalRows rows)',
        context: 'PdfReportService.applyDataLimits',
      );
      summaryOnly = true;
      // Also reduce max rows per section for very large datasets
      if (maxRowsPerSection > 50) {
        maxRowsPerSection = 50;
      }
    }
    // For large data sets (>500 rows), further reduce rows per section
    else if (totalRows > 500 && maxRowsPerSection > 75) {
      maxRowsPerSection = 75;
      ErrorLogger.logInfo(
        'Reducing max rows per section to $maxRowsPerSection due to large dataset',
        context: 'PdfReportService.applyDataLimits',
      );
    }

    // If summary only is enabled, only include sections with "Summary" in the title
    if (summaryOnly) {
      sections = sections
          .where(
            (s) =>
                s.title.toLowerCase().contains('summary') ||
                s.title.toLowerCase().contains('total') ||
                s.rows.length <= 10, // Keep small sections
          )
          .toList();
    }

    // For large sections, apply stricter limits
    List<PdfReportSection> limitedSections = [];
    for (var section in sections) {
      // Apply different limits based on section size
      int sectionLimit = maxRowsPerSection;

      // For very large sections, apply even stricter limits
      if (section.rows.length > 200) {
        sectionLimit = math.min(maxRowsPerSection, 40); // Stricter limit
      }

      limitedSections.add(section.copyWithLimitedRows(sectionLimit));
    }

    return limitedSections;
  }

  /// Split sections into multiple PDFs to prevent TooManyPagesException
  Future<List<File>> generatePaginatedPDFs({
    required String reportTitle,
    required DateTime? startDate,
    required DateTime? endDate,
    required List<PdfReportSection> sections,
    List<PdfCalculationSection>? calculations,
    List<PdfSummarySection>? summaries,
    int sectionsPerPdf = 5,
  }) async {
    List<File> pdfFiles = [];

    // Calculate how many PDFs we'll need
    int totalPdfs = (sections.length / sectionsPerPdf).ceil();

    // Generate one PDF for each batch of sections
    for (int i = 0; i < sections.length; i += sectionsPerPdf) {
      int end = (i + sectionsPerPdf < sections.length)
          ? i + sectionsPerPdf
          : sections.length;
      List<PdfReportSection> sectionChunk = sections.sublist(i, end);

      int pageNumber = (i ~/ sectionsPerPdf) + 1;
      final file = await generateFinancialReport(
        reportTitle: '$reportTitle - Part $pageNumber of $totalPdfs',
        startDate: startDate,
        endDate: endDate,
        sections: sectionChunk,
        calculations: pageNumber == 1
            ? calculations
            : null, // Only include in first PDF
        summaries: pageNumber == totalPdfs
            ? summaries
            : null, // Only include in last PDF
      );

      pdfFiles.add(file);
    }

    return pdfFiles;
  }

  Future<File> generateFinancialReport({
    required String reportTitle,
    required DateTime? startDate,
    required DateTime? endDate,
    required List<PdfReportSection> sections,
    List<PdfCalculationSection>? calculations,
    List<PdfSummarySection>? summaries,
  }) async {
    try {
      debugPrint('[PDF] Starting PDF generation for: $reportTitle');
      debugPrint(
        '[PDF] Sections: ${sections.length}, Calculations: ${calculations?.length ?? 0}, Summaries: ${summaries?.length ?? 0}',
      );

      final doc = pw.Document();
      final df = DateFormat('yyyy-MM-dd');

      doc.addPage(
        pw.MultiPage(
          pageFormat: PdfPageFormat.a4,
          // Set maxPages high enough to handle reasonable content
          maxPages: 100,
          footer: (context) => pw.Align(
            alignment: pw.Alignment.centerRight,
            child: pw.Text(
              'Page ${context.pageNumber} of ${context.pagesCount}',
              style: const pw.TextStyle(fontSize: 9, color: PdfColors.grey700),
            ),
          ),
          build: (context) => [
            pw.Header(
              level: 0,
              child: pw.Row(
                mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                children: [
                  pw.Expanded(
                    child: pw.Text(
                      reportTitle,
                      style: pw.TextStyle(
                        fontSize: 18,
                        fontWeight: pw.FontWeight.bold,
                      ),
                    ),
                  ),
                  pw.Text(
                    startDate != null && endDate != null
                        ? '${df.format(startDate)} - ${df.format(endDate)}'
                        : 'All Time',
                    style: const pw.TextStyle(fontSize: 10),
                  ),
                ],
              ),
            ),
            ...sections.map((s) => _buildSection(s)),
            if (calculations != null)
              ...calculations.map((c) => _buildCalculation(c)),
            if (summaries != null) ...summaries.map((s) => _buildSummary(s)),
            pw.SizedBox(height: 16),
            pw.Align(
              alignment: pw.Alignment.centerRight,
              child: pw.Text(
                'Generated on ${DateFormat('yyyy-MM-dd HH:mm').format(DateTime.now())}',
                style: const pw.TextStyle(
                  fontSize: 9,
                  color: PdfColors.grey700,
                ),
              ),
            ),
          ],
        ),
      );

      debugPrint('[PDF] Building document structure');

      // Try to find a writable directory by testing
      Directory? directoryToUse;
      try {
        debugPrint('[PDF] Finding writable storage directory');

        // Try to use the Download directory directly first
        if (Platform.isAndroid) {
          // Try the requested path first
          final downloadDir = Directory('/My Phone/Internal Storage/Download');
          bool canCreateDir = false;

          try {
            if (await downloadDir.exists()) {
              canCreateDir = true;
            } else {
              await downloadDir.create(recursive: true);
              canCreateDir = await downloadDir.exists();
            }
          } catch (e) {
            debugPrint('[PDF] Error creating directory: $e');
            canCreateDir = false;
          }

          if (canCreateDir) {
            // Test if we can write to this directory
            try {
              final testFile = File(
                '${downloadDir.path}/test_write_access.txt',
              );
              await testFile.writeAsString(
                'Test write access: ${DateTime.now()}',
              );
              if (await testFile.exists()) {
                await testFile.delete();
                debugPrint(
                  '[PDF] Using requested Download directory: ${downloadDir.path}',
                );
                directoryToUse = downloadDir;
                // If this succeeds, don't try other directories
              }
            } catch (e) {
              debugPrint(
                '[PDF] Cannot write to Download directory, will try alternatives: $e',
              );
            }
          }
        }

        // If we couldn't use the Download directory, find another writable directory
        if (directoryToUse == null) {
          // Use the test function to find a directory we can actually write to
          directoryToUse = await _testStorage();
          debugPrint(
            '[PDF] Selected storage directory: ${directoryToUse.path}',
          );
        }
      } catch (e) {
        debugPrint('[PDF] Failed to find writable storage directory: $e');

        // Last resort - use temporary directory which should work in isolates
        debugPrint('[PDF] Using temporary directory as last resort');
        directoryToUse = await getTemporaryDirectory();
      }

      Directory dir = directoryToUse;

      // Check that directory is valid and exists
      if (!(await dir.exists())) {
        debugPrint('[PDF] Directory does not exist: ${dir.path}, creating it');
        await dir.create(recursive: true);
      }

      debugPrint('[PDF] Using directory: ${dir.path}');

      // Generate filename based on report title
      String baseFileName = 'financial_report';
      if (reportTitle.toLowerCase().contains('sales')) {
        baseFileName = 'sales_report';
      } else if (reportTitle.toLowerCase().contains('inventory')) {
        baseFileName = 'inventory_report';
      } else if (reportTitle.toLowerCase().contains('customer')) {
        baseFileName = 'customer_report';
      } else if (reportTitle.toLowerCase().contains('staff')) {
        baseFileName = 'staff_report';
      } else if (reportTitle.toLowerCase().contains('financial')) {
        baseFileName = 'financial_report';
      }

      final fileName =
          '${baseFileName}_${DateTime.now().millisecondsSinceEpoch}.pdf';
      var file = File(p.join(dir.path, fileName));

      debugPrint('[PDF] Saving PDF to: ${file.path}');

      try {
        debugPrint('[PDF] About to generate PDF bytes...');
        final pdfBytes = await doc.save();
        debugPrint('[PDF] PDF generated, size: ${pdfBytes.length} bytes');

        // Check if directory exists and is writable
        final parentDir = file.parent;
        if (!await parentDir.exists()) {
          debugPrint('[PDF] Creating parent directory: ${parentDir.path}');
          try {
            await parentDir.create(recursive: true);
            debugPrint('[PDF] Parent directory created successfully');
          } catch (e) {
            debugPrint('[PDF] Error creating parent directory: $e');
            // Try a fallback location if we can't create the directory
            dir = await getTemporaryDirectory();
            debugPrint(
              '[PDF] Falling back to temporary directory: ${dir.path}',
            );
            final fileName =
                '${baseFileName}_${DateTime.now().millisecondsSinceEpoch}.pdf';
            file = File(p.join(dir.path, fileName));
          }
        }

        // Write file
        debugPrint('[PDF] Writing file to: ${file.path}');
        try {
          await file.writeAsBytes(pdfBytes);
          debugPrint('[PDF] File written successfully');
        } catch (e) {
          debugPrint('[PDF] Error writing file: $e');
          // Try one more fallback to the cache directory
          dir = await getTemporaryDirectory();
          final fileName =
              '${baseFileName}_${DateTime.now().millisecondsSinceEpoch}.pdf';
          file = File(p.join(dir.path, fileName));
          debugPrint('[PDF] Final fallback attempt to: ${file.path}');
          await file.writeAsBytes(pdfBytes);
        }

        // Verify file was created
        final exists = await file.exists();
        final fileSize = exists ? await file.length() : 0;

        debugPrint(
          '[PDF] PDF saved successfully: ${file.path}, exists: $exists, size: $fileSize bytes',
        );

        // Log additional information about the file path for debugging
        if (exists) {
          debugPrint('[PDF] Full absolute path: ${file.absolute.path}');
          debugPrint('[PDF] Parent directory: ${file.parent.path}');

          // On Android, also try to make sure the file is accessible in the media store
          if (Platform.isAndroid && dir.path.contains('/Download')) {
            try {
              // Log that the file should be visible in Downloads
              debugPrint('[PDF] PDF should be visible in Downloads folder');
            } catch (e) {
              debugPrint('[PDF] Note: Media scanning not available: $e');
            }
          }
        }
      } catch (e, stack) {
        debugPrint('[PDF] Failed to write PDF file: $e');
        debugPrint('[PDF] Stack trace: $stack');
        rethrow;
      }

      return file;
    } catch (e, stack) {
      debugPrint('[PDF] Error generating PDF: $e');
      debugPrint('[PDF] Stack trace: $stack');
      rethrow;
    }
  }

  pw.Widget _buildSection(PdfReportSection section) {
    return pw.Container(
      margin: const pw.EdgeInsets.only(bottom: 16),
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          // Section title with numbering
          pw.Container(
            width: double.infinity,
            padding: const pw.EdgeInsets.symmetric(vertical: 6),
            child: pw.Text(
              section.title,
              style: pw.TextStyle(
                fontSize: 14,
                fontWeight: pw.FontWeight.bold,
                color: PdfColors.black,
              ),
            ),
          ),
          pw.SizedBox(height: 8),

          // Table with clean formatting
          _buildFlexibleTable(section),
        ],
      ),
    );
  }

  String _getHeaderText(String sectionTitle) {
    final lower = sectionTitle.toLowerCase();
    if (lower.contains('income')) return 'Product';
    if (lower.contains('cogs') || lower.contains('cost')) return 'Product';
    if (lower.contains('expense')) return 'Expense Item';
    if (lower.contains('cash flow')) return 'Description';
    if (lower.contains('inventory distribution')) return 'Category';
    return 'Description';
  }

  pw.Widget _buildFlexibleTable(PdfReportSection section) {
    final hasAtLeastThreeColumns =
        section.rows.isNotEmpty && section.rows.first.length >= 3;
    final hasFourColumns =
        section.rows.isNotEmpty && section.rows.first.length >= 4;

    if (!hasAtLeastThreeColumns) {
      // Fallback to 2-column table (label, amount)
      return pw.Table(
        border: pw.TableBorder.all(color: PdfColors.black, width: 0.5),
        columnWidths: {
          0: const pw.FlexColumnWidth(3),
          1: const pw.FlexColumnWidth(2),
        },
        children: [
          pw.TableRow(
            decoration: const pw.BoxDecoration(color: PdfColors.grey200),
            children: [
              pw.Padding(
                padding: const pw.EdgeInsets.all(6),
                child: pw.Text(
                  _getHeaderText(section.title),
                  style: pw.TextStyle(
                    fontWeight: pw.FontWeight.bold,
                    fontSize: 11,
                  ),
                ),
              ),
              pw.Padding(
                padding: const pw.EdgeInsets.all(6),
                child: pw.Text(
                  'Amount',
                  style: pw.TextStyle(
                    fontWeight: pw.FontWeight.bold,
                    fontSize: 11,
                  ),
                  textAlign: pw.TextAlign.right,
                ),
              ),
            ],
          ),
          for (int i = 0; i < section.rows.length; i++)
            pw.TableRow(
              children: [
                pw.Padding(
                  padding: const pw.EdgeInsets.all(6),
                  child: pw.Text(
                    section.rows[i][0],
                    style: pw.TextStyle(fontSize: 10),
                  ),
                ),
                pw.Padding(
                  padding: const pw.EdgeInsets.all(6),
                  child: pw.Text(
                    _stripCurrencySymbols(section.rows[i][1]),
                    style: pw.TextStyle(
                      fontSize: 10,
                      fontWeight:
                          _isTotalRow(section.rows[i][0]) ||
                              _isNumericValue(section.rows[i][1])
                          ? pw.FontWeight.bold
                          : pw.FontWeight.normal,
                    ),
                    textAlign: pw.TextAlign.right,
                  ),
                ),
              ],
            ),
        ],
      );
    }

    if (hasFourColumns) {
      // 4-column table: product, quantity, price, amount
      return pw.Table(
        border: pw.TableBorder.all(color: PdfColors.black, width: 0.5),
        columnWidths: {
          0: const pw.FlexColumnWidth(3),
          1: const pw.FlexColumnWidth(1),
          2: const pw.FlexColumnWidth(1.5),
          3: const pw.FlexColumnWidth(2),
        },
        children: [
          pw.TableRow(
            decoration: const pw.BoxDecoration(color: PdfColors.grey200),
            children: [
              pw.Padding(
                padding: const pw.EdgeInsets.all(6),
                child: pw.Text(
                  'Product',
                  style: pw.TextStyle(
                    fontWeight: pw.FontWeight.bold,
                    fontSize: 11,
                  ),
                ),
              ),
              pw.Padding(
                padding: const pw.EdgeInsets.all(6),
                child: pw.Text(
                  'Quantity',
                  style: pw.TextStyle(
                    fontWeight: pw.FontWeight.bold,
                    fontSize: 11,
                  ),
                  textAlign: pw.TextAlign.right,
                ),
              ),
              pw.Padding(
                padding: const pw.EdgeInsets.all(6),
                child: pw.Text(
                  'Price',
                  style: pw.TextStyle(
                    fontWeight: pw.FontWeight.bold,
                    fontSize: 11,
                  ),
                  textAlign: pw.TextAlign.right,
                ),
              ),
              pw.Padding(
                padding: const pw.EdgeInsets.all(6),
                child: pw.Text(
                  'Amount',
                  style: pw.TextStyle(
                    fontWeight: pw.FontWeight.bold,
                    fontSize: 11,
                  ),
                  textAlign: pw.TextAlign.right,
                ),
              ),
            ],
          ),
          for (int i = 0; i < section.rows.length; i++)
            pw.TableRow(
              children: [
                pw.Padding(
                  padding: const pw.EdgeInsets.all(6),
                  child: pw.Text(
                    section.rows[i][0],
                    style: pw.TextStyle(fontSize: 10),
                  ),
                ),
                pw.Padding(
                  padding: const pw.EdgeInsets.all(6),
                  child: pw.Text(
                    section.rows[i][1],
                    style: const pw.TextStyle(fontSize: 10),
                    textAlign: pw.TextAlign.right,
                  ),
                ),
                pw.Padding(
                  padding: const pw.EdgeInsets.all(6),
                  child: pw.Text(
                    _stripCurrencySymbols(section.rows[i][2]),
                    style: const pw.TextStyle(fontSize: 10),
                    textAlign: pw.TextAlign.right,
                  ),
                ),
                pw.Padding(
                  padding: const pw.EdgeInsets.all(6),
                  child: pw.Text(
                    _stripCurrencySymbols(section.rows[i][3]),
                    style: pw.TextStyle(
                      fontSize: 10,
                      fontWeight:
                          _isTotalRow(section.rows[i][0]) ||
                              _isNumericValue(section.rows[i][3])
                          ? pw.FontWeight.bold
                          : pw.FontWeight.normal,
                    ),
                    textAlign: pw.TextAlign.right,
                  ),
                ),
              ],
            ),
        ],
      );
    }

    // 3-column table: product, quantity, amount
    final isInventoryDistribution = section.title.toLowerCase().contains(
      'inventory distribution',
    );
    return pw.Table(
      border: pw.TableBorder.all(color: PdfColors.black, width: 0.5),
      columnWidths: {
        0: const pw.FlexColumnWidth(3),
        1: const pw.FlexColumnWidth(1),
        2: const pw.FlexColumnWidth(2),
      },
      children: [
        pw.TableRow(
          decoration: const pw.BoxDecoration(color: PdfColors.grey200),
          children: [
            pw.Padding(
              padding: const pw.EdgeInsets.all(6),
              child: pw.Text(
                isInventoryDistribution ? 'Category' : 'Product',
                style: pw.TextStyle(
                  fontWeight: pw.FontWeight.bold,
                  fontSize: 11,
                ),
              ),
            ),
            pw.Padding(
              padding: const pw.EdgeInsets.all(6),
              child: pw.Text(
                isInventoryDistribution ? 'Distribution' : 'Quantity',
                style: pw.TextStyle(
                  fontWeight: pw.FontWeight.bold,
                  fontSize: 11,
                ),
                textAlign: pw.TextAlign.right,
              ),
            ),
            pw.Padding(
              padding: const pw.EdgeInsets.all(6),
              child: pw.Text(
                isInventoryDistribution ? 'Quantity' : 'Amount',
                style: pw.TextStyle(
                  fontWeight: pw.FontWeight.bold,
                  fontSize: 11,
                ),
                textAlign: pw.TextAlign.right,
              ),
            ),
          ],
        ),
        for (int i = 0; i < section.rows.length; i++)
          pw.TableRow(
            children: [
              pw.Padding(
                padding: const pw.EdgeInsets.all(6),
                child: pw.Text(
                  section.rows[i][0],
                  style: pw.TextStyle(fontSize: 10),
                ),
              ),
              pw.Padding(
                padding: const pw.EdgeInsets.all(6),
                child: pw.Text(
                  section.rows[i][1],
                  style: const pw.TextStyle(fontSize: 10),
                  textAlign: pw.TextAlign.right,
                ),
              ),
              pw.Padding(
                padding: const pw.EdgeInsets.all(6),
                child: pw.Text(
                  _stripCurrencySymbols(section.rows[i][2]),
                  style: pw.TextStyle(
                    fontSize: 10,
                    fontWeight:
                        _isTotalRow(section.rows[i][0]) ||
                            _isNumericValue(section.rows[i][2])
                        ? pw.FontWeight.bold
                        : pw.FontWeight.normal,
                  ),
                  textAlign: pw.TextAlign.right,
                ),
              ),
            ],
          ),
      ],
    );
  }

  bool _isTotalRow(String text) {
    return text.toLowerCase().contains('total') ||
        text.toLowerCase().contains('net profit') ||
        text.toLowerCase().contains('gross profit');
  }

  pw.Widget _buildCalculation(PdfCalculationSection calculation) {
    return pw.Container(
      margin: const pw.EdgeInsets.only(bottom: 16),
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          // Section title
          pw.Container(
            width: double.infinity,
            padding: const pw.EdgeInsets.symmetric(vertical: 6),
            child: pw.Text(
              calculation.title,
              style: pw.TextStyle(
                fontSize: 14,
                fontWeight: pw.FontWeight.bold,
                color: PdfColors.black,
              ),
            ),
          ),
          pw.SizedBox(height: 8),

          // Formula
          pw.Container(
            width: double.infinity,
            padding: const pw.EdgeInsets.all(8),
            decoration: pw.BoxDecoration(
              border: pw.Border.all(color: PdfColors.black, width: 0.5),
            ),
            child: pw.Text(
              'Formula: ${calculation.formula}',
              style: pw.TextStyle(fontSize: 11, fontWeight: pw.FontWeight.bold),
              textAlign: pw.TextAlign.center,
            ),
          ),
          pw.SizedBox(height: 8),

          // Calculation
          pw.Container(
            width: double.infinity,
            padding: const pw.EdgeInsets.all(8),
            decoration: pw.BoxDecoration(
              color: PdfColors.grey200,
              border: pw.Border.all(color: PdfColors.black, width: 0.5),
            ),
            child: pw.Text(
              'Calculation: ${calculation.calculation}',
              style: pw.TextStyle(
                fontSize: 11,
                fontWeight: pw.FontWeight.normal,
              ),
              textAlign: pw.TextAlign.center,
            ),
          ),
          pw.SizedBox(height: 8),

          // Result
          pw.Container(
            width: double.infinity,
            padding: const pw.EdgeInsets.all(8),
            decoration: pw.BoxDecoration(
              color: PdfColors.grey100,
              border: pw.Border.all(color: PdfColors.black, width: 0.5),
            ),
            child: pw.Text(
              'Result: ${_stripCurrencySymbols(calculation.result)}',
              style: pw.TextStyle(fontSize: 12, fontWeight: pw.FontWeight.bold),
              textAlign: pw.TextAlign.center,
            ),
          ),
        ],
      ),
    );
  }

  pw.Widget _buildSummary(PdfSummarySection summary) {
    return pw.Container(
      margin: const pw.EdgeInsets.only(bottom: 16),
      child: pw.Row(
        mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
        children: [
          pw.Text(
            summary.title,
            style: pw.TextStyle(fontSize: 12, fontWeight: pw.FontWeight.bold),
          ),
          pw.Text(
            _stripCurrencySymbols(summary.value),
            style: pw.TextStyle(fontSize: 12, fontWeight: pw.FontWeight.bold),
          ),
        ],
      ),
    );
  }

  String _stripCurrencySymbols(String value) {
    // Remove currency symbols that the default PDF font may not support
    final withoutSymbols = value
        .replaceAll('₱', '') // Peso symbol
        .replaceAll(RegExp(r'[₱$€£¥₹¢]'), '') // Other currency symbols
        .replaceAll('PHP', '') // PHP currency code
        .replaceAll('P', '') // Sometimes P is used for peso
        .trim();
    return withoutSymbols;
  }

  bool _isNumericValue(String value) {
    // Check if the value looks like a currency amount or percentage
    return value.contains('₱') ||
        value.contains('%') ||
        value.contains('x') ||
        RegExp(r'^\d+\.?\d*$').hasMatch(value.replaceAll(',', ''));
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\printing_service.dart
â•‘ SIZE: 12.03 KB
â•‘ MODIFIED: 09/17/2025 01:35:50
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:bluetooth_thermal_printer_plus/bluetooth_thermal_printer_plus.dart';
import 'package:esc_pos_utils_plus/esc_pos_utils_plus.dart';
import 'package:flutter/foundation.dart';
import 'package:prostock/models/bluetooth_device.dart';
import 'package:prostock/models/receipt.dart';
import 'package:shared_preferences/shared_preferences.dart';

class PrintingService with ChangeNotifier {
  static final PrintingService _instance = PrintingService._internal();
  factory PrintingService() => _instance;
  PrintingService._internal();

  bool _isConnected = false;
  String? _connectedDeviceAddress;
  String? _connectedDeviceName;
  PaperSize _paperSize = PaperSize.mm80;

  bool get isConnected => _isConnected;
  String? get connectedDeviceAddress => _connectedDeviceAddress;
  String? get connectedDeviceName => _connectedDeviceName;
  PaperSize get paperSize => _paperSize;

  Future<void> loadPaperSize() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final paperSizeName = prefs.getString('paper_size');

      if (paperSizeName == 'mm58') {
        _paperSize = PaperSize.mm58;
      } else {
        _paperSize = PaperSize.mm80; // default
      }
    } catch (e) {
      if (kDebugMode) {
        print('Error loading paper size: $e');
      }
    }
    notifyListeners();
  }

  Future<void> savePaperSize(PaperSize paperSize) async {
    try {
      final prefs = await SharedPreferences.getInstance();

      String paperSizeName;
      if (paperSize == PaperSize.mm58) {
        paperSizeName = 'mm58';
      } else {
        paperSizeName = 'mm80';
      }

      await prefs.setString('paper_size', paperSizeName);
      _paperSize = paperSize;

      if (kDebugMode) {
        print('Saved paper size: $paperSizeName');
      }
    } catch (e) {
      if (kDebugMode) {
        print('Error saving paper size: $e');
      }
    }
    notifyListeners();
  }

  Future<List<BluetoothDevice>> getBluetooths() async {
    try {
      final devices = await BluetoothThermalPrinter.getBluetooths ?? [];
      return devices.map((device) {
        String name = 'Unknown Device';
        String address = '';
        if (device is String && device.contains('#')) {
          final parts = device.split('#');
          if (parts.length == 2) {
            name = parts[0];
            address = parts[1];
          }
        } else if (device is Map) {
          name = device['name'] ?? 'Unknown Device';
          address = device['address'] ?? '';
        }
        return BluetoothDevice(name: name, address: address);
      }).toList();
    } catch (e) {
      if (kDebugMode) {
        print('Error getting bluetooth devices: $e');
      }
      rethrow; // Re-throw to allow UI to handle the error
    }
  }

  Future<bool> connect(BluetoothDevice device) async {
    if (kDebugMode) {
      print('Connect called with device: ${device.name}');
    }

    if (device.address.isEmpty) {
      if (kDebugMode) {
        print('Device address is null or empty for device: ${device.name}');
      }
      return false;
    }

    try {
      if (kDebugMode) {
        print('Attempting to connect to: ${device.name} (${device.address})');
      }

      final result = await BluetoothThermalPrinter.connect(device.address);
      if (kDebugMode) {
        print('Connection result: $result');
      }

      if (result == 'true') {
        _isConnected = true;
        _connectedDeviceAddress = device.address;
        _connectedDeviceName = device.name;
        await saveDefaultPrinter(device.address);
        notifyListeners();

        if (kDebugMode) {
          print('Successfully connected to ${device.name}');
        }
        return true;
      } else {
        if (kDebugMode) {
          print('Connection failed with result: $result');
        }
      }
    } catch (e) {
      if (kDebugMode) {
        print('Error connecting to printer: $e');
        print('Stack trace: ${StackTrace.current}');
      }
      // Reset connection state on error
      _isConnected = false;
      _connectedDeviceAddress = null;
      _connectedDeviceName = null;
      notifyListeners();
    }
    return false;
  }

  Future<void> disconnect() async {
    try {
      await BluetoothThermalPrinter.disconnect(); // Fixed: Added parentheses
      if (kDebugMode) {
        print('Disconnected from printer');
      }
    } catch (e) {
      if (kDebugMode) {
        print('Error disconnecting: $e');
      }
    } finally {
      // Always reset the connection state
      _isConnected = false;
      _connectedDeviceAddress = null;
      _connectedDeviceName = null;
      notifyListeners();
    }
  }

  Future<void> saveDefaultPrinter(String address) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('default_printer_address', address);
      if (kDebugMode) {
        print('Saved default printer: $address');
      }
    } catch (e) {
      if (kDebugMode) {
        print('Error saving default printer: $e');
      }
    }
  }

  Future<String?> loadDefaultPrinter() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final address = prefs.getString('default_printer_address');
      if (kDebugMode) {
        print('Loaded default printer: $address');
      }
      return address;
    } catch (e) {
      if (kDebugMode) {
        print('Error loading default printer: $e');
      }
      return null;
    }
  }

  Future<bool> printTest() async {
    if (!_isConnected) {
      if (kDebugMode) {
        print('Cannot print: No printer connected');
      }
      return false;
    }

    try {
      final List<int> bytes = await _generateTestTicket();
      await BluetoothThermalPrinter.writeBytes(bytes);
      if (kDebugMode) {
        print('Test print sent successfully');
      }
      return true;
    } catch (e) {
      if (kDebugMode) {
        print('Error printing test: $e');
      }
      return false;
    }
  }

  Future<bool> printReceipt(
    Receipt receipt, {
    double? cashTendered,
    double? change,
  }) async {
    if (!_isConnected) {
      if (kDebugMode) {
        print('Cannot print receipt: No printer connected');
      }
      return false;
    }

    try {
      final List<int> bytes = await _generateReceiptTicket(
        receipt,
        cashTendered: cashTendered,
        change: change,
      );
      await BluetoothThermalPrinter.writeBytes(bytes);
      if (kDebugMode) {
        print('Receipt printed successfully');
      }
      return true;
    } catch (e) {
      if (kDebugMode) {
        print('Error printing receipt: $e');
      }
      return false;
    }
  }

  Future<List<int>> _generateTestTicket() async {
    final profile = await CapabilityProfile.load();
    final generator = Generator(_paperSize, profile);
    List<int> bytes = [];

    bytes += generator.text(
      'ProStock POS',
      styles: const PosStyles(
        align: PosAlign.center,
        height: PosTextSize.size2,
        width: PosTextSize.size2,
        bold: true,
      ),
    );
    bytes += generator.feed(1);
    bytes += generator.text(
      'Test Print',
      styles: const PosStyles(align: PosAlign.center, bold: true),
    );
    bytes += generator.feed(1);
    bytes += generator.text(
      'Connection Successful!',
      styles: const PosStyles(align: PosAlign.center),
    );
    bytes += generator.feed(1);
    bytes += generator.text(
      'Printer: $_connectedDeviceName',
      styles: const PosStyles(align: PosAlign.center),
    );
    bytes += generator.text(
      'Address: $_connectedDeviceAddress',
      styles: const PosStyles(align: PosAlign.center),
    );
    bytes += generator.feed(1);
    bytes += generator.text(
      DateTime.now().toString(),
      styles: const PosStyles(align: PosAlign.center),
    );
    bytes += generator.hr();
    bytes += generator.feed(2);
    bytes += generator.cut();

    return bytes;
  }

  Future<List<int>> _generateReceiptTicket(
    Receipt receipt, {
    double? cashTendered,
    double? change,
  }) async {
    final profile = await CapabilityProfile.load();
    final generator = Generator(_paperSize, profile);
    List<int> bytes = [];

    // Header
    bytes += generator.text(
      'RETAIL CREDIT MANAGER',
      styles: const PosStyles(align: PosAlign.center, bold: true),
    );
    bytes += generator.feed(1);
    bytes += generator.text(
      'Receipt: ${receipt.formattedReceiptNumber}',
      styles: const PosStyles(align: PosAlign.center),
    );
    bytes += generator.text(
      receipt.formattedTimestamp,
      styles: const PosStyles(align: PosAlign.center),
    );
    bytes += generator.hr();

    // Customer and Payment Info - Single line format for 58mm
    bytes += generator.text(
      'Customer: ${receipt.customerName ?? 'Walk-in Customer'}',
      styles: const PosStyles(align: PosAlign.left),
    );
    bytes += generator.text(
      'Payment: ${receipt.paymentMethod.toUpperCase()}',
      styles: const PosStyles(align: PosAlign.left),
    );
    bytes += generator.hr();

    // Items - Simplified format for 58mm
    bytes += generator.text(
      'ITEMS',
      styles: const PosStyles(align: PosAlign.center, bold: true),
    );
    bytes += generator.hr(ch: '-');

    // Each item on multiple lines for better readability on 58mm
    for (final item in receipt.items) {
      // Product name
      bytes += generator.text(
        item.productName,
        styles: const PosStyles(bold: true),
      );

      // Quantity, price, and total on one line
      bytes += generator.row([
        PosColumn(
          text: '${item.quantity} x PHP${item.unitPrice.toStringAsFixed(2)}',
          width: 8,
          styles: const PosStyles(align: PosAlign.left),
        ),
        PosColumn(
          text: 'PHP${item.totalPrice.toStringAsFixed(2)}',
          width: 4,
          styles: const PosStyles(align: PosAlign.right),
        ),
      ]);
      bytes += generator.feed(1);
    }

    bytes += generator.hr();

    // Totals - Right aligned for 58mm
    bytes += generator.row([
      PosColumn(
        text: 'Subtotal',
        width: 8,
        styles: const PosStyles(align: PosAlign.left),
      ),
      PosColumn(
        text: 'PHP${receipt.subtotal.toStringAsFixed(2)}',
        width: 4,
        styles: const PosStyles(align: PosAlign.right),
      ),
    ]);

    bytes += generator.row([
      PosColumn(
        text: 'TOTAL',
        width: 8,
        styles: const PosStyles(align: PosAlign.left, bold: true),
      ),
      PosColumn(
        text: 'PHP${receipt.total.toStringAsFixed(2)}',
        width: 4,
        styles: const PosStyles(align: PosAlign.right, bold: true),
      ),
    ]);

    // Cash and change information
    if (cashTendered != null && cashTendered > 0) {
      bytes += generator.row([
        PosColumn(
          text: 'Cash Tendered',
          width: 8,
          styles: const PosStyles(align: PosAlign.left),
        ),
        PosColumn(
          text: 'PHP${cashTendered.toStringAsFixed(2)}',
          width: 4,
          styles: const PosStyles(align: PosAlign.right),
        ),
      ]);
    }

    if (change != null && change > 0) {
      bytes += generator.row([
        PosColumn(
          text: 'Change',
          width: 8,
          styles: const PosStyles(align: PosAlign.left, bold: true),
        ),
        PosColumn(
          text: 'PHP${change.toStringAsFixed(2)}',
          width: 4,
          styles: const PosStyles(align: PosAlign.right, bold: true),
        ),
      ]);
    }

    bytes += generator.hr(ch: '=');

    // Footer
    bytes += generator.feed(1);
    bytes += generator.text(
      'Thank you for your business!',
      styles: const PosStyles(align: PosAlign.center, bold: true),
    );
    bytes += generator.feed(2);
    bytes += generator.cut();

    return bytes;
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\report_service.dart
â•‘ SIZE: 14.95 KB
â•‘ MODIFIED: 10/27/2025 08:49:05
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/models/customer.dart';
import 'package:prostock/models/loss.dart';
import 'package:prostock/models/product.dart';
import 'package:prostock/models/sale.dart';
import 'package:prostock/models/sale_item.dart';
import 'package:prostock/models/credit_transaction.dart';
import 'package:prostock/models/stock_movement.dart';
import 'package:prostock/models/tax_rule.dart';
import 'package:prostock/services/tax_service.dart';
import 'package:prostock/services/tax_rules_service.dart';

class ReportService {
  // Sales calculations
  // Treat only cash-like sales as sales (exclude credit checkouts and payment entries)
  double calculateTotalSales(List<Sale> sales) {
    return sales
        .where((s) => _isCashLikeSale(s.paymentMethod))
        .fold(0.0, (sum, sale) => sum + sale.totalAmount);
  }

  double calculateTodaySales(List<Sale> sales) {
    final today = DateTime.now();
    return sales
        .where((s) => _isCashLikeSale(s.paymentMethod))
        .where(
          (sale) =>
              sale.createdAt.day == today.day &&
              sale.createdAt.month == today.month &&
              sale.createdAt.year == today.year,
        )
        .fold(0.0, (sum, sale) => sum + sale.totalAmount);
  }

  double calculateTotalCreditReceived(List<Sale> sales) {
    return sales
        .where((sale) {
          final method = sale.paymentMethod.toLowerCase();
          return method == 'credit payment' ||
              method == 'credit_payment' ||
              method == 'debt payment' ||
              method == 'debt_payment';
        })
        .fold(0.0, (sum, sale) => sum + sale.totalAmount);
  }

  // New: Calculate total credit payments from credit transactions (preferred source)
  double calculateTotalCreditPayments(List<CreditTransaction> transactions) {
    return transactions
        .where((t) => t.type.toLowerCase() == 'payment')
        .fold(0.0, (sum, t) => sum + t.amount);
  }

  // Customer calculations
  int calculateTotalCustomers(List<Customer> customers) {
    return customers.length;
  }

  int calculateCustomersWithBalance(List<Customer> customers) {
    return customers.where((c) => c.balance > 0).length;
  }

  double calculateTotalBalance(List<Customer> customers) {
    return customers.fold(0.0, (sum, c) => sum + c.balance);
  }

  // Financial calculations - CORRECTED VERSIONS

  /// Calculate total revenue: cash-like sales + credit payments
  double calculateTotalRevenue(List<Sale> sales) {
    final cashLike = sales
        .where((s) => _isCashLikeSale(s.paymentMethod))
        .fold(0.0, (sum, s) => sum + s.totalAmount);
    final creditPayments = calculateTotalCreditReceived(sales);
    return cashLike + creditPayments;
  }

  /// Calculate Cost of Goods Sold (COGS) based on actual items sold
  /// This uses the unitCost captured at the time of sale for exact COGS
  /// Falls back to current product cost if unitCost is missing (for old sales)
  double calculateTotalCost(List<SaleItem> saleItems, List<Product> products) {
    // Create product lookup map for fallback
    final productMap = {for (var p in products) p.id: p};

    return saleItems.fold(0.0, (sum, item) {
      // Use unitCost from sale item (captured at time of sale)
      if (item.unitCost > 0) {
        return sum + (item.quantity * item.unitCost);
      }

      // FALLBACK: For old sales without unitCost, use current product cost
      // This happens with pre-FIFO sales data
      final product = productMap[item.productId];
      if (product != null) {
        return sum + (item.quantity * product.cost);
      }

      // If product not found, skip this item
      return sum;
    });
  }

  // Calculate COGS for credit purchases from transaction items (uses unitCost from items)
  // Falls back to current product cost if unitCost is missing (for old credit sales)
  double calculateTotalCostFromCreditTransactions(
    List<CreditTransaction> transactions,
    List<Product> products,
  ) {
    // Create product lookup map for fallback
    final productMap = {for (var p in products) p.id: p};

    double total = 0.0;
    for (final tx in transactions.where(
      (t) => t.type.toLowerCase() == 'purchase',
    )) {
      for (final item in tx.items) {
        // Use unitCost from credit sale item (captured at time of sale)
        if (item.unitCost > 0) {
          total += item.unitCost * item.quantity;
        } else {
          // FALLBACK: For old credit sales without unitCost, use current product cost
          final product = productMap[item.productId];
          if (product != null) {
            total += product.cost * item.quantity;
          }
        }
      }
    }
    return total;
  }

  /// Calculate total losses (damaged goods, expired items, etc.)
  double calculateTotalLoss(List<Loss> losses) {
    return losses.fold(0.0, (sum, loss) => sum + loss.totalCost);
  }

  /// Calculate Gross Profit
  /// Formula: Revenue - COGS - Losses
  double calculateGrossProfit(
    double totalRevenue,
    double totalCost,
    double totalLoss,
  ) {
    return totalRevenue - totalCost - totalLoss;
  }

  /// Calculate Net Profit (if you want to include operating expenses)
  /// Formula: Gross Profit - Operating Expenses
  double calculateNetProfit(double grossProfit, double operatingExpenses) {
    return grossProfit - operatingExpenses;
  }

  /// Calculate Gross Profit Margin
  /// Formula: (Gross Profit / Revenue) × 100
  double calculateProfitMargin(double grossProfit, double totalRevenue) {
    if (totalRevenue == 0) {
      return 0.0;
    }
    return (grossProfit / totalRevenue) * 100;
  }

  /// Calculate Return on Investment (ROI)
  /// Formula: (Net Profit / Total Investment) × 100
  /// Using COGS as investment proxy since we don't have initial investment data
  double calculateRoi(double grossProfit, double totalCost) {
    if (totalCost == 0) {
      return 0.0;
    }
    return (grossProfit / totalCost) * 100;
  }

  /// Alternative ROI calculation using markup percentage
  /// Formula: ((Selling Price - Cost Price) / Cost Price) × 100
  double calculateMarkupPercentage(double totalRevenue, double totalCost) {
    if (totalCost == 0) {
      return 0.0;
    }
    return ((totalRevenue - totalCost) / totalCost) * 100;
  }

  /// Calculate inventory turnover ratio
  /// Formula: COGS / Average Inventory Value
  double calculateInventoryTurnover(
    double totalCost,
    double averageInventoryValue,
  ) {
    if (averageInventoryValue == 0) {
      return 0.0;
    }
    return totalCost / averageInventoryValue;
  }

  /// Calculate days in inventory
  /// Formula: 365 / Inventory Turnover
  double calculateDaysInInventory(double inventoryTurnover) {
    if (inventoryTurnover == 0) {
      return 0.0;
    }
    return 365 / inventoryTurnover;
  }

  // Inventory calculations
  int calculateTotalProducts(List<Product> products) {
    return products.length;
  }

  int calculateLowStockCount(List<Product> products) {
    return products.where((p) => p.stock <= p.minStock).length;
  }

  /// Calculate total inventory value using cost price (recommended for financial reporting)
  /// This represents your actual investment/capital tied up in inventory
  double calculateTotalInventoryValue(List<Product> products) {
    return products.fold(
      0.0,
      (sum, product) => sum + (product.cost * product.stock),
    );
  }

  double calculateBeginningInventoryValue(
    List<Product> currentProducts,
    List<StockMovement> movements,
  ) {
    final movementQuantities = <String, int>{};

    for (final movement in movements) {
      movementQuantities.update(
        movement.productId,
        (value) => value + movement.quantity,
        ifAbsent: () => movement.quantity,
      );
    }

    double beginningValue = 0.0;
    for (final product in currentProducts) {
      final quantityMoved = movementQuantities[product.id] ?? 0;
      final beginningStock = product.stock - quantityMoved;
      beginningValue += beginningStock * product.cost;
    }

    return beginningValue > 0 ? beginningValue : 0.0;
  }

  /// Calculate total inventory value using selling price (for retail/market value)
  /// This represents potential revenue if all inventory is sold at current prices
  Future<double> calculateTotalInventoryRetailValue(
    List<Product> products,
  ) async {
    double total = 0.0;
    for (final product in products) {
      final price = await TaxService.calculateSellingPriceWithRule(
        product.cost,
        productId: product.id,
        categoryName: product.category,
      );
      total += price * product.stock;
    }
    return total;
  }

  /// Calculate potential profit from current inventory
  /// This shows how much profit you could make if all current stock is sold
  Future<double> calculatePotentialInventoryProfit(
    List<Product> products,
  ) async {
    double total = 0.0;
    for (final product in products) {
      final price = await TaxService.calculateSellingPriceWithRule(
        product.cost,
        productId: product.id,
        categoryName: product.category,
      );
      total += (price - product.cost) * product.stock;
    }
    return total;
  }

  /// Batch calculate selling prices for multiple products efficiently
  /// This reduces Firestore calls by fetching all rules once
  Future<Map<String, double>> calculateBatchSellingPrices(
    List<Product> products,
  ) async {
    final rules = await TaxRulesService.getAllRules(); // Single call
    final result = <String, double>{};

    for (final product in products) {
      if (product.id == null) continue;

      final rule = _findBestRuleSync(rules, product.id, product.category);
      final price = _calculatePriceWithRule(product.cost, rule);
      result[product.id!] = price;
    }
    return result;
  }

  /// Find the best matching rule synchronously from cached rules
  TaxRule? _findBestRuleSync(
    List<TaxRule> rules,
    String? productId,
    String? categoryName,
  ) {
    // Find product-specific rule first
    if (productId != null) {
      final productRule = rules.firstWhere(
        (rule) => rule.productId == productId,
        orElse: () => TaxRule(
          id: '',
          tubo: 0.0,
          isInclusive: true,
          priority: -1,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ),
      );
      if (productRule.id.isNotEmpty) return productRule;
    }

    // Find category-specific rule
    if (categoryName != null) {
      final categoryRule = rules.firstWhere(
        (rule) => rule.categoryName == categoryName,
        orElse: () => TaxRule(
          id: '',
          tubo: 0.0,
          isInclusive: true,
          priority: -1,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ),
      );
      if (categoryRule.id.isNotEmpty) return categoryRule;
    }

    // Return global rule
    return rules.firstWhere(
      (rule) => rule.isGlobal,
      orElse: () => TaxRule(
        id: '',
        tubo: 0.0,
        isInclusive: true,
        priority: -1,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      ),
    );
  }

  /// Calculate price with a specific rule
  double _calculatePriceWithRule(double cost, TaxRule? rule) {
    if (rule != null && rule.id.isNotEmpty) {
      // Use rule: always add-on-top
      final rawPrice = cost + rule.tubo;
      return rawPrice.round().toDouble();
    }
    // Fallback to global settings
    return TaxService.calculateSellingPriceSync(cost);
  }

  /// Get top selling products by quantity sold
  List<Product> getTopSellingProducts(
    List<SaleItem> saleItems,
    List<Product> products,
  ) {
    final productSaleCount = <String, int>{};
    for (final item in saleItems) {
      productSaleCount.update(
        item.productId,
        (value) => value + item.quantity,
        ifAbsent: () => item.quantity,
      );
    }

    final sortedProductIds = productSaleCount.keys.toList(growable: false)
      ..sort((a, b) => productSaleCount[b]!.compareTo(productSaleCount[a]!));

    final productMap = {for (var p in products) p.id: p};
    final topProducts = sortedProductIds
        .map((id) => productMap[id])
        .where((p) => p != null)
        .cast<Product>()
        .take(10) // Limit to top 10
        .toList();

    return topProducts;
  }

  /// Get top selling products by revenue generated
  List<MapEntry<Product, double>> getTopSellingProductsByRevenue(
    List<SaleItem> saleItems,
    List<Product> products,
  ) {
    final productRevenue = <String, double>{};
    final productMap = {for (var p in products) p.id: p};

    for (final item in saleItems) {
      final product = productMap[item.productId];
      if (product != null) {
        final revenue =
            item.quantity *
            item.unitPrice; // Use item.price (actual selling price)
        productRevenue.update(
          item.productId,
          (value) => value + revenue,
          ifAbsent: () => revenue,
        );
      }
    }

    final sortedEntries = productRevenue.entries.toList(growable: false)
      ..sort((a, b) => b.value.compareTo(a.value));

    return sortedEntries
        .where((entry) => productMap[entry.key] != null) // Check before mapping
        .map((entry) => MapEntry(productMap[entry.key]!, entry.value))
        .take(10)
        .toList();
  }

  /// Calculate loss breakdown by reason
  Map<String, double> getLossBreakdown(List<Loss> losses) {
    final breakdown = <String, double>{};
    for (final loss in losses) {
      breakdown.update(
        loss.reason.name,
        (value) => value + loss.totalCost,
        ifAbsent: () => loss.totalCost,
      );
    }
    return breakdown;
  }

  /// Calculate average order value
  double calculateAverageOrderValue(List<Sale> sales) {
    if (sales.isEmpty) return 0.0;
    final filtered = sales.where((s) => _isCashLikeSale(s.paymentMethod));
    if (filtered.isEmpty) return 0.0;
    final totalSales = calculateTotalSales(filtered.toList());
    return totalSales / filtered.length;
  }

  /// Calculate conversion rate (if you have visitor/inquiry data)
  double calculateConversionRate(int totalSales, int totalInquiries) {
    if (totalInquiries == 0) return 0.0;
    return (totalSales / totalInquiries) * 100;
  }

  /// Calculate customer lifetime value (simplified version)
  double calculateCustomerLifetimeValue(
    double averageOrderValue,
    double purchaseFrequency,
    double customerLifespanYears,
  ) {
    return averageOrderValue * purchaseFrequency * customerLifespanYears;
  }

  bool _isCashLikeSale(String method) {
    final m = method.toLowerCase();
    // Treat standard immediate methods as sales; exclude credit and any payment entries
    return m == 'cash' || m == 'card' || m == 'gcash' || m == 'paymaya';
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\tax_history_service.dart
â•‘ SIZE: 2.72 KB
â•‘ MODIFIED: 10/02/2025 12:23:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import 'dart:developer' as developer;
import '../models/tax_settings_history.dart';

class TaxHistoryService {
  static const String _historyKey = 'tax_settings_history';
  static const int _maxHistoryEntries = 50; // Keep last 50 changes

  /// Add a new tubo settings change to history
  static Future<void> addHistoryEntry({
    required String changedByUserId,
    required String changedByUserName,
    double? oldAmount,
    double? newAmount,
    bool? oldInclusive,
    bool? newInclusive,
    required String source,
  }) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final historyJson = prefs.getString(_historyKey) ?? '[]';
      final List<dynamic> historyList = jsonDecode(historyJson);

      final newEntry = TaxSettingsHistory(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        changedByUserId: changedByUserId,
        changedByUserName: changedByUserName,
        oldAmount: oldAmount,
        newAmount: newAmount,
        oldInclusive: oldInclusive,
        newInclusive: newInclusive,
        timestamp: DateTime.now(),
        source: source,
      );

      // Add new entry at the beginning
      historyList.insert(0, newEntry.toMap());

      // Keep only the last _maxHistoryEntries
      if (historyList.length > _maxHistoryEntries) {
        historyList.removeRange(_maxHistoryEntries, historyList.length);
      }

      await prefs.setString(_historyKey, jsonEncode(historyList));
    } catch (e) {
      // Silently fail - history is not critical
      developer.log(
        'Failed to save tax history: $e',
        name: 'TaxHistoryService',
      );
    }
  }

  /// Get tax settings history
  static Future<List<TaxSettingsHistory>> getHistory() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final historyJson = prefs.getString(_historyKey) ?? '[]';
      final List<dynamic> historyList = jsonDecode(historyJson);

      return historyList
          .map((entry) => TaxSettingsHistory.fromMap(entry))
          .toList();
    } catch (e) {
      return [];
    }
  }

  /// Get recent history (last 20 entries)
  static Future<List<TaxSettingsHistory>> getRecentHistory() async {
    final history = await getHistory();
    return history.take(20).toList();
  }

  /// Clear all history
  static Future<void> clearHistory() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove(_historyKey);
    } catch (e) {
      developer.log(
        'Failed to clear tax history: $e',
        name: 'TaxHistoryService',
      );
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\tax_rules_service.dart
â•‘ SIZE: 15.27 KB
â•‘ MODIFIED: 10/13/2025 13:57:08
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import '../models/tax_rule.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'firestore/pricing_service.dart';
import 'tax_service.dart';

class TaxRulesService {
  static const String _rulesKey = 'tax_rules';
  // Limit to prevent storage bloat

  // Request-level caching
  static List<TaxRule>? _cachedRules;
  static DateTime? _cacheTimestamp;
  static const _cacheDuration = Duration(seconds: 30);

  /// Get all tax rules
  static Future<List<TaxRule>> getAllRules({bool forceRefresh = false}) async {
    // Return cached rules if fresh
    if (!forceRefresh && _cachedRules != null && _cacheTimestamp != null) {
      if (DateTime.now().difference(_cacheTimestamp!) < _cacheDuration) {
        return _cachedRules!;
      }
    }

    // Try Firestore first
    try {
      final pricing = PricingService(FirebaseFirestore.instance);
      final docs = await pricing.getAllRules().timeout(
        Duration(seconds: 5),
        onTimeout: () {
          // Return cached local rules on timeout
          return _getLocalRulesSync();
        },
      );
      final rules = docs.map((m) => TaxRule.fromMap(m)).toList()
        ..sort((a, b) => b.priority.compareTo(a.priority));
      // Cache locally for offline fallback
      await _writeLocal(rules);
      // Update request-level cache
      _cachedRules = rules;
      _cacheTimestamp = DateTime.now();
      return rules;
    } catch (_) {
      // Fallback to local cache
      try {
        final prefs = await SharedPreferences.getInstance();
        final rulesJson = prefs.getString(_rulesKey) ?? '[]';
        final List<dynamic> rulesList = jsonDecode(rulesJson);
        final rules = rulesList.map((rule) => TaxRule.fromMap(rule)).toList()
          ..sort((a, b) => b.priority.compareTo(a.priority));
        // Update request-level cache
        _cachedRules = rules;
        _cacheTimestamp = DateTime.now();
        return rules;
      } catch (e) {
        return [];
      }
    }
  }

  /// Get rules for a specific category
  static Future<List<TaxRule>> getRulesForCategory(String categoryName) async {
    final allRules = await getAllRules();
    return allRules.where((rule) => rule.categoryName == categoryName).toList();
  }

  /// Get rule for a specific product
  static Future<TaxRule?> getRuleForProduct(String productId) async {
    final allRules = await getAllRules();
    return allRules.firstWhere(
      (rule) => rule.productId == productId,
      orElse: () => TaxRule(
        id: '',
        tubo: 0.0,
        isInclusive: true,
        priority: -1,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      ),
    );
  }

  /// Get the best matching rule for a product and category
  static Future<TaxRule?> getBestRule({
    String? productId,
    String? categoryName,
  }) async {
    final allRules = await getAllRules();

    // Find product-specific rule first
    if (productId != null) {
      final productRule = allRules.firstWhere(
        (rule) => rule.productId == productId,
        orElse: () => TaxRule(
          id: '',
          tubo: 0.0,
          isInclusive: true,
          priority: -1,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ),
      );
      if (productRule.id.isNotEmpty) return productRule;
    }

    // Find category-specific rule
    if (categoryName != null) {
      final categoryRule = allRules.firstWhere(
        (rule) => rule.categoryName == categoryName,
        orElse: () => TaxRule(
          id: '',
          tubo: 0.0,
          isInclusive: true,
          priority: -1,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ),
      );
      if (categoryRule.id.isNotEmpty) return categoryRule;
    }

    // Return global rule
    return allRules.firstWhere(
      (rule) => rule.isGlobal,
      orElse: () => TaxRule(
        id: '',
        tubo: 0.0,
        isInclusive: true,
        priority: -1,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      ),
    );
  }

  static Future<void> _writeLocal(List<TaxRule> rules) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final jsonStr = jsonEncode(rules.map((r) => r.toMap()).toList());
      await prefs.setString(_rulesKey, jsonStr);
    } catch (_) {}
  }

  /// Get local rules synchronously for timeout fallback
  static List<Map<String, dynamic>> _getLocalRulesSync() {
    try {
      // This is a simplified sync version - in practice, we'd need to handle this differently
      // For now, return empty list and let the catch block handle it
      return [];
    } catch (_) {
      return [];
    }
  }

  static Future<bool> addRule(TaxRule rule) async {
    try {
      final pricing = PricingService(FirebaseFirestore.instance);

      // Check for conflicts and replace existing rules
      await _replaceConflictingRules(rule, pricing);

      await pricing.upsertRule(rule.id, rule.toMap());
      // Record price history for affected products (best-effort)
      try {
        await _recordPriceHistoryForRuleChange(
          productId: rule.productId,
          categoryName: rule.categoryName,
          isGlobal: rule.isGlobal,
        );
      } catch (_) {}
      return true;
    } catch (_) {
      // Local fallback
      final existing = await getAllRules();

      // Replace conflicting rules locally
      if (rule.isGlobal) {
        existing.removeWhere((r) => r.isGlobal);
      }
      if (rule.isCategory && (rule.categoryName != null)) {
        existing.removeWhere(
          (r) => r.isCategory && r.categoryName == rule.categoryName,
        );
      }
      if (rule.isProduct && (rule.productId != null)) {
        existing.removeWhere(
          (r) => r.isProduct && r.productId == rule.productId,
        );
      }

      existing.add(rule);
      await _writeLocal(existing);
      return true;
    }
  }

  /// Check if a rule would conflict with existing rules
  static Future<TaxRule?> checkForConflicts(TaxRule rule) async {
    final existingRules = await getAllRules();

    if (rule.isGlobal) {
      final existingGlobalRule = existingRules.firstWhere(
        (r) => r.isGlobal,
        orElse: () => TaxRule(
          id: '',
          tubo: 0.0,
          isInclusive: true,
          priority: -1,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ),
      );

      if (existingGlobalRule.id.isNotEmpty) {
        return existingGlobalRule;
      }
    }

    if (rule.isCategory && (rule.categoryName != null)) {
      final existingCategoryRule = existingRules.firstWhere(
        (r) => r.isCategory && r.categoryName == rule.categoryName,
        orElse: () => TaxRule(
          id: '',
          tubo: 0.0,
          isInclusive: true,
          priority: -1,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ),
      );
      if (existingCategoryRule.id.isNotEmpty) {
        return existingCategoryRule;
      }
    }

    if (rule.isProduct && (rule.productId != null)) {
      final existingProductRule = existingRules.firstWhere(
        (r) => r.isProduct && r.productId == rule.productId,
        orElse: () => TaxRule(
          id: '',
          tubo: 0.0,
          isInclusive: true,
          priority: -1,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ),
      );
      if (existingProductRule.id.isNotEmpty) {
        return existingProductRule;
      }
    }

    return null; // No conflicts found
  }

  /// Check for existing rules that would conflict with the new rule and replace them
  static Future<void> _replaceConflictingRules(
    TaxRule rule,
    PricingService pricing,
  ) async {
    final existingRules = await getAllRules();

    if (rule.isGlobal) {
      final existingGlobalRule = existingRules.firstWhere(
        (r) => r.isGlobal,
        orElse: () => TaxRule(
          id: '',
          tubo: 0.0,
          isInclusive: true,
          priority: -1,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ),
      );

      if (existingGlobalRule.id.isNotEmpty) {
        await pricing.deleteRule(existingGlobalRule.id);
      }
    }

    if (rule.isCategory && (rule.categoryName != null)) {
      final existingCategoryRule = existingRules.firstWhere(
        (r) => r.isCategory && r.categoryName == rule.categoryName,
        orElse: () => TaxRule(
          id: '',
          tubo: 0.0,
          isInclusive: true,
          priority: -1,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ),
      );
      if (existingCategoryRule.id.isNotEmpty) {
        await pricing.deleteRule(existingCategoryRule.id);
      }
    }

    if (rule.isProduct && (rule.productId != null)) {
      final existingProductRule = existingRules.firstWhere(
        (r) => r.isProduct && r.productId == rule.productId,
        orElse: () => TaxRule(
          id: '',
          tubo: 0.0,
          isInclusive: true,
          priority: -1,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ),
      );
      if (existingProductRule.id.isNotEmpty) {
        await pricing.deleteRule(existingProductRule.id);
      }
    }
  }

  static Future<bool> updateRule(TaxRule rule) async {
    try {
      final pricing = PricingService(FirebaseFirestore.instance);
      await pricing.upsertRule(rule.id, rule.toMap());
      // Record price history for affected products (best-effort)
      try {
        await _recordPriceHistoryForRuleChange(
          productId: rule.productId,
          categoryName: rule.categoryName,
          isGlobal: rule.isGlobal,
        );
      } catch (_) {}
      return true;
    } catch (_) {
      final existing = await getAllRules();
      final idx = existing.indexWhere((r) => r.id == rule.id);
      if (idx != -1) existing[idx] = rule;
      await _writeLocal(existing);
      return true;
    }
  }

  static Future<bool> deleteRule(String ruleId) async {
    try {
      final pricing = PricingService(FirebaseFirestore.instance);
      // Try to capture the rule before deletion to know affected scope
      TaxRule? toDelete;
      try {
        final rules = await getAllRules();
        toDelete = rules.firstWhere(
          (r) => r.id == ruleId,
          orElse: () => TaxRule(
            id: '',
            tubo: 0.0,
            isInclusive: true,
            priority: -1,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
        );
        if (toDelete.id.isEmpty) toDelete = null;
      } catch (_) {}
      await pricing.deleteRule(ruleId);
      // Record price history for affected products after deletion (best-effort)
      if (toDelete != null) {
        try {
          await _recordPriceHistoryForRuleChange(
            productId: toDelete.productId,
            categoryName: toDelete.categoryName,
            isGlobal: toDelete.isGlobal,
          );
        } catch (_) {}
      }
      return true;
    } catch (_) {
      final existing = await getAllRules();
      existing.removeWhere((r) => r.id == ruleId);
      await _writeLocal(existing);
      return true;
    }
  }

  // Removed duplicate local-only CRUD; Firestore-backed versions above handle writes

  /// Clear all rules
  static Future<bool> clearAllRules() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove(_rulesKey);
      return true;
    } catch (e) {
      return false;
    }
  }

  /// Get available categories from existing rules
  static Future<List<String>> getAvailableCategories() async {
    final allRules = await getAllRules();
    return allRules
        .where((rule) => rule.categoryName != null)
        .map((rule) => rule.categoryName!)
        .toSet()
        .toList()
      ..sort();
  }

  /// Get priority for new rule based on type
  static int getPriorityForNewRule({String? productId, String? categoryName}) {
    if (productId != null) {
      return 100; // Product-specific has highest priority
    } else if (categoryName != null) {
      return 50; // Category-specific has medium priority
    } else {
      return 0; // Global has lowest priority
    }
  }

  /// When markup rules change, compute the new selling price for affected
  /// products and write a `priceHistory` entry. This is best-effort and
  /// intentionally ignores failures so rules UI remains responsive.
  static Future<void> _recordPriceHistoryForRuleChange({
    String? productId,
    String? categoryName,
    bool isGlobal = false,
  }) async {
    final firestore = FirebaseFirestore.instance;
    final productsCol = firestore.collection('products');
    final priceHistoryCol = firestore.collection('priceHistory');

    // Collect affected product documents
    List<QueryDocumentSnapshot<Map<String, dynamic>>> docs = [];

    if (productId != null && productId.isNotEmpty) {
      final doc = await productsCol.doc(productId).get();
      if (doc.exists) {
        // Create a synthetic QueryDocument-like map for unified handling
        final data = doc.data() as Map<String, dynamic>;
        final fakeQuerySnap = await productsCol
            .where(FieldPath.documentId, isEqualTo: productId)
            .limit(1)
            .get();
        if (fakeQuerySnap.docs.isNotEmpty) {
          docs = fakeQuerySnap.docs;
        } else {
          // Fallback: if query fails, process single doc directly
          final batch = firestore.batch();
          final double cost = (data['cost'] as num?)?.toDouble() ?? 0.0;
          final String? cat = data['category'] as String?;
          final price = await TaxService.calculateSellingPriceWithRule(
            cost,
            productId: productId,
            categoryName: cat,
          );
          final ref = priceHistoryCol.doc();
          batch.set(ref, {
            'productId': productId,
            'price': price,
            'timestamp': FieldValue.serverTimestamp(),
          });
          await batch.commit();
          return;
        }
      }
    } else if (categoryName != null && categoryName.isNotEmpty) {
      final snap = await productsCol
          .where('category', isEqualTo: categoryName)
          .get();
      docs = snap.docs;
    } else if (isGlobal) {
      final snap = await productsCol.get();
      docs = snap.docs;
    }

    if (docs.isEmpty) return;

    final batch = firestore.batch();
    for (final d in docs) {
      final data = d.data();
      final id = d.id;
      final double cost = (data['cost'] as num?)?.toDouble() ?? 0.0;
      final String? cat = data['category'] as String?;

      final price = await TaxService.calculateSellingPriceWithRule(
        cost,
        productId: id,
        categoryName: cat,
      );

      final ref = priceHistoryCol.doc();
      batch.set(ref, {
        'productId': id,
        'price': price,
        'timestamp': FieldValue.serverTimestamp(),
      });
    }

    await batch.commit();
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\tax_service.dart
â•‘ SIZE: 12.23 KB
â•‘ MODIFIED: 10/04/2025 06:20:48
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:shared_preferences/shared_preferences.dart';
import 'package:flutter/foundation.dart';
import 'tax_history_service.dart';
import 'tax_rules_service.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'firestore/pricing_service.dart';
import 'dart:async';
import '../models/tax_rule.dart';

class TaxService extends ChangeNotifier {
  static const String _tuboAmountKey = 'tubo_amount';
  static const String _tuboInclusiveKey = 'tubo_inclusive';

  // Default values
  static const double _defaultTuboAmount = 2.0; // ₱2 default tubo
  static const bool _defaultTuboInclusive = true;

  // In-memory cache
  static double? _cachedTuboAmount;
  static bool? _cachedTuboInclusive;
  static bool _isInitialized = false;
  static final TaxService _instance = TaxService._internal();

  factory TaxService() => _instance;
  TaxService._internal();

  /// Initialize the service and load settings into cache
  static Future<void> initialize() async {
    if (_isInitialized) return;

    try {
      final prefs = await SharedPreferences.getInstance();
      _cachedTuboAmount = prefs.getDouble(_tuboAmountKey) ?? _defaultTuboAmount;
      _cachedTuboInclusive =
          prefs.getBool(_tuboInclusiveKey) ?? _defaultTuboInclusive;
      _isInitialized = true;

      // Hydrate from Firestore and subscribe for updates (best-effort)
      try {
        final pricing = PricingService(FirebaseFirestore.instance);
        final remote = await pricing.getGlobalSettings();
        if (remote != null) {
          final remoteAmount =
              (remote['tuboAmount'] ?? _defaultTuboAmount) * 1.0;
          final remoteInclusive =
              (remote['isInclusive'] ?? _defaultTuboInclusive) == true;
          await _writeLocal(remoteAmount, remoteInclusive);
        }
      } catch (_) {}
    } catch (e) {
      _cachedTuboAmount = _defaultTuboAmount;
      _cachedTuboInclusive = _defaultTuboInclusive;
      _isInitialized = true;
    }
  }

  static Future<void> _writeLocal(double amount, bool inclusive) async {
    final prefs = await SharedPreferences.getInstance();
    _cachedTuboAmount = amount;
    _cachedTuboInclusive = inclusive;
    await prefs.setDouble(_tuboAmountKey, amount);
    await prefs.setBool(_tuboInclusiveKey, inclusive);
  }

  /// Get cached tubo amount (synchronous)
  static double getCachedTuboAmount() {
    return _cachedTuboAmount ?? _defaultTuboAmount;
  }

  /// Get cached tubo inclusive setting (synchronous)
  static bool getCachedTuboInclusive() {
    return _cachedTuboInclusive ?? _defaultTuboInclusive;
  }

  /// Get the current tubo amount - async version
  static Future<double> getTuboAmount() async {
    if (!_isInitialized) {
      await initialize();
    }
    return getCachedTuboAmount();
  }

  /// Check if pricing is tubo inclusive - async version
  static Future<bool> isTuboInclusive() async {
    if (!_isInitialized) {
      await initialize();
    }
    return getCachedTuboInclusive();
  }

  /// Set the tubo amount
  static Future<bool> setTuboAmount(
    double amount, {
    String? changedByUserId,
    String? changedByUserName,
    String source = 'settings_screen',
  }) async {
    try {
      if (amount < 0.0) {
        return false;
      }

      final oldAmount = _cachedTuboAmount;
      await _writeLocal(amount, getCachedTuboInclusive());
      final success = true;

      if (success) {
        _cachedTuboAmount = amount;
        _instance.notifyListeners();

        // Log history if user info is provided
        if (changedByUserId != null && changedByUserName != null) {
          await TaxHistoryService.addHistoryEntry(
            changedByUserId: changedByUserId,
            changedByUserName: changedByUserName,
            oldAmount: oldAmount,
            newAmount: amount,
            source: source,
          );
        }
        // Push to Firestore (best-effort)
        try {
          final pricing = PricingService(FirebaseFirestore.instance);
          await pricing.setGlobalSettings(
            tuboAmount: amount,
            isInclusive: getCachedTuboInclusive(),
            updatedBy: changedByUserName,
          );
        } catch (_) {}
      }
      return success;
    } catch (e) {
      return false;
    }
  }

  /// Set whether pricing is tubo inclusive
  static Future<bool> setTuboInclusive(
    bool inclusive, {
    String? changedByUserId,
    String? changedByUserName,
    String source = 'settings_screen',
  }) async {
    try {
      final oldInclusive = _cachedTuboInclusive;
      await _writeLocal(getCachedTuboAmount(), inclusive);
      final success = true;

      if (success) {
        _cachedTuboInclusive = inclusive;
        _instance.notifyListeners();

        // Log history if user info is provided
        if (changedByUserId != null && changedByUserName != null) {
          await TaxHistoryService.addHistoryEntry(
            changedByUserId: changedByUserId,
            changedByUserName: changedByUserName,
            oldInclusive: oldInclusive,
            newInclusive: inclusive,
            source: source,
          );
        }
      }
      // Push to Firestore (best-effort)
      try {
        final pricing = PricingService(FirebaseFirestore.instance);
        await pricing.setGlobalSettings(
          tuboAmount: getCachedTuboAmount(),
          isInclusive: inclusive,
          updatedBy: changedByUserName,
        );
      } catch (_) {}
      return success;
    } catch (e) {
      return false;
    }
  }

  /// Calculate selling price based on cost and tubo settings (synchronous)
  static double calculateSellingPriceSync(double cost) {
    // Added-on-top only: selling price = cost + tubo, rounded to nearest peso
    final tuboAmount = getCachedTuboAmount();
    final rawPrice = cost + tuboAmount;
    return rawPrice.round().toDouble();
  }

  /// Calculate selling price based on cost and tubo settings (async)
  static Future<double> calculateSellingPrice(double cost) async {
    if (!_isInitialized) {
      await initialize();
    }
    return calculateSellingPriceSync(cost);
  }

  /// Batch calculate selling prices for multiple costs
  static Future<List<double>> calculateSellingPrices(List<double> costs) async {
    if (!_isInitialized) {
      await initialize();
    }

    final tuboAmount = getCachedTuboAmount();
    final isInclusive = getCachedTuboInclusive();

    return costs.map((cost) {
      if (isInclusive) {
        return cost.round().toDouble();
      } else {
        final rawPrice = cost + tuboAmount;
        return rawPrice.round().toDouble();
      }
    }).toList();
  }

  /// Calculate cost from selling price based on tubo settings (synchronous)
  static double calculateCostFromSellingPriceSync(double sellingPrice) {
    // Added-on-top only: cost = selling price - tubo
    final tuboAmount = getCachedTuboAmount();
    return sellingPrice - tuboAmount;
  }

  /// Calculate cost from selling price based on tubo settings (async)
  static Future<double> calculateCostFromSellingPrice(
    double sellingPrice,
  ) async {
    if (!_isInitialized) {
      await initialize();
    }
    return calculateCostFromSellingPriceSync(sellingPrice);
  }

  /// Batch calculate costs from selling prices
  static Future<List<double>> calculateCostsFromSellingPrices(
    List<double> sellingPrices,
  ) async {
    if (!_isInitialized) {
      await initialize();
    }

    final tuboAmount = getCachedTuboAmount();
    final isInclusive = getCachedTuboInclusive();

    return sellingPrices.map((sellingPrice) {
      if (isInclusive) {
        return sellingPrice;
      } else {
        return sellingPrice - tuboAmount;
      }
    }).toList();
  }

  /// Calculate tubo amount from selling price (synchronous)
  static double calculateTuboAmountSync(double sellingPrice) {
    // Added-on-top only: tubo is the fixed amount added
    final tuboAmount = getCachedTuboAmount();
    return tuboAmount;
  }

  /// Calculate tubo amount from selling price (async)
  static Future<double> calculateTuboAmount(double sellingPrice) async {
    if (!_isInitialized) {
      await initialize();
    }
    return calculateTuboAmountSync(sellingPrice);
  }

  /// Batch calculate tubo amounts from selling prices
  static Future<List<double>> calculateTuboAmounts(
    List<double> sellingPrices,
  ) async {
    if (!_isInitialized) {
      await initialize();
    }

    final tuboAmount = getCachedTuboAmount();

    return sellingPrices.map((sellingPrice) {
      return tuboAmount;
    }).toList();
  }

  /// Calculate selling price with category-specific tubo rule
  static Future<double> calculateSellingPriceWithRule(
    double cost, {
    String? productId,
    String? categoryName,
  }) async {
    if (!_isInitialized) {
      await initialize();
    }

    final rule = await TaxRulesService.getBestRule(
      productId: productId,
      categoryName: categoryName,
    );

    if (rule != null && rule.id.isNotEmpty) {
      // Use rule: always add-on-top
      final rawPrice = cost + rule.tubo;
      return rawPrice.round().toDouble();
    }
    // Fallback to global
    return calculateSellingPriceSync(cost);
  }

  /// Calculate selling price with category-specific tubo rule (synchronous)
  static double calculateSellingPriceWithRuleSync(
    double cost, {
    String? productId,
    String? categoryName,
  }) {
    // For synchronous version, we can't easily get the rule without async
    // So we fall back to global settings
    return calculateSellingPriceSync(cost);
  }

  /// Batch calculate selling prices with category-specific rules
  static Future<List<double>> calculateSellingPricesWithRules(
    List<double> costs, {
    List<String>? productIds,
    List<String>? categoryNames,
  }) async {
    if (!_isInitialized) {
      await initialize();
    }

    final results = <double>[];

    for (int i = 0; i < costs.length; i++) {
      final cost = costs[i];
      final productId = productIds != null && i < productIds.length
          ? productIds[i]
          : null;
      final categoryName = categoryNames != null && i < categoryNames.length
          ? categoryNames[i]
          : null;

      final sellingPrice = await calculateSellingPriceWithRule(
        cost,
        productId: productId,
        categoryName: categoryName,
      );

      results.add(sellingPrice);
    }

    return results;
  }

  /// Get tax rule for a specific product/category
  static Future<TaxRule?> getTaxRule({
    String? productId,
    String? categoryName,
  }) async {
    return await TaxRulesService.getBestRule(
      productId: productId,
      categoryName: categoryName,
    );
  }

  /// Get all tax rules
  static Future<List<TaxRule>> getAllTaxRules() async {
    return await TaxRulesService.getAllRules();
  }

  /// Add a new tax rule
  static Future<bool> addTaxRule(TaxRule rule) async {
    return await TaxRulesService.addRule(rule);
  }

  /// Update an existing tax rule
  static Future<bool> updateTaxRule(TaxRule rule) async {
    return await TaxRulesService.updateRule(rule);
  }

  /// Delete a tax rule
  static Future<bool> deleteTaxRule(String ruleId) async {
    return await TaxRulesService.deleteRule(ruleId);
  }

  /// Check if a rule would conflict with existing rules
  static Future<TaxRule?> checkForConflicts(TaxRule rule) async {
    return await TaxRulesService.checkForConflicts(rule);
  }

  /// Get tubo information for display
  static Future<Map<String, dynamic>> getTuboInfo() async {
    final tuboAmount = await getTuboAmount();

    return {
      'tuboAmount': tuboAmount,
      'isInclusive': false,
      'tuboAmountFormatted': '₱${tuboAmount.toStringAsFixed(2)}',
      'pricingMethod': 'Tubo Added on Top',
    };
  }

  /// Reset to default settings
  static Future<bool> resetToDefaults() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setDouble(_tuboAmountKey, _defaultTuboAmount);
      await prefs.setBool(_tuboInclusiveKey, _defaultTuboInclusive);
      return true;
    } catch (e) {
      return false;
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\firestore\activity_service.dart
â•‘ SIZE: 6.82 KB
â•‘ MODIFIED: 09/12/2025 20:22:14
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:prostock/models/paginated_result.dart';
import 'package:prostock/models/user_activity.dart';
import 'package:prostock/services/firestore/firestore_exception.dart';
import 'package:prostock/utils/app_constants.dart';
import 'package:prostock/utils/constants.dart';

class ActivityService {
  final FirebaseFirestore _firestore;

  ActivityService(this._firestore);

  CollectionReference get activities =>
      _firestore.collection(AppConstants.activitiesCollection);
  CollectionReference get users =>
      _firestore.collection(AppConstants.usersCollection);

  Stream<List<UserActivity>> getActivitiesStream({
    String? userId,
    DateTimeRange? dateRange,
    List<String>? activityTypes,
  }) {
    Query query = activities.orderBy('timestamp', descending: true);

    if (userId != null) {
      query = query.where('user_id', isEqualTo: userId);
    }

    if (dateRange != null) {
      query = query
          .where('timestamp', isGreaterThanOrEqualTo: dateRange.start)
          .where('timestamp', isLessThanOrEqualTo: dateRange.end);
    }

    if (activityTypes != null && activityTypes.isNotEmpty) {
      query = query.where('action', whereIn: activityTypes);
    }

    return query.snapshots().map((snapshot) {
      return snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return UserActivity.fromMap(data);
      }).toList();
    });
  }

  Future<void> logActivity(
    String userId,
    String action,
    String details, {
    String? username,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final sanitizedMetadata = metadata != null
          ? Map<String, dynamic>.from(metadata)
          : <String, dynamic>{};

      await activities.add({
        'user_id': userId,
        'username': username, // Denormalized username
        'action': action,
        'details': details,
        'metadata': sanitizedMetadata,
        'timestamp': FieldValue.serverTimestamp(),
        'ipAddress': 'hidden', // Don't log actual IP for privacy
      });
    } catch (e) {
      throw FirestoreException('Failed to log activity: $e');
    }
  }

  Future<String> insertUserActivity(UserActivity activity) async {
    try {
      final activityData = activity.toMap();
      activityData.remove('id');

      final docRef = await activities.add(activityData);
      return docRef.id;
    } catch (e) {
      throw FirestoreException('Failed to insert user activity: $e');
    }
  }

  Future<List<UserActivity>> getUserActivities(
    String userId, {
    int limit = ValidationConstants.maxLocalErrors,
  }) async {
    try {
      final snapshot = await activities
          .where('user_id', isEqualTo: userId)
          .orderBy('timestamp', descending: true)
          .limit(limit)
          .get();

      return snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return UserActivity.fromMap(data);
      }).toList();
    } catch (e) {
      throw FirestoreException('Failed to get user activities: $e');
    }
  }

  Future<List<Map<String, dynamic>>> getAllUserActivitiesWithUsernames({
    int limit = ValidationConstants.maxDescriptionLength,
  }) async {
    try {
      final activitiesSnapshot = await activities
          .orderBy('timestamp', descending: true)
          .limit(limit)
          .get();

      final List<Map<String, dynamic>> result = [];

      for (final activityDoc in activitiesSnapshot.docs) {
        final activityData = activityDoc.data() as Map<String, dynamic>;
        activityData['id'] = activityDoc.id;
        // Get username
        final userId = activityData['user_id'];
        final userDoc = await users.doc(userId).get();
        if (userDoc.exists) {
          final userData = userDoc.data() as Map<String, dynamic>;
          activityData['username'] = userData['username'];
        }

        result.add(activityData);
      }

      return result;
    } catch (e) {
      throw FirestoreException(
        'Failed to get all user activities with usernames: $e',
      );
    }
  }

  Stream<List<UserActivity>> getAllUserActivitiesStream() {
    try {
      return activities.orderBy('timestamp', descending: true).snapshots().map((snapshot) {
        return snapshot.docs.map((doc) {
          final data = doc.data() as Map<String, dynamic>;
          data['id'] = doc.id;
          return UserActivity.fromMap(data);
        }).toList();
      });
    } catch (e) {
      throw FirestoreException('Failed to get all user activities: $e');
    }
  }

  Future<List<UserActivity>> getActivitiesByDateRange(
    DateTime start,
    DateTime end, {
    String? userId,
  }) async {
    try {
      Query query = activities
          .where('timestamp', isGreaterThanOrEqualTo: Timestamp.fromDate(start))
          .where('timestamp', isLessThanOrEqualTo: Timestamp.fromDate(end));

      if (userId != null) {
        query = query.where('user_id', isEqualTo: userId);
      }

      final snapshot = await query.orderBy('timestamp', descending: true).get();

      return snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return UserActivity.fromMap(data);
      }).toList();
    } catch (e) {
      throw FirestoreException('Failed to get activities by date range: $e');
    }
  }

  Future<PaginatedResult<UserActivity>> getUserActivitiesPaginated({
    String? userId,
    String? role,
    int limit = ApiConstants.productSearchLimit,
    DocumentSnapshot? lastDocument,
  }) async {
    if (userId == null && role == null) {
      throw ArgumentError('Either userId or role must be provided.');
    }

    try {
      List<String> userIds = [];
      if (role != null) {
        final usersSnapshot = await users.where('role', isEqualTo: role).get();
        userIds = usersSnapshot.docs.map((doc) => doc.id).toList();
        if (userIds.isEmpty) {
          return PaginatedResult(items: [], lastDocument: null);
        }
      } else if (userId != null) {
        userIds.add(userId);
      }

      Query query = activities
          .where('user_id', whereIn: userIds)
          .orderBy('timestamp', descending: true);

      if (lastDocument != null) {
        query = query.startAfterDocument(lastDocument);
      }

      query = query.limit(limit);

      final snapshot = await query.get();

      final activitiesList = snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return UserActivity.fromMap(data);
      }).toList();

      return PaginatedResult(
        items: activitiesList,
        lastDocument: snapshot.docs.isNotEmpty ? snapshot.docs.last : null,
      );
    } catch (e) {
      throw FirestoreException('Failed to get paginated user activities: $e');
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\firestore\credit_service.dart
â•‘ SIZE: 3.08 KB
â•‘ MODIFIED: 09/25/2025 17:02:58
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:prostock/models/credit_transaction.dart';
import 'package:prostock/utils/error_logger.dart';

class CreditService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final String _collectionPath = 'credit_transactions';

  Future<void> recordPayment(CreditTransaction transaction) async {
    await _firestore.collection(_collectionPath).add(transaction.toMap());
  }

  Future<void> recordCreditSale(CreditTransaction transaction) async {
    await _firestore.collection(_collectionPath).add(transaction.toMap());
  }

  Future<List<CreditTransaction>> getTransactionsByCustomer(
    String customerId,
  ) async {
    try {
      ErrorLogger.logInfo(
        'Querying transactions for customer',
        context: 'CreditService.getTransactionsByCustomer',
        metadata: {'customerId': customerId},
      );

      // First, let's check if the collection exists and has any documents
      final collectionSnapshot = await _firestore
          .collection(_collectionPath)
          .limit(1)
          .get();
      ErrorLogger.logInfo(
        'Checked collection existence',
        context: 'CreditService.getTransactionsByCustomer',
        metadata: {'docs': collectionSnapshot.docs.length},
      );

      // Use a simpler query without orderBy to avoid composite index requirement
      // We'll sort the results locally instead
      final querySnapshot = await _firestore
          .collection(_collectionPath)
          .where('customerId', isEqualTo: customerId)
          .get();

      ErrorLogger.logInfo(
        'Found documents for customer',
        context: 'CreditService.getTransactionsByCustomer',
        metadata: {
          'customerId': customerId,
          'count': querySnapshot.docs.length,
        },
      );

      final transactions = querySnapshot.docs.map((doc) {
        ErrorLogger.logInfo(
          'Processing document',
          context: 'CreditService.getTransactionsByCustomer',
          metadata: {'docId': doc.id},
        );
        return CreditTransaction.fromMap(doc.data(), doc.id);
      }).toList();

      // Sort transactions by createdAt in descending order locally
      transactions.sort((a, b) => b.date.compareTo(a.date));

      ErrorLogger.logInfo(
        'Created transactions list',
        context: 'CreditService.getTransactionsByCustomer',
        metadata: {'count': transactions.length},
      );
      return transactions;
    } catch (e) {
      ErrorLogger.logError(
        'Error querying transactions',
        error: e,
        context: 'CreditService.getTransactionsByCustomer',
        metadata: {'customerId': customerId},
      );
      rethrow;
    }
  }

  Future<bool> hasAnyTransactions() async {
    try {
      final snapshot = await _firestore
          .collection(_collectionPath)
          .limit(1)
          .get();
      return snapshot.docs.isNotEmpty;
    } catch (e) {
      ErrorLogger.logError(
        'Error checking for transactions',
        error: e,
        context: 'CreditService.hasAnyTransactions',
      );
      return false;
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\firestore\customer_service.dart
â•‘ SIZE: 5.59 KB
â•‘ MODIFIED: 09/29/2025 08:08:35
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:prostock/models/customer.dart';
import 'package:prostock/models/paginated_result.dart';
import 'package:prostock/services/firestore/firestore_exception.dart';
import 'package:prostock/utils/app_constants.dart';
import 'package:prostock/utils/constants.dart';

class CustomerService {
  final FirebaseFirestore _firestore;

  CustomerService(this._firestore);

  CollectionReference get customers =>
      _firestore.collection(AppConstants.customersCollection);

  Customer _customerFromDocument(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    data['id'] = doc.id;
    return Customer.fromMap(data);
  }

  bool _isValidCustomer(Customer customer) {
    return customer.name.isNotEmpty && customer.balance >= 0;
  }

  Future<String> insertCustomer(Customer customer) async {
    try {
      if (!_isValidCustomer(customer)) {
        throw ArgumentError('Invalid customer data');
      }

      final customerData = customer.toMap();
      customerData.remove('id');

      final docRef = await customers.add(customerData);
      return docRef.id;
    } catch (e) {
      throw FirestoreException('Failed to insert customer: $e');
    }
  }

  Future<List<Customer>> getAllCustomers() async {
    try {
      final snapshot = await customers.orderBy('name').get();
      return snapshot.docs.map(_customerFromDocument).toList();
    } catch (e) {
      throw FirestoreException('Failed to get all customers: $e');
    }
  }

  Future<List<Customer>> searchCustomers(String query) async {
    try {
      final snapshot = await customers
          .where('name', isGreaterThanOrEqualTo: query)
          .where('name', isLessThan: '$query\ufff0')
          .get();
      return snapshot.docs.map(_customerFromDocument).toList();
    } catch (e) {
      throw FirestoreException('Failed to search customers: $e');
    }
  }

  Future<Customer?> getCustomerById(String id) async {
    try {
      final doc = await customers.doc(id).get();

      if (doc.exists) {
        return _customerFromDocument(doc);
      }
      return null;
    } catch (e) {
      throw FirestoreException('Failed to get customer by ID: $e');
    }
  }

  Future<Customer?> getCustomerByName(String name) async {
    try {
      final snapshot = await customers
          .where('name', isEqualTo: name)
          .limit(1)
          .get();

      if (snapshot.docs.isNotEmpty) {
        return _customerFromDocument(snapshot.docs.first);
      }
      return null;
    } catch (e) {
      throw FirestoreException('Failed to get customer by name: $e');
    }
  }

  Future<void> updateCustomer(Customer customer) async {
    try {
      if (!_isValidCustomer(customer)) {
        throw ArgumentError('Invalid customer data');
      }

      final customerData = customer.toMap();
      customerData.remove('id');

      await customers.doc(customer.id).update(customerData);
    } catch (e) {
      throw FirestoreException('Failed to update customer: $e');
    }
  }

  Future<void> deleteCustomer(String id) async {
    try {
      await customers.doc(id).delete();
    } catch (e) {
      throw FirestoreException('Failed to delete customer: $e');
    }
  }

  Future<double> updateCustomerBalance(
    String customerId,
    double amountChange,
  ) async {
    try {
      return await _firestore.runTransaction((transaction) async {
        final customerRef = customers.doc(customerId);
        final customerDoc = await transaction.get(customerRef);

        if (!customerDoc.exists) {
          throw Exception('Customer not found');
        }

        final data = customerDoc.data() as Map<String, dynamic>;
        final currentBalance = (data['balance'] ?? 0.0) as double;
        final newBalance = currentBalance + amountChange;

        transaction.update(customerRef, {
          'balance': newBalance,
          'updatedAt': FieldValue.serverTimestamp(),
        });
        return newBalance;
      });
    } catch (e) {
      throw FirestoreException('Failed to update customer balance: $e');
    }
  }

  Future<PaginatedResult<Customer>> getCustomersPaginated({
    int limit = ApiConstants.productSearchLimit,
    DocumentSnapshot? lastDocument,
    String? searchQuery,
  }) async {
    try {
      Query query = customers.orderBy('name');

      // Note: We don't apply Firestore search filters here because they are case-sensitive
      // and would miss results. Instead, we fetch all customers and filter client-side
      // for better case-insensitive search results.

      if (lastDocument != null) {
        query = query.startAfterDocument(lastDocument);
      }

      query = query.limit(limit);

      final snapshot = await query.get();

      final customersList = snapshot.docs.map(_customerFromDocument).toList();

      // Apply client-side filtering for case-insensitive search
      if (searchQuery != null && searchQuery.isNotEmpty) {
        final filteredCustomers = customersList.where((customer) {
          final query = searchQuery.toLowerCase();
          return customer.name.toLowerCase().contains(query) ||
              (customer.phone?.toLowerCase().contains(query) ?? false) ||
              (customer.email?.toLowerCase().contains(query) ?? false);
        }).toList();

        return PaginatedResult(
          items: filteredCustomers,
          lastDocument: snapshot.docs.isNotEmpty ? snapshot.docs.last : null,
        );
      }

      return PaginatedResult(
        items: customersList,
        lastDocument: snapshot.docs.isNotEmpty ? snapshot.docs.last : null,
      );
    } catch (e) {
      throw FirestoreException('Failed to get paginated customers: $e');
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\firestore\firestore_exception.dart
â•‘ SIZE: 0.41 KB
â•‘ MODIFIED: 08/31/2025 20:11:06
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


// Custom exception class for better error handling
class FirestoreException implements Exception {
  final String message;
  final String? code;
  final dynamic originalError;

  const FirestoreException(this.message, {this.code, this.originalError});

  @override
  String toString() {
    if (code != null) {
      return 'FirestoreException [$code]: $message';
    }
    return 'FirestoreException: $message';
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\firestore\inventory_service.dart
â•‘ SIZE: 4.25 KB
â•‘ MODIFIED: 09/13/2025 12:27:37
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:prostock/models/loss.dart';
import 'package:prostock/models/paginated_result.dart';
import 'package:prostock/models/stock_movement.dart';
import 'package:prostock/services/firestore/firestore_exception.dart';

import 'package:prostock/utils/constants.dart';

class InventoryService {
  final FirebaseFirestore _firestore;

  InventoryService(this._firestore);

  CollectionReference get stockMovements =>
      _firestore.collection(AppConstants.stockMovementsCollection);
  CollectionReference get losses =>
      _firestore.collection(AppConstants.lossesCollection);

  Future<String> insertStockMovement(
    String productId,
    String productName,
    String movementType,
    int quantity,
    String? reason,
  ) async {
    try {
      final stockMovementData = {
        'productId': productId,
        'productName': productName,
        'movementType': movementType,
        'quantity': quantity,
        'reason': reason,
        'createdAt': FieldValue.serverTimestamp(),
      };

      final docRef = await stockMovements.add(stockMovementData);
      return docRef.id;
    } catch (e) {
      throw FirestoreException('Failed to insert stock movement: $e');
    }
  }

  Future<List<StockMovement>> getStockMovementsByProduct(
    String productId,
  ) async {
    try {
      final snapshot = await stockMovements
          .where('productId', isEqualTo: productId)
          .orderBy('createdAt', descending: true)
          .get();

      return snapshot.docs.map(_stockMovementFromDocument).toList();
    } catch (e) {
      throw FirestoreException('Failed to get stock movements by product: $e');
    }
  }

  StockMovement _stockMovementFromDocument(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    data['id'] = doc.id;
    return StockMovement.fromMap(data);
  }

  Future<PaginatedResult<StockMovement>> getStockMovements({
    int limit = 20,
    DocumentSnapshot? lastDocument,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      Query query = stockMovements.orderBy('createdAt', descending: true);

      if (startDate != null) {
        query = query.where('createdAt', isGreaterThanOrEqualTo: startDate);
      }
      if (endDate != null) {
        query = query.where(
          'createdAt',
          isLessThanOrEqualTo: endDate.add(const Duration(days: 1)),
        );
      }

      if (lastDocument != null) {
        query = query.startAfterDocument(lastDocument);
      }

      query = query.limit(limit);

      final snapshot = await query.get();

      final movementsList = snapshot.docs
          .map(_stockMovementFromDocument)
          .toList();

      return PaginatedResult(
        items: movementsList,
        lastDocument: snapshot.docs.isNotEmpty ? snapshot.docs.last : null,
      );
    } catch (e) {
      throw FirestoreException('Failed to get paginated stock movements: $e');
    }
  }

  Future<List<StockMovement>> getAllStockMovements({
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      Query query = stockMovements.orderBy('createdAt', descending: true);

      if (startDate != null) {
        query = query.where('createdAt', isGreaterThanOrEqualTo: startDate);
      }
      if (endDate != null) {
        query = query.where(
          'createdAt',
          isLessThanOrEqualTo: endDate.add(const Duration(days: 1)),
        );
      }

      final snapshot = await query.get();

      return snapshot.docs.map(_stockMovementFromDocument).toList();
    } catch (e) {
      throw FirestoreException('Failed to get all stock movements: $e');
    }
  }

  Future<void> insertLoss(Loss loss) async {
    try {
      final lossData = loss.toMap();
      lossData.remove('id');

      await losses.add(lossData);
    } catch (e) {
      throw FirestoreException('Failed to insert loss: $e');
    }
  }

  Future<List<Loss>> getLosses() async {
    try {
      final snapshot = await losses
          .orderBy('timestamp', descending: true)
          .get();

      return snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return Loss.fromMap(data);
      }).toList();
    } catch (e) {
      throw FirestoreException('Failed to get losses: $e');
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\firestore\pricing_service.dart
â•‘ SIZE: 1.77 KB
â•‘ MODIFIED: 10/03/2025 21:36:52
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:cloud_firestore/cloud_firestore.dart';

class PricingService {
  static const String _settingsDocPath = 'pricing_settings/global';
  static const String _rulesCollection = 'pricing_rules';

  final FirebaseFirestore _firestore;

  PricingService(this._firestore);

  DocumentReference get _settingsDoc => _firestore.doc(_settingsDocPath);
  CollectionReference get _rulesCol => _firestore.collection(_rulesCollection);

  Future<Map<String, dynamic>?> getGlobalSettings() async {
    final snap = await _settingsDoc.get();
    if (!snap.exists) return null;
    return snap.data() as Map<String, dynamic>;
  }

  Stream<Map<String, dynamic>?> watchGlobalSettings() {
    return _settingsDoc.snapshots().map((snap) {
      if (!snap.exists) return null;
      return snap.data() as Map<String, dynamic>;
    });
  }

  Future<void> setGlobalSettings({
    required double tuboAmount,
    required bool isInclusive,
    String? updatedBy,
  }) async {
    await _settingsDoc.set({
      'tuboAmount': tuboAmount,
      'isInclusive': isInclusive,
      'updatedAt': FieldValue.serverTimestamp(),
      if (updatedBy != null) 'updatedBy': updatedBy,
    }, SetOptions(merge: true));
  }

  Future<List<Map<String, dynamic>>> getAllRules() async {
    final snap = await _rulesCol.orderBy('priority', descending: true).get();
    return snap.docs
        .map((d) => ({...d.data() as Map<String, dynamic>, 'id': d.id}))
        .toList();
  }

  Future<void> upsertRule(String id, Map<String, dynamic> data) async {
    await _rulesCol.doc(id).set({
      ...data,
      'updatedAt': FieldValue.serverTimestamp(),
    }, SetOptions(merge: true));
  }

  Future<void> deleteRule(String id) async {
    await _rulesCol.doc(id).delete();
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\firestore\product_service.dart
â•‘ SIZE: 8.05 KB
â•‘ MODIFIED: 10/02/2025 12:23:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:prostock/models/paginated_result.dart';
import 'package:prostock/models/price_history.dart';
import 'package:prostock/models/product.dart';
import 'package:prostock/services/firestore/firestore_exception.dart';
import 'package:prostock/services/tax_service.dart';
import 'package:prostock/utils/app_constants.dart';
import 'package:prostock/utils/constants.dart';

class ProductService {
  final FirebaseFirestore _firestore;

  ProductService(this._firestore);

  CollectionReference get products =>
      _firestore.collection(AppConstants.productsCollection);
  CollectionReference get priceHistory => _firestore.collection('priceHistory');

  Product _productFromDocument(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    data['id'] = doc.id;
    return Product.fromMap(data);
  }

  bool _isValidProduct(Product product) {
    return product.name.isNotEmpty && product.cost >= 0 && product.stock >= 0;
  }

  Future<void> insertProduct(Product product) async {
    try {
      if (!_isValidProduct(product)) {
        throw ArgumentError('Invalid product data');
      }
      if (product.id == null || product.id!.isEmpty) {
        throw ArgumentError(
          'Product ID cannot be null or empty for insertion.',
        );
      }

      final productData = product.toMap();

      // Use the product's own ID to set the document, ensuring a single ID.
      await products.doc(product.id).set(productData);
    } catch (e) {
      throw FirestoreException('Failed to insert product: $e');
    }
  }

  Future<void> addProductWithPriceHistory(Product product) async {
    try {
      if (!_isValidProduct(product)) {
        throw ArgumentError('Invalid product data');
      }
      if (product.id == null || product.id!.isEmpty) {
        throw ArgumentError(
          'Product ID cannot be null or empty for insertion.',
        );
      }

      final batch = _firestore.batch();

      final productRef = products.doc(product.id);
      batch.set(productRef, product.toMap());

      final priceHistoryRef = priceHistory.doc();
      final sellingPrice = await TaxService.calculateSellingPriceWithRule(
        product.cost,
        productId: product.id,
        categoryName: product.category,
      );
      final priceHistoryData = PriceHistory(
        id: priceHistoryRef.id,
        productId: product.id!,
        price: sellingPrice,
        timestamp: DateTime.now(),
      ).toMap();
      batch.set(priceHistoryRef, priceHistoryData);

      await batch.commit();
    } catch (e) {
      throw FirestoreException(
        'Failed to insert product with price history: $e',
      );
    }
  }

  Future<void> updateProductWithPriceHistory(
    Product product,
    bool priceChanged,
  ) async {
    try {
      if (!_isValidProduct(product)) {
        throw ArgumentError('Invalid product data');
      }

      final batch = _firestore.batch();

      final productRef = products.doc(product.id);
      batch.update(productRef, product.toMap());

      if (priceChanged) {
        final priceHistoryRef = priceHistory.doc();
        final sellingPrice = await TaxService.calculateSellingPriceWithRule(
          product.cost,
          productId: product.id,
          categoryName: product.category,
        );
        final priceHistoryData = PriceHistory(
          id: priceHistoryRef.id,
          productId: product.id!,
          price: sellingPrice,
          timestamp: DateTime.now(),
        ).toMap();
        batch.set(priceHistoryRef, priceHistoryData);
      }

      await batch.commit();
    } catch (e) {
      throw FirestoreException(
        'Failed to update product with price history: $e',
      );
    }
  }

  Future<List<String>> insertProductsBatch(List<Product> productsList) async {
    try {
      final batch = FirebaseFirestore.instance.batch();
      final List<String> docIds = [];

      for (final product in productsList) {
        if (!_isValidProduct(product)) {
          throw ArgumentError('Invalid product data: ${product.name}');
        }

        final docRef = products.doc(); // Use the collection reference
        final productData = product.toMap();
        productData.remove('id');

        batch.set(docRef, productData);
        docIds.add(docRef.id);
      }

      await batch.commit();
      return docIds;
    } catch (e) {
      throw FirestoreException('Failed to insert products batch: $e');
    }
  }

  Future<List<Product>> getAllProducts() async {
    try {
      final snapshot = await products.orderBy('name').get();
      return snapshot.docs.map(_productFromDocument).toList();
    } catch (e) {
      throw FirestoreException('Failed to get all products: $e');
    }
  }

  Future<List<Product>> searchProducts(String query) async {
    try {
      final snapshot = await products
          .where('name', isGreaterThanOrEqualTo: query)
          .where('name', isLessThan: '$query\ufff0')
          .get();
      return snapshot.docs.map(_productFromDocument).toList();
    } catch (e) {
      throw FirestoreException('Failed to search products: $e');
    }
  }

  Future<Product?> getProductByBarcode(String barcode) async {
    try {
      if (barcode.isEmpty) return null;

      final snapshot = await products
          .where('barcode', isEqualTo: barcode)
          .limit(1)
          .get();

      if (snapshot.docs.isNotEmpty) {
        return _productFromDocument(snapshot.docs.first);
      }
      return null;
    } catch (e) {
      throw FirestoreException('Failed to get product by barcode: $e');
    }
  }

  Future<Product?> getProductById(String id) async {
    try {
      final doc = await products.doc(id).get();

      if (doc.exists) {
        return _productFromDocument(doc);
      }
      return null;
    } catch (e) {
      throw FirestoreException('Failed to get product by ID: $e');
    }
  }

  Future<void> updateProduct(Product product) async {
    try {
      if (!_isValidProduct(product)) {
        throw ArgumentError('Invalid product data');
      }

      final productData = product.toMap();
      productData.remove('id');

      await products.doc(product.id).update(productData);
    } catch (e) {
      throw FirestoreException('Failed to update product: $e');
    }
  }

  Future<void> deleteProduct(String id) async {
    try {
      await products.doc(id).delete();
    } catch (e) {
      throw FirestoreException('Failed to delete product: $e');
    }
  }

  Future<PaginatedResult<Product>> getProductsPaginated({
    int limit = ApiConstants.productSearchLimit,
    DocumentSnapshot? lastDocument,
    String? searchQuery,
  }) async {
    try {
      Query query = products.orderBy('name');

      // Apply search filter if searchQuery is provided
      if (searchQuery != null && searchQuery.isNotEmpty) {
        query = query
            .where('name', isGreaterThanOrEqualTo: searchQuery)
            .where('name', isLessThan: '$searchQuery\ufff0');
      }

      if (lastDocument != null) {
        query = query.startAfterDocument(lastDocument);
      }

      query = query.limit(limit);

      final snapshot = await query.get();

      final productsList = snapshot.docs.map(_productFromDocument).toList();

      return PaginatedResult(
        items: productsList,
        lastDocument: snapshot.docs.isNotEmpty ? snapshot.docs.last : null,
      );
    } catch (e) {
      throw FirestoreException('Failed to get paginated products: $e');
    }
  }

  Future<List<PriceHistory>> getPriceHistory(String productId) async {
    try {
      final snapshot = await priceHistory
          .where('productId', isEqualTo: productId)
          .orderBy('timestamp', descending: true)
          .get();

      return snapshot.docs.map((doc) {
        return PriceHistory.fromFirestore(doc);
      }).toList();
    } catch (e) {
      throw FirestoreException('Failed to get price history: $e');
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\firestore\sale_service.dart
â•‘ SIZE: 12.19 KB
â•‘ MODIFIED: 09/22/2025 09:36:33
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:prostock/models/credit_transaction.dart';
import 'package:prostock/models/paginated_result.dart';
import 'package:prostock/models/product.dart';
import 'package:prostock/models/sale.dart';
import 'package:prostock/models/sale_item.dart';
import 'package:prostock/services/firestore/firestore_exception.dart';
import 'package:prostock/utils/app_constants.dart';
import 'package:prostock/utils/constants.dart';

class SaleService {
  final FirebaseFirestore _firestore;

  SaleService(this._firestore);

  CollectionReference get sales =>
      _firestore.collection(AppConstants.salesCollection);
  CollectionReference get saleItems =>
      _firestore.collection(AppConstants.saleItemsCollection);
  CollectionReference get creditTransactions =>
      _firestore.collection(AppConstants.creditTransactionsCollection);
  CollectionReference get products =>
      _firestore.collection(AppConstants.productsCollection);
  CollectionReference get customers =>
      _firestore.collection(AppConstants.customersCollection);

  bool _isValidSale(Sale sale) {
    return sale.totalAmount >= 0 &&
        sale.paymentMethod.isNotEmpty &&
        sale.status.isNotEmpty;
  }

  Future<String> insertSale(Sale sale, List<Product> products) async {
    try {
      if (!_isValidSale(sale)) {
        throw ArgumentError('Invalid sale data');
      }

      return await _firestore.runTransaction((transaction) async {
        // 1. Read all product documents first.
        final productRefs = products
            .map((p) => this.products.doc(p.id))
            .toList();
        final productDocs = await Future.wait(
          productRefs.map((ref) => transaction.get(ref)),
        );

        // 2. Validate products and prepare updates.
        for (int i = 0; i < products.length; i++) {
          final productDoc = productDocs[i];
          if (!productDoc.exists) {
            throw Exception('Product with ID ${products[i].id} not found');
          }
          final currentStock =
              (productDoc.data() as Map<String, dynamic>)['stock'] ?? 0;
          if (currentStock <= 0) {
            throw Exception(
              'Product with ID ${products[i].id} is out of stock',
            );
          }
        }

        // 3. Perform all write operations.
        final saleRef = sales.doc();
        final saleData = sale.toMap();
        saleData.remove('id');
        saleData['createdAt'] = Timestamp.fromDate(
          sale.createdAt,
        ); // Explicitly convert to Timestamp
        transaction.set(saleRef, saleData);

        for (int i = 0; i < products.length; i++) {
          final productRef = productRefs[i];
          transaction.update(productRef, {'stock': FieldValue.increment(-1)});
        }

        return saleRef.id;
      });
    } catch (e) {
      throw FirestoreException('Failed to insert sale: $e');
    }
  }

  Future<String> recordUtang(
    String customerId,
    double totalAmount,
    double amountChange,
    List<SaleItem> saleItems,
  ) async {
    try {
      return await _firestore.runTransaction((transaction) async {
        // 1. Update customer's utang balance
        final customerRef = customers.doc(customerId);
        final customerDoc = await transaction.get(customerRef);

        if (!customerDoc.exists) {
          throw Exception('Customer not found');
        }

        final data = customerDoc.data() as Map<String, dynamic>;
        final currentBalance = (data['utang_balance'] ?? 0.0) as double;
        final newBalance = currentBalance + amountChange;

        transaction.update(customerRef, {
          'utang_balance': newBalance,
          'updatedAt': FieldValue.serverTimestamp(),
        });

        // 2. Create a credit transaction record
        final creditTransactionRef = creditTransactions.doc();
        final creditTransaction = CreditTransaction(
          customerId: customerId,
          amount: totalAmount,
          type: 'credit',
          notes: 'POS Utang',
          date: DateTime.now(),
        );
        transaction.set(creditTransactionRef, creditTransaction.toMap());

        // 3. Decrement product stock
        for (final item in saleItems) {
          final productRef = products.doc(item.productId);
          transaction.update(productRef, {
            'stock': FieldValue.increment(-item.quantity),
          });
        }

        return creditTransactionRef.id;
      });
    } catch (e) {
      throw FirestoreException('Failed to record utang: $e');
    }
  }

  Future<String> insertSaleItem(SaleItem saleItem) async {
    try {
      final saleItemData = saleItem.toMap();
      saleItemData.remove('id');

      final docRef = await saleItems.add(saleItemData);
      return docRef.id;
    } catch (e) {
      throw FirestoreException('Failed to insert sale item: $e');
    }
  }

  Future<String> insertCompleteTransaction(
    Sale sale,
    List<SaleItem> saleItems,
  ) async {
    try {
      if (!_isValidSale(sale)) {
        throw ArgumentError('Invalid sale data');
      }

      return await FirebaseFirestore.instance.runTransaction((
        transaction,
      ) async {
        // Insert sale
        final saleRef = sales.doc();
        final saleData = sale.toMap();
        saleData.remove('id');
        transaction.set(saleRef, saleData);

        // Insert all sale items
        for (final item in saleItems) {
          final saleItemRef = this.saleItems.doc();
          final saleItemData = item.toMap();
          saleItemData.remove('id');
          saleItemData['saleId'] = saleRef.id;
          transaction.set(saleItemRef, saleItemData);
        }

        return saleRef.id;
      });
    } catch (e) {
      throw FirestoreException('Failed to insert complete transaction: $e');
    }
  }

  Future<List<Sale>> getAllSales() async {
    try {
      final snapshot = await sales.orderBy('createdAt', descending: true).get();

      return snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return Sale.fromMap(data);
      }).toList();
    } catch (e) {
      throw FirestoreException('Failed to get all sales: $e');
    }
  }

  Future<List<Sale>> getSalesInDateRange(
    DateTime startDate,
    DateTime endDate,
  ) async {
    try {
      final snapshot = await sales
          .where(
            'createdAt',
            isGreaterThanOrEqualTo: Timestamp.fromDate(startDate),
          )
          .where('createdAt', isLessThanOrEqualTo: Timestamp.fromDate(endDate))
          .get();

      return snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return Sale.fromMap(data);
      }).toList();
    } catch (e) {
      throw FirestoreException('Failed to get sales in date range: $e');
    }
  }

  Future<List<SaleItem>> getSaleItemsBySaleId(String saleId) async {
    try {
      final snapshot = await saleItems.where('saleId', isEqualTo: saleId).get();

      return snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return SaleItem.fromMap(data);
      }).toList();
    } catch (e) {
      throw FirestoreException('Failed to get sale items by sale ID: $e');
    }
  }

  Future<List<SaleItem>> getSaleItemsBySaleIds(List<String> saleIds) async {
    if (saleIds.isEmpty) {
      return [];
    }

    try {
      final List<SaleItem> allSaleItems = [];
      final saleIdBatches = _splitList(saleIds, 30);

      for (final batch in saleIdBatches) {
        final snapshot = await saleItems.where('saleId', whereIn: batch).get();
        final items = snapshot.docs.map((doc) {
          final data = doc.data() as Map<String, dynamic>;
          data['id'] = doc.id;
          return SaleItem.fromMap(data);
        }).toList();
        allSaleItems.addAll(items);
      }

      return allSaleItems;
    } catch (e) {
      throw FirestoreException('Failed to get sale items by sale IDs: $e');
    }
  }

  List<List<T>> _splitList<T>(List<T> list, int size) {
    final chunks = <List<T>>[];
    for (var i = 0; i < list.length; i += size) {
      chunks.add(
        list.sublist(i, i + size > list.length ? list.length : i + size),
      );
    }
    return chunks;
  }

  Future<PaginatedResult<Sale>> getSalesPaginated({
    int limit = ApiConstants.salesHistoryLimit,
    DocumentSnapshot? lastDocument,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      Query query = sales.orderBy('createdAt', descending: true);

      if (startDate != null) {
        query = query.where(
          'createdAt',
          isGreaterThanOrEqualTo: Timestamp.fromDate(startDate),
        );
      }

      if (endDate != null) {
        query = query.where(
          'createdAt',
          isLessThanOrEqualTo: Timestamp.fromDate(endDate),
        );
      }

      if (lastDocument != null) {
        query = query.startAfterDocument(lastDocument);
      }

      query = query.limit(limit);

      final snapshot = await query.get();

      final salesList = snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return Sale.fromMap(data);
      }).toList();

      return PaginatedResult(
        items: salesList,
        lastDocument: snapshot.docs.isNotEmpty ? snapshot.docs.last : null,
      );
    } catch (e) {
      throw FirestoreException('Failed to get paginated sales: $e');
    }
  }

  Future<Map<String, dynamic>> getSalesAnalytics({
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      Query query = sales;

      if (startDate != null) {
        query = query.where(
          'createdAt',
          isGreaterThanOrEqualTo: Timestamp.fromDate(startDate),
        );
      }

      if (endDate != null) {
        query = query.where(
          'createdAt',
          isLessThanOrEqualTo: Timestamp.fromDate(endDate),
        );
      }

      final snapshot = await query.get();

      double totalRevenue = 0;
      int totalSales = snapshot.docs.length;
      Map<String, int> paymentMethods = {};

      for (final doc in snapshot.docs) {
        final data = doc.data() as Map<String, dynamic>;
        totalRevenue += (data['totalAmount'] ?? 0.0) as double;

        final paymentMethod = data['paymentMethod'] as String? ?? 'Unknown';
        paymentMethods[paymentMethod] =
            (paymentMethods[paymentMethod] ?? 0) + 1;
      }

      return {
        'totalRevenue': totalRevenue,
        'totalSales': totalSales,
        'averageSale': totalSales > 0 ? totalRevenue / totalSales : 0.0,
        'paymentMethods': paymentMethods,
      };
    } catch (e) {
      throw FirestoreException('Failed to get sales analytics: $e');
    }
  }

  Future<String> insertCreditTransaction(CreditTransaction transaction) async {
    try {
      final transactionData = transaction.toMap();
      transactionData.remove('id');

      final docRef = await creditTransactions.add(transactionData);
      return docRef.id;
    } catch (e) {
      throw FirestoreException('Failed to insert credit transaction: $e');
    }
  }

  Future<List<CreditTransaction>> getAllCreditTransactions() async {
    try {
      final snapshot = await creditTransactions
          .orderBy('createdAt', descending: true)
          .get();

      return snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        return CreditTransaction.fromMap(data, doc.id);
      }).toList();
    } catch (e) {
      throw FirestoreException('Failed to get all credit transactions: $e');
    }
  }

  Future<List<CreditTransaction>> getCreditTransactionsByCustomer(
    String customerId,
  ) async {
    try {
      // Use a simpler query without orderBy to avoid composite index requirement
      final snapshot = await creditTransactions
          .where('customerId', isEqualTo: customerId)
          .get();

      final transactions = snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        return CreditTransaction.fromMap(data, doc.id);
      }).toList();

      // Sort transactions by createdAt in descending order locally
      transactions.sort((a, b) => b.date.compareTo(a.date));

      return transactions;
    } catch (e) {
      throw FirestoreException(
        'Failed to get credit transactions by customer: $e',
      );
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\firestore\user_service.dart
â•‘ SIZE: 5.27 KB
â•‘ MODIFIED: 09/12/2025 20:42:20
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:prostock/models/app_user.dart';
import 'package:prostock/services/firestore/firestore_exception.dart';
import 'package:prostock/utils/constants.dart';
import 'package:prostock/utils/password_helper.dart';

class UserService {
  final FirebaseFirestore _firestore;
  final FirebaseAuth _auth;

  UserService(this._firestore, this._auth);

  CollectionReference get users =>
      _firestore.collection(AppConstants.usersCollection);

  User? get currentUser => _auth.currentUser;
  Stream<User?> get authStateChanges => _auth.authStateChanges();

  Future<void> initializeFirestore() async {
    try {
      // Create initial admin user if it doesn't exist
      final adminQuery = await users
          .where('username', isEqualTo: 'admin')
          .get();
      if (adminQuery.docs.isEmpty) {
        final hashedPassword = PasswordHelper.hashPassword('admin123');
        await users.add({
          'username': 'admin',
          'passwordHash': hashedPassword,
          'role': 'admin',
          'isActive': true,
          'createdAt': FieldValue.serverTimestamp(),
        });
      }

      // Create initial regular user if it doesn't exist
      final userQuery = await users.where('username', isEqualTo: 'user').get();
      if (userQuery.docs.isEmpty) {
        final hashedPassword = PasswordHelper.hashPassword('user123');
        await users.add({
          'username': 'user',
          'passwordHash': hashedPassword,
          'role': 'user',
          'isActive': true,
          'createdAt': FieldValue.serverTimestamp(),
        });
      }
    } catch (e) {
      throw FirestoreException('Failed to initialize Firestore: $e');
    }
  }

  Future<AppUser?> getUserByCredentials(
    String username,
    String password,
  ) async {
    try {
      final snapshot = await users
          .where('username', isEqualTo: username)
          .limit(1)
          .get();

      if (snapshot.docs.isNotEmpty) {
        final doc = snapshot.docs.first;
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;

        return AppUser.fromMap(data);
      }

      return null;
    } catch (e) {
      throw FirestoreException('Failed to get user by credentials: $e');
    }
  }

  Future<AppUser?> getUserByUsername(String username) async {
    try {
      final snapshot = await users
          .where('username', isEqualTo: username)
          .limit(1)
          .get();

      if (snapshot.docs.isNotEmpty) {
        final doc = snapshot.docs.first;
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;

        return AppUser.fromMap(data);
      }

      return null;
    } catch (e) {
      throw FirestoreException('Failed to get user by username: $e');
    }
  }

  Future<AppUser?> getUserByEmail(String email) async {
    try {
      final snapshot = await users
          .where('email', isEqualTo: email)
          .limit(1)
          .get();

      if (snapshot.docs.isNotEmpty) {
        final doc = snapshot.docs.first;
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;

        return AppUser.fromMap(data);
      }

      return null;
    } catch (e) {
      throw FirestoreException('Failed to get user by email: $e');
    }
  }

  Future<AppUser?> getUserById(String id) async {
    try {
      final doc = await users.doc(id).get();

      if (doc.exists) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return AppUser.fromMap(data);
      }
      return null;
    } catch (e) {
      throw FirestoreException('Failed to get user by ID: $e');
    }
  }

  Future<List<AppUser>> getAllUsers() async {
    try {
      final snapshot = await users.orderBy('username').get();
      return snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return AppUser.fromMap(data);
      }).toList();
    } catch (e) {
      throw FirestoreException('Failed to get all users: $e');
    }
  }

  Stream<List<AppUser>> getAllUsersStream() {
    try {
      return users.orderBy('username').snapshots().map((snapshot) {
        return snapshot.docs.map((doc) {
          final data = doc.data() as Map<String, dynamic>;
          data['id'] = doc.id;
          return AppUser.fromMap(data);
        }).toList();
      });
    } catch (e) {
      throw FirestoreException('Failed to get all users: $e');
    }
  }

  Future<String> insertUser(AppUser user) async {
    try {
      final userData = user.toMap();
      userData.remove('id');

      // Add isActive field for future compatibility
      userData['isActive'] = true;

      final docRef = await users.add(userData);
      return docRef.id;
    } catch (e) {
      throw FirestoreException('Failed to insert user: $e');
    }
  }

  Future<void> updateUser(AppUser user) async {
    try {
      final userData = user.toMap();
      userData.remove('id');

      await users.doc(user.id).update(userData);
    } catch (e) {
      throw FirestoreException('Failed to update user: $e');
    }
  }

  Future<void> deleteUser(String id) async {
    try {
      await users.doc(id).delete();
    } catch (e) {
      throw FirestoreException('Failed to delete user: $e');
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\offline\cache_service.dart
â•‘ SIZE: 2.85 KB
â•‘ MODIFIED: 08/31/2025 20:47:29
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:prostock/utils/error_logger.dart';

class CacheService {
  Future<void> cacheData(String key, dynamic data) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final jsonString = jsonEncode(data);
      await prefs.setString('cache_$key', jsonString);
      await prefs.setString(
        'cache_${key}_timestamp',
        DateTime.now().toIso8601String(),
      );
    } catch (e) {
      ErrorLogger.logError(
        'Error caching data',
        error: e,
        context: 'CacheService.cacheData',
      );
    }
  }

  Future<T?> getCachedData<T>(
    String key,
    T Function(Map<String, dynamic>) fromJson,
  ) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final jsonString = prefs.getString('cache_$key');

      if (jsonString != null) {
        final data = jsonDecode(jsonString);
        if (data is List) {
          return data
                  .map((item) => fromJson(item as Map<String, dynamic>))
                  .toList()
              as T;
        } else if (data is Map<String, dynamic>) {
          return fromJson(data);
        }
      }
    } catch (e) {
      ErrorLogger.logError(
        'Error getting cached data',
        error: e,
        context: 'CacheService.getCachedData',
      );
    }
    return null;
  }

  Future<bool> isCacheValid(String key, Duration maxAge) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final timestampString = prefs.getString('cache_${key}_timestamp');

      if (timestampString != null) {
        final timestamp = DateTime.parse(timestampString);
        return DateTime.now().difference(timestamp) < maxAge;
      }
    } catch (e) {
      ErrorLogger.logError(
        'Error checking cache validity',
        error: e,
        context: 'CacheService.isCacheValid',
      );
    }
    return false;
  }

  Future<void> clearCache() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final keys = prefs
          .getKeys()
          .where((key) => key.startsWith('cache_'))
          .toList();
      for (final key in keys) {
        await prefs.remove(key);
      }
      ErrorLogger.logInfo(
        'Cache cleared',
        context: 'CacheService.clearCache',
      );
    } catch (e) {
      ErrorLogger.logError(
        'Error clearing cache',
        error: e,
        context: 'CacheService.clearCache',
      );
    }
  }

  Future<void> saveLastSyncTime(DateTime time) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('last_sync_time', time.toIso8601String());
    } catch (e) {
      ErrorLogger.logError(
        'Error saving last sync time',
        error: e,
        context: 'CacheService.saveLastSyncTime',
      );
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\offline\connectivity_service.dart
â•‘ SIZE: 1.14 KB
â•‘ MODIFIED: 10/02/2025 12:09:41
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:async';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flutter/material.dart';

class ConnectivityService with ChangeNotifier {
  bool _isOnline = true;
  StreamSubscription<List<ConnectivityResult>>? _connectivitySubscription;

  bool get isOnline => _isOnline;

  Future<void> initialize() async {
    await _checkConnectivity();
    _startConnectivityMonitoring();
  }

  Future<void> _checkConnectivity() async {
    final connectivityResults = await Connectivity().checkConnectivity();
    _isOnline = connectivityResults.any(
      (result) => result != ConnectivityResult.none,
    );
    notifyListeners();
  }

  void _startConnectivityMonitoring() {
    _connectivitySubscription = Connectivity().onConnectivityChanged.listen((
      List<ConnectivityResult> results,
    ) async {
      final wasOnline = _isOnline;
      _isOnline = results.any((result) => result != ConnectivityResult.none);
      if (wasOnline != _isOnline) {
        notifyListeners();
      }
    });
  }

  @override
  void dispose() {
    _connectivitySubscription?.cancel();
    super.dispose();
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\offline\operation_queue_service.dart
â•‘ SIZE: 2.96 KB
â•‘ MODIFIED: 09/22/2025 21:18:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/models/offline_operation.dart';
import 'package:prostock/models/sale.dart';
import 'package:prostock/models/sale_item.dart';
import 'package:prostock/services/local_database_service.dart';
import 'package:prostock/utils/error_logger.dart';

class OperationQueueService {
  final LocalDatabaseService _localDatabaseService;

  OperationQueueService(this._localDatabaseService);

  Future<void> queueOperation(OfflineOperation operation) async {
    if (operation.type == OperationType.createSaleTransaction) {
      final saleMap = operation.data['sale'] as Map<String, dynamic>;
      final sale = Sale.fromMap(saleMap).copyWith(isSynced: 0);
      final saleItems = (operation.data['saleItems'] as List)
          .map((item) => SaleItem.fromMap(item as Map<String, dynamic>))
          .toList();

      await _localDatabaseService.insertSale(sale);
      for (final item in saleItems) {
        await _localDatabaseService.insertSaleItem(item);
      }
    } else if (operation.type == OperationType.insertCreditTransaction) {
      // Mirror credit transaction locally for offline history
      await _localDatabaseService.insertCreditTransaction(operation.data);
    }

    try {
      final db = await _localDatabaseService.database;
      await db.insert('offline_operations', operation.toMap());
      ErrorLogger.logInfo(
        'Queued operation: ${operation.type} - ${operation.id}',
        context: 'OperationQueueService.queueOperation',
      );
    } catch (e) {
      ErrorLogger.logError(
        'Error queuing operation',
        error: e,
        context: 'OperationQueueService.queueOperation',
      );
    }
  }

  Future<List<OfflineOperation>> getPendingOperations() async {
    try {
      final db = await _localDatabaseService.database;
      final List<Map<String, dynamic>> maps = await db.query(
        'offline_operations',
      );
      return List.generate(maps.length, (i) {
        return OfflineOperation.fromMap(maps[i]);
      });
    } catch (e) {
      ErrorLogger.logError(
        'Error loading pending operations from DB',
        error: e,
        context: 'OperationQueueService.getPendingOperations',
      );
      return [];
    }
  }

  Future<void> clearPendingOperations() async {
    try {
      final db = await _localDatabaseService.database;
      await db.delete('offline_operations');
      ErrorLogger.logInfo(
        'Pending operations cleared',
        context: 'OperationQueueService.clearPendingOperations',
      );
    } catch (e) {
      ErrorLogger.logError(
        'Error clearing pending operations',
        error: e,
        context: 'OperationQueueService.clearPendingOperations',
      );
    }
  }

  Future<List<Sale>> getPendingSales() async {
    final db = await _localDatabaseService.database;
    final List<Map<String, dynamic>> maps = await db.query(
      'sales',
      where: 'is_synced = ?',
      whereArgs: [0],
    );
    return List.generate(maps.length, (i) {
      return Sale.fromMap(maps[i]);
    });
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\services\offline\sync_service.dart
â•‘ SIZE: 12.93 KB
â•‘ MODIFIED: 10/13/2025 10:27:31
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:prostock/models/offline_operation.dart';
import 'package:prostock/models/sale.dart';
import 'package:prostock/models/sale_item.dart';
import 'package:prostock/models/sync_failure.dart';
import 'package:prostock/providers/sync_failure_provider.dart';
import 'package:prostock/services/cloudinary_service.dart';
import 'package:prostock/services/local_database_service.dart';
import 'package:prostock/services/offline/operation_queue_service.dart';
import 'package:prostock/utils/constants.dart';
import 'package:prostock/utils/error_logger.dart';

class SyncService {
  final OperationQueueService _queueService;
  final LocalDatabaseService _localDatabaseService;
  final SyncFailureProvider _syncFailureProvider;
  static const int maxRetries = 3;

  Function(int, int)? _onProgressUpdate;

  SyncService(
    this._queueService,
    this._localDatabaseService,
    this._syncFailureProvider,
  );

  void setProgressCallback(Function(int completed, int total) callback) {
    _onProgressUpdate = callback;
  }

  Future<void> syncPendingOperations() async {
    final operationsToSync = await _queueService.getPendingOperations();
    if (operationsToSync.isEmpty) return;

    try {
      await _processBatches(operationsToSync);
    } catch (e) {
      _handleFailedSync(e);
    }
  }

  Future<void> _processBatches(List<OfflineOperation> operationsToSync) async {
    const int batchSize = 50;
    for (int i = 0; i < operationsToSync.length; i += batchSize) {
      final List<OfflineOperation> batch = operationsToSync.sublist(
        i,
        i + batchSize > operationsToSync.length
            ? operationsToSync.length
            : i + batchSize,
      );
      await _processBatch(batch);

      // Update progress after each batch
      _updateSyncProgress(i + batch.length, operationsToSync.length);
    }
  }

  void _updateSyncProgress(int completed, int total) {
    _onProgressUpdate?.call(completed, total);
  }

  Future<void> _processBatch(List<OfflineOperation> batch) async {
    final List<Map<String, dynamic>> batchOperations = [];
    final List<OfflineOperation> operationsInBatch = [];
    final List<OfflineOperation> failedOperations = [];

    for (final operation in batch) {
      try {
        // Handle image upload with fallback
        if (operation.type == OperationType.insertCustomer ||
            operation.type == OperationType.updateCustomer) {
          if (operation.data['localImagePath'] != null) {
            try {
              final imageUrl = await CloudinaryService.instance.uploadImage(
                File(operation.data['localImagePath']),
              );
              operation.data['imageUrl'] = imageUrl;
              operation.data.remove('localImagePath');
              ErrorLogger.logInfo(
                'Image uploaded successfully for operation ${operation.id}',
                context: 'SyncService._processBatch',
              );
            } catch (imageError) {
              ErrorLogger.logError(
                'Image upload failed for operation ${operation.id}, continuing without image',
                error: imageError,
                context: 'SyncService._processBatch',
              );
              // Keep localImagePath for retry later, don't fail the entire operation
              // operation.data.remove('localImagePath'); // Commented out to preserve for retry
            }
          }
        }

        final newBatchOperations = _getBatchOperations(operation);
        batchOperations.addAll(newBatchOperations);
        operationsInBatch.add(operation);
        ErrorLogger.logInfo(
          'Prepared operation for batch: ${operation.type} - ${operation.id}',
          context: 'SyncService._processBatch',
        );
      } catch (e) {
        ErrorLogger.logError(
          'Failed to prepare operation ${operation.id}',
          error: e,
          context: 'SyncService._processBatch',
        );
        if (operation.retryCount < maxRetries) {
          final updatedOperation = operation.copyWith(
            retryCount: operation.retryCount + 1,
          );
          failedOperations.add(updatedOperation);
        } else {
          await _moveToDeadLetterQueue(operation, e.toString());
          ErrorLogger.logError(
            'Operation ${operation.id} failed after $maxRetries retries',
            error: e,
            context: 'SyncService._processBatch',
          );
        }
      }
    }

    // Commit batch with error handling
    final List<int> successfulOperationIds = [];
    if (batchOperations.isNotEmpty) {
      final firestoreBatch = FirebaseFirestore.instance.batch();

      for (final operation in batchOperations) {
        final type = operation['type'];
        final collection = operation['collection'];
        final docId = operation['docId'];
        final data = operation['data'];

        if (type == AppConstants.operationInsert) {
          final docRef = FirebaseFirestore.instance
              .collection(collection)
              .doc(docId);
          firestoreBatch.set(docRef, data);
        } else if (type == AppConstants.operationUpdate) {
          final docRef = FirebaseFirestore.instance
              .collection(collection)
              .doc(docId);
          // Use set with merge for updateProduct to handle missing documents
          if (collection == AppConstants.productsCollection) {
            firestoreBatch.set(docRef, data, SetOptions(merge: true));
          } else {
            firestoreBatch.update(docRef, data);
          }
        } else if (type == AppConstants.operationDelete) {
          final docRef = FirebaseFirestore.instance
              .collection(collection)
              .doc(docId);
          firestoreBatch.delete(docRef);
        }
      }

      try {
        await firestoreBatch.commit();
        // Only mark as successful if commit succeeds
        successfulOperationIds.addAll(operationsInBatch.map((op) => op.dbId!));
        ErrorLogger.logInfo(
          'Successfully committed batch with ${operationsInBatch.length} operations',
          context: 'SyncService._processBatch',
        );
      } catch (e) {
        ErrorLogger.logError(
          'Firebase batch commit failed, retrying operations',
          error: e,
          context: 'SyncService._processBatch',
        );
        // If commit fails, retry all operations
        for (final op in operationsInBatch) {
          if (op.retryCount < maxRetries) {
            final updatedOperation = op.copyWith(retryCount: op.retryCount + 1);
            failedOperations.add(updatedOperation);
            ErrorLogger.logInfo(
              'Retrying operation ${op.id} (attempt ${updatedOperation.retryCount})',
              context: 'SyncService._processBatch',
            );
          } else {
            await _moveToDeadLetterQueue(op, e.toString());
            successfulOperationIds.add(op.dbId!);
            ErrorLogger.logError(
              'Operation ${op.id} failed after $maxRetries retries due to batch commit failure',
              error: e,
              context: 'SyncService._processBatch',
            );
          }
        }
      }
    }

    final db = await _localDatabaseService.database;
    // Delete only successfully synced operations
    if (successfulOperationIds.isNotEmpty) {
      final placeholders = successfulOperationIds.map((_) => '?').join(',');
      await db.delete(
        'offline_operations',
        where: 'id IN ($placeholders)',
        whereArgs: successfulOperationIds,
      );
      ErrorLogger.logInfo(
        'Removed ${successfulOperationIds.length} successfully synced operations from queue',
        context: 'SyncService._processBatch',
      );
    }

    if (failedOperations.isNotEmpty) {
      final batchDb = db.batch();
      for (final op in failedOperations) {
        batchDb.update(
          'offline_operations',
          op.toMap(),
          where: 'id = ?',
          whereArgs: [op.dbId],
        );
      }
      await batchDb.commit(noResult: true);
      ErrorLogger.logInfo(
        'Updated retry count for ${failedOperations.length} failed operations',
        context: 'SyncService._processBatch',
      );
    }
  }

  void _handleFailedSync(Object e) {
    ErrorLogger.logError(
      'Error during sync',
      error: e,
      context: 'SyncService.syncPendingOperations',
    );
  }

  Future<void> _moveToDeadLetterQueue(
    OfflineOperation operation,
    String error,
  ) async {
    final db = await _localDatabaseService.database;
    await db.insert('dead_letter_operations', {
      'operation_id': operation.id,
      'operation_type': operation.type.toString().split('.').last,
      'collection_name': operation.collectionName,
      'document_id': operation.documentId,
      'data': jsonEncode(operation.data),
      'timestamp': operation.timestamp.toIso8601String(),
      'error': error,
    });

    _syncFailureProvider.addFailure(
      SyncFailure(operation: operation, error: error),
    );
  }

  List<Map<String, dynamic>> _getBatchOperations(OfflineOperation operation) {
    switch (operation.type) {
      case OperationType.insertProduct:
      case OperationType.insertCustomer:
      case OperationType.insertCreditTransaction:
      case OperationType.insertLoss:
      case OperationType.insertPriceHistory:
      case OperationType.insertCostHistory:
      case OperationType.insertStockMovement:
      case OperationType.logActivity:
        return [_getInsertOperation(operation)];
      case OperationType.updateProduct:
      case OperationType.updateCustomer:
        return [_getUpdateOperation(operation)];
      case OperationType.updateCustomerBalance:
        return [_getBalanceIncrementOperation(operation)];
      case OperationType.deleteCustomer:
        return [_getDeleteOperation(operation)];
      case OperationType.createSaleTransaction:
        final saleMap = operation.data['sale'] as Map<String, dynamic>;
        final sale = Sale.fromMap(saleMap);
        final saleItems = (operation.data['saleItems'] as List)
            .map((item) => SaleItem.fromMap(item as Map<String, dynamic>))
            .toList();

        // Avoid duplicating local data: just mark as synced instead of re-inserting
        unawaited(_localDatabaseService.markSaleAsSynced(sale.id!));

        final List<Map<String, dynamic>> operations = [];

        // Normalize sale payload for Firestore: camelCase + Timestamp
        final Map<String, dynamic> saleData = {
          'userId': sale.userId,
          'customerId': sale.customerId,
          'totalAmount': sale.totalAmount,
          'paymentMethod': sale.paymentMethod,
          'status': sale.status,
          'createdAt': Timestamp.fromDate(sale.createdAt),
        };
        if (sale.dueDate != null) {
          saleData['dueDate'] = Timestamp.fromDate(sale.dueDate!);
        }

        operations.add({
          'type': AppConstants.operationInsert,
          'collection': AppConstants.salesCollection,
          'docId': sale.id,
          'data': saleData,
        });

        for (final item in saleItems) {
          final Map<String, dynamic> itemData = {
            'saleId': item.saleId,
            'productId': item.productId,
            'quantity': item.quantity,
            'unitPrice': item.unitPrice,
            'totalPrice': item.totalPrice,
          };
          operations.add({
            'type': AppConstants.operationInsert,
            'collection': AppConstants.saleItemsCollection,
            'docId': item.id,
            'data': itemData,
          });
        }

        for (final item in saleItems) {
          operations.add({
            'type': AppConstants.operationUpdate,
            'collection': AppConstants.productsCollection,
            'docId': item.productId,
            'data': {'stock': FieldValue.increment(-item.quantity)},
          });
        }

        return operations;
    }
  }

  Map<String, dynamic> _getInsertOperation(OfflineOperation operation) {
    return {
      'type': AppConstants.operationInsert,
      'collection': operation.collectionName,
      'docId': operation.documentId,
      'data': operation.data,
    };
  }

  Map<String, dynamic> _getUpdateOperation(OfflineOperation operation) {
    return {
      'type': AppConstants.operationUpdate,
      'collection': operation.collectionName,
      'docId': operation.documentId,
      'data': operation.data,
    };
  }

  Map<String, dynamic> _getDeleteOperation(OfflineOperation operation) {
    return {
      'type': AppConstants.operationDelete,
      'collection': operation.collectionName,
      'docId': operation.documentId,
    };
  }

  Map<String, dynamic> _getBalanceIncrementOperation(
    OfflineOperation operation,
  ) {
    return {
      'type': AppConstants.operationUpdate,
      'collection': operation.collectionName,
      'docId': operation.documentId,
      'data': {
        'balance': FieldValue.increment(
          operation.data['balance_increment'] ?? 0.0,
        ),
        'updatedAt': FieldValue.serverTimestamp(),
      },
    };
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\utils\app_constants.dart
â•‘ SIZE: 2.78 KB
â•‘ MODIFIED: 09/04/2025 19:22:33
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// A central place for constant values used throughout the application.
/// This helps in maintaining consistency and makes the code more readable
/// and easier to maintain.
library;

// ------------------- API/Query Constants ------------------- //

/// Constants related to API, database queries, and pagination.
class ApiConstants {
  static const int defaultPageSize = 30;
  static const int userActivityLimit = 10;
  static const int productSearchLimit = 50;
  static const int salesHistoryLimit = 30;
  static const int offlineBatchSize = 50;
}

// ------------------- Validation Constants ------------------- //

/// Constants for data validation rules.
class ValidationConstants {
  static const double maxTransactionAmount = 1000000.0;
  static const int maxDescriptionLength = 200;
  static const int maxNameLength = 100;
  static const int maxCategoryLength = 50;
  static const int maxSaleQuantity = 1000;
  static const int maxLocalErrors = 100;
  static const int minPhoneNumberLength = 10;
  static const int maxPhoneNumberLength = 11;
  static const int maxInputLength = 1000;
  static const int maxCollectionNameLength = 100;
  static const int maxDocIdLength = 100;
}

// ------------------- UI Constants ------------------- //

/// Constants for defining UI element properties like spacing, radius, etc.
class UiConstants {
  // Durations
  static const Duration debounceDuration = Duration(milliseconds: 200);

  // Padding and Spacing
  static const double spacingSmall = 8.0;
  static const double spacingMedium = 16.0;
  static const double spacingLarge = 24.0;
  static const double spacingExtraLarge = 40.0;
  static const double spacingExtraLarge2 = 30.0;

  // Radius
  static const double borderRadiusStandard = 10.0;

  // Font Sizes
  static const double fontSizeExtraSmall = 10.0;
  static const double fontSizeSmall = 12.0;
  static const double fontSizeMedium = 16.0;
  static const double fontSizeLarge = 20.0;
  static const double fontSizeTitle = 32.0;
  static const double fontSizeButton = 18.0;

  // Barcode Scanner
  static const double barcodeScannerBorderLength = 40.0;
  static const double barcodeScannerCutOutSize = 280.0;
  static const double barcodeScannerBorderWidth = 3.0;

  // Constraints
  static const double receiptMaxWidth = 400.0;

  // Icon Sizes
  static const double iconSizeSmall = 20.0;
  static const double iconSizeMedium = 30.0;
  static const double iconSizeLarge = 40.0;

  // Stroke Widths
  static const double strokeWidthSmall = 2.0;
}

// ------------------- App Default Values ------------------- //

/// Default values for various states and initializations.
class AppDefaults {
  static const int defaultTabIndex = 0;
  static const int notSynced = 0;
  static const int synced = 1;
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\utils\auth_error_handler.dart
â•‘ SIZE: 3.62 KB
â•‘ MODIFIED: 10/02/2025 17:06:21
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:firebase_auth/firebase_auth.dart';

class AuthErrorHandler {
  static String getLoginErrorMessage(FirebaseAuthException e) {
    switch (e.code) {
      case 'user-not-found':
        return 'No account found with this email address. Please check your email or create a new account.';
      case 'wrong-password':
        return 'Incorrect password. Please try again or reset your password.';
      case 'invalid-email':
        return 'Please enter a valid email address.';
      case 'user-disabled':
        return 'This account has been disabled. Please contact support for assistance.';
      case 'too-many-requests':
        return 'Too many failed login attempts. Please wait a few minutes before trying again.';
      case 'network-request-failed':
        return 'Network connection error. Please check your internet connection and try again.';
      case 'invalid-credential':
        return 'Invalid login credentials. Please check your email and password.';
      case 'account-exists-with-different-credential':
        return 'An account already exists with this email using a different sign-in method.';
      case 'operation-not-allowed':
        return 'Email/password sign-in is not enabled. Please contact support.';
      default:
        return e.message ?? 'Login failed. Please try again.';
    }
  }

  static String getSignupErrorMessage(FirebaseAuthException e) {
    switch (e.code) {
      case 'email-already-in-use':
        return 'This email address is already registered. Please use a different email or try logging in.';
      case 'invalid-email':
        return 'Please enter a valid email address.';
      case 'weak-password':
        return 'Password is too weak. Please choose a stronger password with at least 8 characters, including uppercase, lowercase, numbers, and special characters.';
      case 'operation-not-allowed':
        return 'Account creation is not enabled. Please contact support.';
      case 'network-request-failed':
        return 'Network connection error. Please check your internet connection and try again.';
      case 'too-many-requests':
        return 'Too many requests. Please wait a few minutes before trying again.';
      default:
        return e.message ?? 'Account creation failed. Please try again.';
    }
  }

  static String getPasswordResetErrorMessage(FirebaseAuthException e) {
    switch (e.code) {
      case 'user-not-found':
        return 'No account found with this email address. Please check your email or create a new account.';
      case 'invalid-email':
        return 'Please enter a valid email address.';
      case 'network-request-failed':
        return 'Network connection error. Please check your internet connection and try again.';
      case 'too-many-requests':
        return 'Too many password reset requests. Please wait before trying again.';
      default:
        return e.message ?? 'Password reset failed. Please try again.';
    }
  }

  static Map<String, String> getFieldSpecificError(FirebaseAuthException e) {
    final Map<String, String> errors = {};

    switch (e.code) {
      case 'user-not-found':
      case 'invalid-email':
        errors['email'] = 'Invalid email or user not found';
        break;
      case 'wrong-password':
      case 'invalid-credential':
        errors['password'] = 'Incorrect password';
        break;
      case 'email-already-in-use':
        errors['email'] = 'This email is already registered';
        break;
      case 'weak-password':
        errors['password'] = 'Password is too weak';
        break;
    }

    return errors;
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\utils\chart_utils.dart
â•‘ SIZE: 5.18 KB
â•‘ MODIFIED: 09/17/2025 11:12:14
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:intl/intl.dart';

class ChartUtils {
  static Map<DateTime, double> groupDataByFilter<T>(
    List<T> data,
    String filter,
    DateTime Function(T) dateSelector,
    double Function(T) valueSelector,
  ) {
    // First filter data by time scope
    final filteredData = _filterDataByTimeScope(data, filter, dateSelector);
    final Map<DateTime, double> groupedData = {};

    for (final item in filteredData) {
      DateTime key;
      final date = dateSelector(item);

      if (filter == "Daily") {
        key = DateTime(date.year, date.month, date.day);
      } else if (filter == "Weekly") {
        // Group by Monday of the week
        final dayOfWeek = date.weekday;
        key = DateTime(date.year, date.month, date.day - dayOfWeek + 1);
      } else if (filter == "Monthly") {
        key = DateTime(date.year, date.month);
      } else {
        // Yearly
        key = DateTime(date.year);
      }

      groupedData[key] = (groupedData[key] ?? 0) + valueSelector(item);
    }

    // Merge with complete date range to show zero values for missing periods
    return _mergeWithDateRange(groupedData, filter);
  }

  /// Filter data based on the selected time scope
  static List<T> _filterDataByTimeScope<T>(
    List<T> data,
    String filter,
    DateTime Function(T) dateSelector,
  ) {
    final now = DateTime.now();
    late DateTime cutoffDate;

    switch (filter) {
      case "Daily":
        // Last 7 days
        cutoffDate = DateTime(now.year, now.month, now.day - 6);
        break;
      case "Weekly":
        // Last 5 weeks (35 days)
        cutoffDate = DateTime(now.year, now.month, now.day - 34);
        break;
      case "Monthly":
        // Last 12 months
        cutoffDate = DateTime(now.year - 1, now.month, now.day);
        break;
      case "Yearly":
        // Last 5 years
        cutoffDate = DateTime(now.year - 4, now.month, now.day);
        break;
      default:
        return data;
    }

    return data.where((item) {
      final itemDate = dateSelector(item);
      return itemDate.isAfter(cutoffDate) ||
          itemDate.isAtSameMomentAs(cutoffDate);
    }).toList();
  }

  /// Generate complete date range for the filter
  static List<DateTime> _generateDateRange(String filter) {
    final now = DateTime.now();
    final List<DateTime> dates = [];

    switch (filter) {
      case "Daily":
        // Last 7 days
        for (int i = 6; i >= 0; i--) {
          final date = DateTime(now.year, now.month, now.day - i);
          dates.add(date);
        }
        break;

      case "Weekly":
        // Last 5 weeks (Monday of each week)
        final mondayThisWeek = now.subtract(Duration(days: now.weekday - 1));
        for (int i = 4; i >= 0; i--) {
          final weekStart = mondayThisWeek.subtract(Duration(days: i * 7));
          dates.add(DateTime(weekStart.year, weekStart.month, weekStart.day));
        }
        break;

      case "Monthly":
        // Last 12 months
        for (int i = 11; i >= 0; i--) {
          final monthDate = DateTime(now.year, now.month - i, 1);
          dates.add(monthDate);
        }
        break;

      case "Yearly":
        // Last 5 years
        for (int i = 4; i >= 0; i--) {
          final yearDate = DateTime(now.year - i, 1, 1);
          dates.add(yearDate);
        }
        break;
    }

    return dates;
  }

  /// Merge generated date range with actual data to show zero values
  static Map<DateTime, double> _mergeWithDateRange(
    Map<DateTime, double> data,
    String filter,
  ) {
    final dateRange = _generateDateRange(filter);
    final Map<DateTime, double> merged = {};

    for (final date in dateRange) {
      DateTime key;

      if (filter == "Daily") {
        key = DateTime(date.year, date.month, date.day);
      } else if (filter == "Weekly") {
        final dayOfWeek = date.weekday;
        key = DateTime(date.year, date.month, date.day - dayOfWeek + 1);
      } else if (filter == "Monthly") {
        key = DateTime(date.year, date.month);
      } else {
        // Yearly
        key = DateTime(date.year);
      }

      merged[key] = data[key] ?? 0.0;
    }

    return merged;
  }

  /// Public method for merging with date range (for external use if needed)
  static Map<DateTime, double> mergeWithDateRange(
    Map<DateTime, double> data,
    String filter,
  ) {
    return _mergeWithDateRange(data, filter);
  }

  static String formatBottomTitle(DateTime date, String filter) {
    if (filter == "Daily") {
      // Return day names: Mon, Tue, Wed, etc.
      return DateFormat('E').format(date);
    } else if (filter == "Weekly") {
      // Return week ranges: Sep 1-7, Sep 8-14, etc.
      final endOfWeek = date.add(const Duration(days: 6));
      final startFormat = DateFormat('MMM d').format(date);
      final endDay = endOfWeek.day;

      if (date.month == endOfWeek.month) {
        return '$startFormat-$endDay';
      } else {
        final endFormat = DateFormat('MMM d').format(endOfWeek);
        return '$startFormat-$endFormat';
      }
    } else if (filter == "Monthly") {
      // Return month names: Jan, Feb, Mar, etc.
      return DateFormat('MMM').format(date);
    } else {
      // Yearly
      // Return year: 2023, 2024, etc.
      return DateFormat('yyyy').format(date);
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\utils\constants.dart
â•‘ SIZE: 1.47 KB
â•‘ MODIFIED: 10/21/2025 07:26:57
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class AppConstants {
  // Firestore collection names
  static const String productsCollection = 'products';
  static const String customersCollection = 'customers';
  static const String salesCollection = 'sales';
  static const String usersCollection = 'users';
  static const String activitiesCollection = 'activities';
  static const String creditTransactionsCollection = 'credit_transactions';
  static const String saleItemsCollection = 'sale_items';
  static const String stockMovementsCollection = 'stock_movements';
  static const String errorLogsCollection = 'error_logs';
  static const String lossesCollection = 'losses';
  static const String priceHistoryCollection = 'price_history';
  static const String costHistoryCollection = 'cost_history';

  // Operation types
  static const String operationInsert = 'insert';
  static const String operationUpdate = 'update';
  static const String operationDelete = 'delete';
  static const String operationCreateSaleTransaction = 'createSaleTransaction';

  // Tubo amount (deprecated - use TaxService.getTuboAmount() instead)
  @Deprecated('Use TaxService.getTuboAmount() instead')
  static const double tuboAmount = 2.0;

  // Product Categories
  static const List<String> productCategories = [
    'Snacks',
    'Drinks',
    'Canned Goods',
    'Noodles & Pasta',
    'Condiments',
    'Cleaning Supplies',
    'Personal Care',
    'Medicine',
    'Cigarettes & Lighters',
    'Others (Iba pa)',
  ];
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\utils\currency_utils.dart
â•‘ SIZE: 3.29 KB
â•‘ MODIFIED: 08/18/2025 08:00:24
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CurrencyUtils {
  static const String currencySymbol = '₱';
  static const String incorrectSymbol = r'$';

  /// Formats a double value as Philippine Peso currency
  /// Example: formatCurrency(1234.56) returns "₱1,234.56"
  static String formatCurrency(double amount) {
    final formatted = amount.toStringAsFixed(2);
    final parts = formatted.split('.');
    final integerPart = parts[0];
    final decimalPart = parts[1];

    // Add commas to integer part
    final regex = RegExp(r'(\d{1,3})(?=(\d{3})+(?!\d))');
    final integerWithCommas = integerPart.replaceAllMapped(
      regex,
      (Match m) => '${m[1]},',
    );

    return '$currencySymbol$integerWithCommas.$decimalPart';
  }

  /// Formats currency without decimal places for whole numbers
  /// Example: formatCurrencyWhole(1000.00) returns "₱1,000"
  static String formatCurrencyWhole(double amount) {
    if (amount == amount.roundToDouble()) {
      return '$currencySymbol${amount.toInt().toString().replaceAllMapped(RegExp(r'(\d{1,3})(?=(\d{3})+(?!\d))'), (Match m) => '${m[1]},')}';
    }
    return formatCurrency(amount);
  }

  /// Parses a currency string back to double
  /// Example: parseCurrency("₱1,234.56") returns 1234.56
  static double parseCurrency(String currencyString) {
    final cleanString = currencyString
        .replaceAll(currencySymbol, '')
        .replaceAll(incorrectSymbol, '')
        .replaceAll(',', '')
        .trim();
    return double.tryParse(cleanString) ?? 0.0;
  }

  /// Validates if a string is a valid currency format
  static bool isValidCurrency(String value) {
    final cleanValue = value
        .replaceAll(currencySymbol, '')
        .replaceAll(incorrectSymbol, '')
        .replaceAll(',', '')
        .trim();
    final parsed = double.tryParse(cleanValue);
    return parsed != null && parsed >= 0;
  }

  /// Validates that a currency string uses the correct symbol
  static bool isValidCurrencyFormat(String currencyString) {
    return currencyString.contains(currencySymbol) &&
        !currencyString.contains(incorrectSymbol);
  }

  /// Converts any \$ symbols to ₱ symbols
  static String fixCurrencySymbol(String currencyString) {
    return currencyString.replaceAll(incorrectSymbol, currencySymbol);
  }

  /// Enhanced currency validator to ensure no dollar signs appear in the app
  static String validateAndFix(String input) {
    // Replace any dollar signs with peso signs
    String fixed = input.replaceAll(incorrectSymbol, currencySymbol);

    // If it's a number without currency symbol, add peso sign
    final numericValue = double.tryParse(input);
    if (numericValue != null) {
      return '$currencySymbol${numericValue.toStringAsFixed(2)}';
    }

    return fixed;
  }

  /// Checks if a string contains any dollar signs
  static bool containsDollarSign(String input) {
    return input.contains(incorrectSymbol);
  }

  /// Scans a list of strings for dollar signs
  static List<String> findDollarSigns(List<String> inputs) {
    return inputs.where((input) => containsDollarSign(input)).toList();
  }

  /// Validates that all currency displays in a widget tree use peso signs
  static bool validateCurrencyConsistency(List<String> displayValues) {
    for (String value in displayValues) {
      if (containsDollarSign(value)) {
        return false;
      }
    }
    return true;
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\utils\error_logger.dart
â•‘ SIZE: 3.26 KB
â•‘ MODIFIED: 08/17/2025 13:29:21
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/foundation.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'constants.dart';

class ErrorLogger {
  static final ErrorLogger _instance = ErrorLogger._internal();
  factory ErrorLogger() => _instance;
  ErrorLogger._internal();

  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final List<ErrorLog> _localErrors = [];

  // Log error with context
  static void logError(
    String message, {
    String? context,
    dynamic error,
    StackTrace? stackTrace,
    Map<String, dynamic>? metadata,
  }) {
    final errorLog = ErrorLog(
      message: message,
      context: context ?? 'Unknown',
      error: error?.toString(),
      stackTrace: stackTrace?.toString(),
      metadata: metadata ?? {},
      timestamp: DateTime.now(),
    );

    if (kDebugMode) {
      debugPrint('[ERROR] ${errorLog.context}: ${errorLog.message}');
      if (errorLog.error != null) {
        debugPrint('[ERROR] Details: ${errorLog.error}');
      }
    }

    // Store locally
    _instance._localErrors.add(errorLog);

    // Keep only last 100 errors in memory
    if (_instance._localErrors.length > 100) {
      _instance._localErrors.removeAt(0);
    }

    // Try to log to Firestore (non-blocking)
    _instance._logToFirestore(errorLog);
  }

  // Log warning
  static void logWarning(
    String message, {
    String? context,
    Map<String, dynamic>? metadata,
  }) {
    if (kDebugMode) {
      debugPrint('[WARNING] ${context ?? 'Unknown'}: $message');
    }
  }

  // Log info
  static void logInfo(
    String message, {
    String? context,
    Map<String, dynamic>? metadata,
  }) {
    if (kDebugMode) {
      debugPrint('[INFO] ${context ?? 'Unknown'}: $message');
    }
  }

  Future<void> _logToFirestore(ErrorLog errorLog) async {
    try {
      await _firestore.collection(AppConstants.errorLogsCollection).add(errorLog.toMap());
    } catch (e) {
      // Don't throw errors from error logging
      if (kDebugMode) {
        debugPrint('[ERROR_LOGGER] Failed to log to Firestore: $e');
      }
    }
  }

  // Get recent errors for debugging
  List<ErrorLog> getRecentErrors({int limit = 50}) {
    return _localErrors.take(limit).toList();
  }

  // Clear local error cache
  void clearLocalErrors() {
    _localErrors.clear();
  }
}

class ErrorLog {
  final String message;
  final String context;
  final String? error;
  final String? stackTrace;
  final Map<String, dynamic> metadata;
  final DateTime timestamp;

  ErrorLog({
    required this.message,
    required this.context,
    this.error,
    this.stackTrace,
    required this.metadata,
    required this.timestamp,
  });

  Map<String, dynamic> toMap() {
    return {
      'message': message,
      'context': context,
      'error': error,
      'stackTrace': stackTrace,
      'metadata': metadata,
      'timestamp': timestamp.toIso8601String(),
      'platform': 'flutter',
    };
  }

  factory ErrorLog.fromMap(Map<String, dynamic> map) {
    return ErrorLog(
      message: map['message'] ?? '',
      context: map['context'] ?? 'Unknown',
      error: map['error'],
      stackTrace: map['stackTrace'],
      metadata: Map<String, dynamic>.from(map['metadata'] ?? {}),
      timestamp: DateTime.parse(
        map['timestamp'] ?? DateTime.now().toIso8601String(),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\utils\error_utils.dart
â•‘ SIZE: 0.7 KB
â•‘ MODIFIED: 09/10/2025 09:52:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:firebase_auth/firebase_auth.dart';

String getFirebaseAuthErrorMessage(FirebaseAuthException e) {
  switch (e.code) {
    case 'invalid-email':
      return 'The email address is badly formatted.';
    case 'user-not-found':
      return 'No user found for that email.';
    case 'wrong-password':
      return 'Wrong password provided for that user.';
    case 'email-already-in-use':
      return 'The email address is already in use by another account.';
    case 'weak-password':
      return 'The password provided is too weak.';
    case 'operation-not-allowed':
      return 'Email & Password accounts are not enabled.';
    default:
      return e.message ?? 'An unknown error occurred.';
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\utils\global_error_handler.dart
â•‘ SIZE: 0.51 KB
â•‘ MODIFIED: 08/22/2025 19:40:44
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/foundation.dart';
import 'package:prostock/utils/error_logger.dart';

class GlobalErrorHandler {
  static void initialize() {
    FlutterError.onError = (FlutterErrorDetails details) {
      ErrorLogger.logError(
        'Flutter error',
        error: details.exception,
        stackTrace: details.stack,
      );
    };

    PlatformDispatcher.instance.onError = (error, stack) {
      ErrorLogger.logError('Platform error', error: error, stackTrace: stack);
      return true;
    };
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\utils\notification_tester.dart
â•‘ SIZE: 2.03 KB
â•‘ MODIFIED: 10/02/2025 20:06:34
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:prostock/services/credit_check_service.dart';
import 'package:prostock/services/local_database_service.dart';
import 'package:prostock/services/notification_service.dart';

/// Utility class to test notifications manually
class NotificationTester {
  static Future<void> testCustomerPaymentNotifications() async {
    final notificationService = NotificationService();
    final creditCheckService = CreditCheckService(
      LocalDatabaseService.instance,
      notificationService,
    );

    // Test the actual credit check service
    await creditCheckService.checkDuePaymentsAndNotify();
  }

  static Future<void> testDirectNotifications() async {
    final notificationService = NotificationService();

    // Test direct notifications
    await notificationService.showNotification(
      999,
      'Test Notification',
      'This is a test notification to verify the system works',
      'test',
    );

    // Test overdue notification
    await notificationService.showNotification(
      998,
      'Test Overdue Payment',
      'John Doe has an overdue payment of \$150.00',
      'test_overdue',
    );

    // Test due today notification
    await notificationService.showNotification(
      997,
      'Test Due Payment',
      'Jane Smith has a payment due today of \$75.00',
      'test_due',
    );

    // Test almost due notification
    await notificationService.showNotification(
      996,
      'Test Almost Due Payment',
      'Mike Johnson has a payment due in 3 days of \$200.00',
      'test_almost_due',
    );
  }

  static Future<void> testScheduledNotification() async {
    final notificationService = NotificationService();

    // Schedule a notification for 10 seconds from now
    await notificationService.scheduleNotification(
      id: 995,
      title: 'Scheduled Test',
      body: 'This notification was scheduled 10 seconds ago',
      scheduledDate: DateTime.now().add(const Duration(seconds: 10)),
      payload: 'scheduled_test',
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\utils\password_helper.dart
â•‘ SIZE: 1.87 KB
â•‘ MODIFIED: 08/31/2025 19:50:32
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:convert';
import 'dart:math';
import 'package:crypto/crypto.dart';

class PasswordHelper {
  static const int _saltLength = 32;

  /// Generates a random salt for password hashing
  static String _generateSalt() {
    final random = Random.secure();
    final saltBytes = List<int>.generate(
      _saltLength,
      (i) => random.nextInt(256),
    );
    return base64.encode(saltBytes);
  }

  /// Hashes a password with a salt using SHA-256
  static String hashPassword(String password, [String? salt]) {
    salt ??= _generateSalt();
    final bytes = utf8.encode(password + salt);
    final digest = sha256.convert(bytes);
    return '${digest.toString()}:$salt';
  }

  /// Verifies a password against a hashed password
  static bool verifyPassword(String password, String hashedPassword) {
    try {
      final parts = hashedPassword.split(':');
      if (parts.length != 2) return false;

      final salt = parts[1];

      final testHash = hashPassword(password, salt);
      return testHash == hashedPassword;
    } catch (e) {
      return false;
    }
  }

  /// Validates password strength
  static bool isPasswordStrong(String password) {
    if (password.length < 8) return false;

    bool hasUppercase = password.contains(RegExp(r'[A-Z]'));
    bool hasLowercase = password.contains(RegExp(r'[a-z]'));
    bool hasDigits = password.contains(RegExp(r'[0-9]'));
    bool hasSpecialCharacters = password.contains(
      RegExp(r'[!@#$%^&*(),.?":{}|<>]'),
    );

    return hasUppercase && hasLowercase && hasDigits && hasSpecialCharacters;
  }

  /// Gets password strength description
  static String getPasswordStrengthDescription(String password) {
    if (password.length < 6) return 'Too short';
    if (password.length < 8) return 'Weak';
    if (!isPasswordStrong(password)) return 'Medium';
    return 'Strong';
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\add_customer_dialog.dart
â•‘ SIZE: 17.12 KB
â•‘ MODIFIED: 10/06/2025 22:48:46
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:image_picker/image_picker.dart';
import 'package:prostock/models/customer.dart';
import 'package:prostock/providers/customer_provider.dart';
import 'package:prostock/services/cloudinary_service.dart';
import 'package:prostock/services/offline_manager.dart';
import 'package:prostock/utils/error_logger.dart';
import 'package:prostock/widgets/confirmation_dialog.dart';
import 'package:provider/provider.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;

class AddCustomerDialog extends StatefulWidget {
  final Customer? customer;
  final OfflineManager offlineManager;
  const AddCustomerDialog({
    super.key,
    this.customer,
    required this.offlineManager,
  });

  @override
  State<AddCustomerDialog> createState() => _AddCustomerDialogState();
}

class _AddCustomerDialogState extends State<AddCustomerDialog> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _phoneController = TextEditingController();
  final _emailController = TextEditingController();
  final _addressController = TextEditingController();
  final _creditLimitController = TextEditingController();

  bool _isLoading = false;
  File? _imageFile;
  String? _networkImageUrl;

  bool get _isEditMode => widget.customer != null;

  @override
  void initState() {
    super.initState();
    if (_isEditMode) {
      final customer = widget.customer!;
      _nameController.text = customer.name;

      String? displayPhone = customer.phone;
      if (displayPhone != null && displayPhone.isNotEmpty) {
        displayPhone = displayPhone.replaceAll(RegExp(r'[\s\-]'), '');
        if (displayPhone.startsWith('+63')) {
          displayPhone = displayPhone.substring(3);
        } else if (displayPhone.startsWith('63')) {
          displayPhone = displayPhone.substring(2);
        } else if (displayPhone.startsWith('0')) {
          displayPhone = displayPhone.substring(1);
        }
      }
      _phoneController.text = displayPhone ?? '';

      _emailController.text = customer.email ?? '';
      _addressController.text = customer.address ?? '';
      _creditLimitController.text = customer.creditLimit.toString();
      _networkImageUrl = customer.imageUrl;
      if (customer.localImagePath != null) {
        _imageFile = File(customer.localImagePath!);
      }
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _phoneController.dispose();
    _emailController.dispose();
    _addressController.dispose();
    _creditLimitController.dispose();
    super.dispose();
  }

  Future<void> _pickImage(ImageSource source) async {
    try {
      final pickedFile = await ImagePicker().pickImage(source: source);
      if (pickedFile != null) {
        final appDir = await getApplicationDocumentsDirectory();
        final fileName = p.basename(pickedFile.path);
        final savedImage = await File(
          pickedFile.path,
        ).copy('${appDir.path}/$fileName');
        setState(() {
          _imageFile = savedImage;
        });
      }
    } catch (e, s) {
      ErrorLogger.logError('Error picking image', error: e, stackTrace: s);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error picking image: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  void _showImageSourceActionSheet() {
    showModalBottomSheet(
      context: context,
      builder: (context) => SafeArea(
        child: Wrap(
          children: [
            ListTile(
              leading: const Icon(Icons.photo_library),
              title: const Text('Gallery'),
              onTap: () {
                Navigator.of(context).pop();
                _pickImage(ImageSource.gallery);
              },
            ),
            ListTile(
              leading: const Icon(Icons.camera_alt),
              title: const Text('Camera'),
              onTap: () {
                Navigator.of(context).pop();
                _pickImage(ImageSource.camera);
              },
            ),
          ],
        ),
      ),
    );
  }

  Future<String?> _uploadImage(File imageFile) async {
    try {
      return await CloudinaryService.instance.uploadImage(imageFile);
    } catch (e, s) {
      ErrorLogger.logError('Error uploading image', error: e, stackTrace: s);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('An unknown error occurred during image upload.'),
            backgroundColor: Colors.red,
          ),
        );
      }
      return null;
    }
  }

  Future<void> _saveCustomer() async {
    if (!_formKey.currentState!.validate()) return;

    final confirmed = await showConfirmationDialog(
      context: context,
      title: _isEditMode ? 'Update Customer' : 'Add Customer',
      content: _isEditMode
          ? 'Are you sure you want to save changes to ${widget.customer!.name}?'
          : 'Are you sure you want to add this customer?',
      confirmText: _isEditMode ? 'Save' : 'Add',
    );

    if (confirmed != true) return;

    setState(() {
      _isLoading = true;
    });

    try {
      String? imageUrl = _networkImageUrl;
      String? localImagePath = _imageFile?.path;

      if (_imageFile != null && widget.offlineManager.isOnline) {
        imageUrl = await _uploadImage(_imageFile!);
        if (imageUrl == null) {
          setState(() {
            _isLoading = false;
          });
          return;
        }
      }

      String? phone = _phoneController.text.trim();
      final email = _emailController.text.trim();
      final address = _addressController.text.trim();
      final creditLimit =
          double.tryParse(_creditLimitController.text.trim()) ?? 0.0;

      if (phone.isNotEmpty) {
        phone = phone.replaceAll(RegExp(r'[\s\-\+]'), '');
        if (phone.startsWith('63')) {
          phone = phone.substring(2);
        }
        if (phone.startsWith('0')) {
          phone = phone.substring(1);
        }
        phone = '+63$phone';
      } else {
        phone = null;
      }

      final customerData = Customer(
        id: _isEditMode ? widget.customer!.id : null,
        name: _nameController.text.trim(),
        phone: phone,
        email: email.isEmpty ? null : email,
        address: address.isEmpty ? null : address,
        imageUrl: imageUrl,
        localImagePath: localImagePath,
        balance: _isEditMode ? widget.customer!.balance : 0.0,
        creditLimit: creditLimit,
        createdAt: _isEditMode ? widget.customer!.createdAt : DateTime.now(),
        updatedAt: DateTime.now(),
      );

      if (!mounted) return;

      final provider = Provider.of<CustomerProvider>(context, listen: false);
      Customer? result;
      if (_isEditMode) {
        final updateResult = await provider.updateCustomer(customerData);
        result = updateResult.success ? customerData : null;
      } else {
        result = await provider.addCustomer(customerData);
      }

      if (result != null) {
        if (imageUrl != null) {
          ErrorLogger.logError(
            'INFO: Image uploaded for customer ${result.id}',
            context: 'AddCustomerDialog._saveCustomer',
            metadata: {'imageUrl': imageUrl},
          );
        }
        if (mounted) {
          Navigator.pop(context);
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                'Customer "${result.name}" ${_isEditMode ? 'updated' : 'added'} successfully!',
              ),
              backgroundColor: Colors.green,
              duration: const Duration(seconds: 3),
            ),
          );
        }
      } else {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                'Failed to ${_isEditMode ? 'update' : 'add'} customer. ${provider.error ?? ''}',
              ),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } on FormatException catch (e, s) {
      ErrorLogger.logError(
        'Invalid number format in add customer dialog',
        error: e,
        stackTrace: s,
      );
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Invalid number format. Please check credit limit.'),
            backgroundColor: Colors.red,
            duration: Duration(seconds: 3),
          ),
        );
      }
    } on ArgumentError catch (e, s) {
      ErrorLogger.logError(
        'Invalid argument in add customer dialog',
        error: e,
        stackTrace: s,
      );
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Input Error: ${e.message}'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 4),
          ),
        );
      }
    } catch (e, s) {
      ErrorLogger.logError('Error saving customer', error: e, stackTrace: s);
      if (mounted) {
        String errorMessage = 'Error saving customer';

        if (e.toString().contains('already exists')) {
          errorMessage =
              'Customer with this name, phone, or email already exists.';
        } else if (e.toString().contains('network') ||
            e.toString().contains('connection')) {
          errorMessage = 'Network error. Please check your connection.';
        } else {
          errorMessage = 'An unexpected error occurred: ${e.toString()}';
        }

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(errorMessage),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 4),
            action: SnackBarAction(
              label: 'Retry',
              textColor: Colors.white,
              onPressed: _saveCustomer,
            ),
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(_isEditMode ? 'Edit Customer' : 'Add New Customer'),
      content: SizedBox(
        width: MediaQuery.of(context).size.width * 0.9,
        child: Form(
          key: _formKey,
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                GestureDetector(
                  onTap: _showImageSourceActionSheet,
                  child: Container(
                    width: double.infinity,
                    height: 200,
                    decoration: BoxDecoration(
                      border: Border.all(color: Colors.grey),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: _imageFile != null
                        ? ClipRRect(
                            borderRadius: BorderRadius.circular(8),
                            child: Image.file(_imageFile!, fit: BoxFit.cover),
                          )
                        : widget.customer?.localImagePath != null
                        ? ClipRRect(
                            borderRadius: BorderRadius.circular(8),
                            child: Image.file(
                              File(widget.customer!.localImagePath!),
                              fit: BoxFit.cover,
                            ),
                          )
                        : _networkImageUrl != null
                        ? ClipRRect(
                            borderRadius: BorderRadius.circular(8),
                            child: Image.network(
                              _networkImageUrl!,
                              fit: BoxFit.cover,
                            ),
                          )
                        : const Icon(
                            Icons.add_a_photo,
                            size: 50,
                            color: Colors.grey,
                          ),
                  ),
                ),
                const SizedBox(height: 16),

                TextFormField(
                  controller: _nameController,
                  textCapitalization: TextCapitalization.words,
                  decoration: const InputDecoration(
                    labelText: 'Customer Name *',
                    border: OutlineInputBorder(),
                    prefixIcon: Icon(Icons.person),
                  ),
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return 'Please enter customer name';
                    }
                    if (value.trim().length < 2) {
                      return 'Name must be at least 2 characters';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                TextFormField(
                  controller: _phoneController,
                  keyboardType: TextInputType.phone,
                  inputFormatters: [FilteringTextInputFormatter.digitsOnly],
                  decoration: const InputDecoration(
                    labelText: 'Phone Number',
                    border: OutlineInputBorder(),
                    prefixIcon: Icon(Icons.phone),
                    helperText: 'e.g. 9123456789',
                    prefixText: '+63 ',
                  ),
                  validator: (value) {
                    if (value != null && value.trim().isNotEmpty) {
                      final cleanNumber = value.trim();
                      if (!RegExp(r'^[9][0-9]{9}').hasMatch(cleanNumber)) {
                        return 'Enter a valid 10-digit number starting with 9';
                      }
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                TextFormField(
                  controller: _emailController,
                  keyboardType: TextInputType.emailAddress,
                  decoration: const InputDecoration(
                    labelText: 'Email Address',
                    border: OutlineInputBorder(),
                    prefixIcon: Icon(Icons.email),
                    helperText: 'Optional',
                  ),
                  validator: (value) {
                    if (value != null && value.trim().isNotEmpty) {
                      if (!RegExp(
                        r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}',
                      ).hasMatch(value.trim())) {
                        return 'Enter a valid email address';
                      }
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                TextFormField(
                  controller: _addressController,
                  maxLines: 2,
                  textCapitalization: TextCapitalization.sentences,
                  decoration: const InputDecoration(
                    labelText: 'Address',
                    border: OutlineInputBorder(),
                    prefixIcon: Icon(Icons.location_on),
                    helperText: 'Optional',
                    alignLabelWithHint: true,
                  ),
                ),
                const SizedBox(height: 16),

                TextFormField(
                  controller: _creditLimitController,
                  keyboardType: const TextInputType.numberWithOptions(
                    decimal: true,
                  ),
                  decoration: const InputDecoration(
                    labelText: 'Credit Limit',
                    border: OutlineInputBorder(),
                    prefixIcon: Icon(Icons.credit_card),
                  ),
                  validator: (value) {
                    if (value != null && value.trim().isNotEmpty) {
                      if (double.tryParse(value.trim()) == null) {
                        return 'Please enter a valid number';
                      }
                    }
                    return null;
                  },
                ),
              ],
            ),
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.pop(context),
          child: const Text('Cancel'),
        ),
        ElevatedButton(
          onPressed: _isLoading ? null : _saveCustomer,
          child: _isLoading
              ? const SizedBox(
                  width: 16,
                  height: 16,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : Text(_isEditMode ? 'Save Changes' : 'Add Customer'),
        ),
      ],
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\add_product_dialog.dart
â•‘ SIZE: 13.41 KB
â•‘ MODIFIED: 10/21/2025 07:26:57
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/utils/error_logger.dart';
import 'package:provider/provider.dart';
import '../providers/inventory_provider.dart';
import '../models/product.dart';
import '../utils/constants.dart';
import '../services/tax_service.dart';

class AddProductDialog extends StatefulWidget {
  final Product? product;
  const AddProductDialog({super.key, this.product});

  @override
  State<AddProductDialog> createState() => _AddProductDialogState();
}

class _AddProductDialogState extends State<AddProductDialog> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _barcodeController = TextEditingController();
  final _costController = TextEditingController();
  final _stockController = TextEditingController();
  final _minStockController = TextEditingController(text: '5');

  String _selectedCategory = AppConstants.productCategories.first;
  bool _isLoading = false;

  final List<String> _categories = AppConstants.productCategories;

  bool get _isEditing => widget.product != null;

  @override
  void initState() {
    super.initState();
    if (_isEditing) {
      final product = widget.product!;
      _nameController.text = product.name;
      _barcodeController.text = product.barcode ?? '';
      _costController.text = product.cost.toString();
      _stockController.text = product.stock.toString();
      _minStockController.text = product.minStock.toString();

      // FIX: Ensure the product's category exists in the list
      if (_categories.contains(product.category)) {
        _selectedCategory = product.category!;
      } else {
        // If the product's category doesn't exist, default to first category
        _selectedCategory = _categories.first;
      }
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _barcodeController.dispose();
    _costController.dispose();
    _stockController.dispose();
    _minStockController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(_isEditing ? 'Product Information' : 'Add New Product'),
      content: SizedBox(
        width: MediaQuery.of(context).size.width * 0.9,
        child: Form(
          key: _formKey,
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                // Product Name
                TextFormField(
                  controller: _nameController,
                  decoration: const InputDecoration(
                    labelText: 'Product Name *',
                    border: OutlineInputBorder(),
                    prefixIcon: Icon(Icons.inventory),
                  ),
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return 'Please enter product name';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // Barcode (Optional)
                TextFormField(
                  controller: _barcodeController,
                  readOnly: _isEditing,
                  decoration: const InputDecoration(
                    labelText: 'Barcode (Optional)',
                    border: OutlineInputBorder(),
                    prefixIcon: Icon(Icons.qr_code),
                    helperText: 'Leave empty if no barcode',
                  ),
                  validator: (value) {
                    // Optional validation for barcode format if needed
                    if (value != null && value.trim().isNotEmpty) {
                      // Add any barcode format validation here if needed
                      if (value.trim().length < 8) {
                        return 'Barcode must be at least 8 characters';
                      }
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // Category Dropdown
                DropdownButtonFormField<String>(
                  isExpanded: true,
                  initialValue: _selectedCategory,
                  decoration: const InputDecoration(
                    labelText: 'Category',
                    border: OutlineInputBorder(),
                    prefixIcon: Icon(Icons.category),
                  ),
                  items: _categories.map((category) {
                    return DropdownMenuItem(
                      value: category,
                      child: Text(category, overflow: TextOverflow.ellipsis),
                    );
                  }).toList(),
                  onChanged: (value) {
                    if (value != null) {
                      setState(() {
                        _selectedCategory = value;
                      });
                    }
                  },
                ),
                const SizedBox(height: 16),

                // Cost Row
                TextFormField(
                  controller: _costController,
                  readOnly: _isEditing,
                  keyboardType: const TextInputType.numberWithOptions(
                    decimal: true,
                  ),
                  decoration: const InputDecoration(
                    labelText: 'Cost Price *',
                    border: OutlineInputBorder(),
                    prefixText: '₱ ', // Philippine Peso symbol
                    prefixIcon: Icon(Icons.shopping_cart),
                  ),
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return 'Enter cost';
                    }
                    final cost = double.tryParse(value.trim());
                    if (cost == null || cost < 0) {
                      return 'Enter valid cost';
                    }
                    return null;
                  },
                  onChanged: (value) {
                    setState(() {}); // Trigger profit margin recalculation
                  },
                ),
                const SizedBox(height: 16),

                // Stock and Min Stock Row
                Row(
                  children: [
                    Expanded(
                      child: TextFormField(
                        controller: _stockController,
                        readOnly: _isEditing,
                        keyboardType: TextInputType.number,
                        decoration: const InputDecoration(
                          labelText: 'Initial Stock *',
                          border: OutlineInputBorder(),
                          prefixIcon: Icon(Icons.inventory_2),
                          suffixText: 'pcs',
                        ),
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return 'Enter stock';
                          }
                          final stock = int.tryParse(value.trim());
                          if (stock == null || stock < 0) {
                            return 'Enter valid stock';
                          }
                          return null;
                        },
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: TextFormField(
                        controller: _minStockController,
                        readOnly: _isEditing,
                        keyboardType: TextInputType.number,
                        decoration: const InputDecoration(
                          labelText: 'Min Stock Alert',
                          border: OutlineInputBorder(),
                          prefixIcon: Icon(Icons.warning),
                          suffixText: 'pcs',
                        ),
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return null; // Optional field
                          }
                          final minStock = int.tryParse(value.trim());
                          if (minStock == null || minStock < 0) {
                            return 'Enter valid number';
                          }
                          return null;
                        },
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),

                // Profit Margin Display
                _buildProfitMarginDisplay(),
              ],
            ),
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.pop(context),
          child: const Text('Cancel'),
        ),
        ElevatedButton(
          onPressed: _isLoading ? null : _saveProduct,
          child: _isLoading
              ? const SizedBox(
                  width: 16,
                  height: 16,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : Text(_isEditing ? 'Save Changes' : 'Add Product'),
        ),
      ],
    );
  }

  Widget _buildProfitMarginDisplay() {
    final cost = double.tryParse(_costController.text.trim()) ?? 0;

    final price = TaxService.calculateSellingPriceSync(cost);
    final profit = price - cost;
    final margin = cost > 0 ? (profit / cost * 100) : 0;

    // Only show if both price and cost have values
    if (cost == 0) {
      return const SizedBox.shrink();
    }

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: margin > 20 ? Colors.green.shade50 : Colors.orange.shade50,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: margin > 20 ? Colors.green : Colors.orange),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Selling Price',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              Text('₱${price.toStringAsFixed(2)}'),
              const SizedBox(height: 8),
              const Text(
                'Profit Margin',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              Text(
                '₱${profit.toStringAsFixed(2)} (${margin.toStringAsFixed(1)}%)',
              ),
            ],
          ),
          Icon(
            margin > 20 ? Icons.trending_up : Icons.warning,
            color: margin > 20 ? Colors.green : Colors.orange,
          ),
        ],
      ),
    );
  }

  Future<void> _saveProduct() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
    });

    try {
      final inventoryProvider = Provider.of<InventoryProvider>(
        context,
        listen: false,
      );
      final cost = double.parse(_costController.text.trim());
      final stock = int.parse(_stockController.text.trim());
      final minStock = int.tryParse(_minStockController.text.trim()) ?? 5;
      final barcode = _barcodeController.text.trim();
      final finalBarcode = barcode.isEmpty ? null : barcode;

      if (_isEditing) {
        // Update existing product
        final updatedProduct = widget.product!.copyWith(
          name: _nameController.text.trim(),
          barcode: finalBarcode,
          cost: cost,
          stock: stock,
          minStock: minStock,
          category: _selectedCategory,
          updatedAt: DateTime.now(),
        );
        await inventoryProvider.updateProduct(updatedProduct);
        if (mounted) {
          Navigator.pop(context, updatedProduct);
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Product "${updatedProduct.name}" updated!'),
              backgroundColor: Colors.green,
            ),
          );
        }
      } else {
        // Add new product
        final product = Product(
          name: _nameController.text.trim(),
          barcode: finalBarcode,
          cost: cost,
          stock: stock,
          minStock: minStock,
          category: _selectedCategory,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );
        final newProduct = await inventoryProvider.addProduct(product);
        if (mounted) {
          Navigator.pop(context, newProduct);
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Product "${product.name}" added successfully!'),
              backgroundColor: Colors.green,
            ),
          );
        }
      }
    } catch (e, s) {
      ErrorLogger.logError('Error saving product', error: e, stackTrace: s);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error saving product: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\analytics_report_widget.dart
â•‘ SIZE: 2.07 KB
â•‘ MODIFIED: 10/02/2025 12:09:41
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

// Model imports
import 'package:prostock/models/loss.dart';
import 'package:prostock/models/sale_item.dart';

// Provider imports
import '../providers/customer_provider.dart';
import '../providers/inventory_provider.dart';
import '../providers/sales_provider.dart';

// Widget imports
import 'sales_over_time_chart.dart';
import 'loss_over_time_chart.dart';

class AnalyticsReportWidget extends StatelessWidget {
  final List<SaleItem> saleItems;
  final List<Loss> losses;

  const AnalyticsReportWidget({
    super.key,
    required this.saleItems,
    required this.losses,
  });

  @override
  Widget build(BuildContext context) {
    return Consumer3<SalesProvider, InventoryProvider, CustomerProvider>(
      builder:
          (context, salesProvider, inventoryProvider, customerProvider, child) {
            return SingleChildScrollView(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Sales Over Time',
                    style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 16),
                  if (salesProvider.sales.isEmpty)
                    const Center(child: Text('No sales data available.'))
                  else
                    SalesOverTimeChart(sales: salesProvider.sales),
                  const SizedBox(height: 24),
                  const Text(
                    'Losses Over Time',
                    style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 16),
                  if (losses.isEmpty)
                    const Center(child: Text('No loss data available.'))
                  else
                    LossOverTimeChart(losses: losses),
                ],
              ),
            );
          },
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\barcode_product_dialog.dart
â•‘ SIZE: 16.59 KB
â•‘ MODIFIED: 10/02/2025 12:23:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/utils/error_logger.dart';
import 'package:provider/provider.dart';
import '../providers/inventory_provider.dart';
import '../models/product.dart';
import '../utils/constants.dart';
import '../services/tax_service.dart';

class BarcodeProductDialog extends StatefulWidget {
  final String barcode;

  const BarcodeProductDialog({super.key, required this.barcode});

  @override
  State<BarcodeProductDialog> createState() => _BarcodeProductDialogState();
}

class _BarcodeProductDialogState extends State<BarcodeProductDialog> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _costController = TextEditingController();
  final _stockController = TextEditingController();
  final _minStockController = TextEditingController(text: '5');

  String _selectedCategory = AppConstants.productCategories.first;
  bool _isLoading = false;
  bool _showSuccess = false;

  final List<String> _categories = AppConstants.productCategories;

  @override
  void dispose() {
    _nameController.dispose();
    _costController.dispose();
    _stockController.dispose();
    _minStockController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      scrollable: true, // Added to make the dialog content scrollable
      title: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('Add New Product'),
          const SizedBox(height: 4),
          Text(
            'Barcode: ${widget.barcode}',
            style: const TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.normal,
              color: Colors.grey,
            ),
          ),
        ],
      ),
      content: _showSuccess ? _buildSuccessContent() : _buildFormContent(),
      actions: _showSuccess ? _buildSuccessActions() : _buildFormActions(),
    );
  }

  Widget _buildSuccessContent() {
    final cost = double.tryParse(_costController.text.trim()) ?? 0;
    return SizedBox(
      width: MediaQuery.of(context).size.width * 0.9,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            padding: const EdgeInsets.all(20),
            decoration: BoxDecoration(
              color: Colors.green.shade50,
              borderRadius: BorderRadius.circular(16),
              border: Border.all(color: Colors.green.shade200),
            ),
            child: Column(
              children: [
                Icon(
                  Icons.check_circle,
                  color: Colors.green.shade600,
                  size: 64,
                ),
                const SizedBox(height: 16),
                Text(
                  'Product Added Successfully!',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: Colors.green.shade800,
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 8),
                Text(
                  '"${_nameController.text}" has been added to your inventory.',
                  style: TextStyle(fontSize: 14, color: Colors.green.shade700),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 16),
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.green.shade200),
                  ),
                  child: Column(
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          const Text(
                            'Initial Stock:',
                            style: TextStyle(fontWeight: FontWeight.w500),
                          ),
                          Text('${_stockController.text}pcs'),
                        ],
                      ),
                      const SizedBox(height: 4),
                      FutureBuilder<double>(
                        future: TaxService.calculateSellingPriceWithRule(
                          cost,
                          categoryName: _selectedCategory,
                        ),
                        builder: (context, snapshot) {
                          if (snapshot.hasData) {
                            return Row(
                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                              children: [
                                const Text(
                                  'Selling Price:',
                                  style: TextStyle(fontWeight: FontWeight.w500),
                                ),
                                Text('₱${snapshot.data!.toStringAsFixed(2)}'),
                              ],
                            );
                          }
                          return const Row(
                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                            children: [
                              Text(
                                'Selling Price:',
                                style: TextStyle(fontWeight: FontWeight.w500),
                              ),
                              Text('Calculating...'),
                            ],
                          );
                        },
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFormContent() {
    return Form(
      key: _formKey,
      child: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Product Name
            TextFormField(
              controller: _nameController,
              decoration: const InputDecoration(
                labelText: 'Product Name *',
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.inventory),
              ),
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return 'Please enter product name';
                }
                return null;
              },
            ),
            const SizedBox(height: 16),

            // Category Dropdown
            DropdownButtonFormField<String>(
              isExpanded: true, // Added to allow the dropdown to expand
              initialValue: _selectedCategory,
              decoration: const InputDecoration(
                labelText: 'Category',
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.category),
              ),
              items: _categories.map((category) {
                return DropdownMenuItem(
                  value: category,
                  child: Text(
                    category,
                    overflow: TextOverflow.ellipsis, // Handle long text
                  ),
                );
              }).toList(),
              onChanged: (value) {
                setState(() {
                  _selectedCategory = value!;
                });
              },
            ),
            const SizedBox(height: 16),

            // Cost Row
            TextFormField(
              controller: _costController,
              keyboardType: const TextInputType.numberWithOptions(
                decimal: true,
              ),
              decoration: const InputDecoration(
                labelText: 'Cost Price *',
                border: OutlineInputBorder(),
                prefixText: '₱ ',
                prefixIcon: Icon(Icons.local_mall),
              ),
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return 'Enter cost';
                }
                final cost = double.tryParse(value);
                if (cost == null || cost < 0) {
                  return 'Enter valid cost';
                }
                return null;
              },
            ),
            const SizedBox(height: 16),

            // Stock and Min Stock Row
            Row(
              children: [
                Expanded(
                  child: TextFormField(
                    controller: _stockController,
                    keyboardType: TextInputType.number,
                    decoration: const InputDecoration(
                      labelText: 'Initial Stock *',
                      border: OutlineInputBorder(),
                      prefixIcon: Icon(Icons.inventory_2),
                      suffixText: 'pcs',
                    ),
                    validator: (value) {
                      if (value == null || value.trim().isEmpty) {
                        return 'Enter stock';
                      }
                      final stock = int.tryParse(value);
                      if (stock == null || stock < 0) {
                        return 'Enter valid stock';
                      }
                      return null;
                    },
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: TextFormField(
                    controller: _minStockController,
                    keyboardType: TextInputType.number,
                    decoration: const InputDecoration(
                      labelText: 'Min Stock Alert',
                      border: OutlineInputBorder(),
                      prefixIcon: Icon(Icons.warning),
                      suffixText: 'pcs',
                    ),
                    validator: (value) {
                      if (value == null || value.trim().isEmpty) {
                        return null;
                      }
                      final minStock = int.tryParse(value);
                      if (minStock == null || minStock < 0) {
                        return 'Enter valid number';
                      }
                      return null;
                    },
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),

            // Profit Margin Display
            FutureBuilder<double>(
              future: () async {
                final cost = double.tryParse(_costController.text) ?? 0;
                return await TaxService.calculateSellingPriceWithRule(
                  cost,
                  categoryName: _selectedCategory,
                );
              }(),
              builder: (context, snapshot) {
                final cost = double.tryParse(_costController.text) ?? 0;

                if (snapshot.hasData) {
                  final price = snapshot.data!;
                  final profit = price - cost;
                  final margin = cost > 0 ? (profit / cost * 100) : 0;

                  return Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: margin > 20
                          ? Colors.green.shade50
                          : Colors.orange.shade50,
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(
                        color: margin > 20 ? Colors.green : Colors.orange,
                      ),
                    ),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const Text(
                              'Selling Price',
                              style: TextStyle(fontWeight: FontWeight.bold),
                            ),
                            Text('₱${price.toStringAsFixed(2)}'),
                            const SizedBox(height: 8),
                            const Text(
                              'Profit Margin',
                              style: TextStyle(fontWeight: FontWeight.bold),
                            ),
                            Text(
                              '₱${profit.toStringAsFixed(2)} (${margin.toStringAsFixed(1)}%)',
                            ),
                          ],
                        ),
                        Icon(
                          margin > 20 ? Icons.trending_up : Icons.warning,
                          color: margin > 20 ? Colors.green : Colors.orange,
                        ),
                      ],
                    ),
                  );
                }

                return Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.grey.shade50,
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.grey),
                  ),
                  child: const Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text('Calculating profit margin...'),
                      CircularProgressIndicator(),
                    ],
                  ),
                );
              },
            ),
          ],
        ),
      ),
    );
  }

  List<Widget> _buildFormActions() {
    return [
      TextButton(
        onPressed: _isLoading ? null : () => Navigator.pop(context),
        child: const Text('Cancel'),
      ),
      ElevatedButton(
        onPressed: _isLoading ? null : _saveProduct,
        child: _isLoading
            ? const SizedBox(
                width: 16,
                height: 16,
                child: CircularProgressIndicator(strokeWidth: 2),
              )
            : const Text('Add Product'),
      ),
    ];
  }

  List<Widget> _buildSuccessActions() {
    return [
      TextButton(
        onPressed: () => Navigator.pop(context, true),
        child: const Text('View Inventory'),
      ),
      ElevatedButton(
        onPressed: () => Navigator.pop(context, true),
        style: ElevatedButton.styleFrom(
          backgroundColor: Colors.green,
          foregroundColor: Colors.white,
        ),
        child: const Text('Done'),
      ),
    ];
  }

  Future<void> _saveProduct() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
    });

    try {
      final product = Product(
        name: _nameController.text.trim(),
        barcode: widget.barcode,
        cost: double.parse(_costController.text),
        stock: int.parse(_stockController.text),
        minStock: int.tryParse(_minStockController.text) ?? 5,
        category: _selectedCategory,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final newProduct = await Provider.of<InventoryProvider>(
        context,
        listen: false,
      ).addProduct(product);

      if (newProduct != null && mounted) {
        setState(() {
          _isLoading = false;
          _showSuccess = true;
        });

        Future.delayed(const Duration(seconds: 3), () {
          if (mounted && _showSuccess) {
            Navigator.pop(context, true);
          }
        });
      }
    } catch (e, s) {
      ErrorLogger.logError(
        'Error adding product from barcode',
        error: e,
        stackTrace: s,
      );
      if (mounted) {
        setState(() {
          _isLoading = false;
        });

        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            title: const Row(
              children: [
                Icon(Icons.error, color: Colors.red),
                SizedBox(width: 8),
                Text('Error Adding Product'),
              ],
            ),
            content: Text(
              'Failed to add product: $e\n\nPlease check your input and try again.',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text('OK'),
              ),
            ],
          ),
        );
      }
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\barcode_scanner_widget.dart
â•‘ SIZE: 32.93 KB
â•‘ MODIFIED: 10/02/2025 12:23:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:developer';

import 'package:prostock/models/stock_update_result.dart';
import 'package:flutter/material.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import 'package:prostock/utils/error_logger.dart';
import 'package:provider/provider.dart';
import 'package:permission_handler/permission_handler.dart';
import '../providers/inventory_provider.dart';
import '../providers/sales_provider.dart';
import '../services/tax_service.dart';
import '../models/product.dart';
import '../models/loss_reason.dart';
import 'add_product_dialog.dart';
import 'barcode_product_dialog.dart';
import 'receive_stock_dialog.dart';

enum ScannerMode {
  normal, // Default mode for sales/finding products
  receiveStock, // Mode for receiving/adding stock
  removeStock, // Mode for removing stock
}

class BarcodeScannerWidget extends StatefulWidget {
  final ScannerMode mode;

  const BarcodeScannerWidget({super.key, this.mode = ScannerMode.normal});

  @override
  State<BarcodeScannerWidget> createState() => _BarcodeScannerWidgetState();
}

class _BarcodeScannerWidgetState extends State<BarcodeScannerWidget> {
  MobileScannerController cameraController = MobileScannerController(
    autoStart: false,
  );
  bool _isProcessing = false;
  bool _hasPermission = false;
  bool _isInitializing = true;
  String? _errorMessage;

  // Track torch and camera state manually
  bool _isTorchOn = false;
  bool _isBackCamera = true;

  @override
  void initState() {
    super.initState();
    _initializeCamera();
  }

  Future<void> _initializeCamera() async {
    try {
      final status = await Permission.camera.status;
      if (status.isDenied) {
        final result = await Permission.camera.request();
        if (result.isDenied) {
          setState(() {
            _errorMessage = 'Camera permission is required to scan barcodes';
            _isInitializing = false;
          });
          return;
        }
      }

      if (status.isPermanentlyDenied) {
        setState(() {
          _errorMessage =
              'Camera permission is permanently denied. Please enable it in settings.';
          _isInitializing = false;
        });
        return;
      }

      setState(() {
        _hasPermission = true;
        _isInitializing = false;
      });

      await cameraController.start();
    } catch (e, s) {
      ErrorLogger.logError(
        'Failed to initialize camera',
        error: e,
        stackTrace: s,
      );
      setState(() {
        _errorMessage = 'Failed to initialize camera: $e';
        _isInitializing = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      appBar: AppBar(
        title: Text(
          _getAppBarTitle(),
          style: const TextStyle(fontWeight: FontWeight.w600),
        ),
        backgroundColor: Colors.black,
        foregroundColor: Colors.white,
        elevation: 0,
        actions: [
          if (_hasPermission && !_isInitializing) ...[
            Container(
              margin: const EdgeInsets.only(right: 8),
              decoration: BoxDecoration(
                color: Colors.white.withValues(alpha: .1),
                borderRadius: BorderRadius.circular(8),
              ),
              child: IconButton(
                icon: Icon(
                  _isTorchOn ? Icons.flash_on : Icons.flash_off,
                  color: _isTorchOn ? Colors.amber : Colors.white70,
                ),
                onPressed: () async {
                  try {
                    await cameraController.toggleTorch();
                    setState(() {
                      _isTorchOn = !_isTorchOn;
                    });
                  } catch (e, s) {
                    ErrorLogger.logError(
                      'Torch toggle error',
                      error: e,
                      stackTrace: s,
                    );
                    // Handle error silently or show snackbar
                    log('Torch toggle error: $e');
                  }
                },
              ),
            ),
            Container(
              margin: const EdgeInsets.only(right: 16),
              decoration: BoxDecoration(
                color: Colors.white.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(8),
              ),
              child: IconButton(
                icon: Icon(
                  _isBackCamera ? Icons.camera_rear : Icons.camera_front,
                  color: Colors.white70,
                ),
                onPressed: () async {
                  try {
                    await cameraController.switchCamera();
                    setState(() {
                      _isBackCamera = !_isBackCamera;
                    });
                  } catch (e, s) {
                    ErrorLogger.logError(
                      'Camera switch error',
                      error: e,
                      stackTrace: s,
                    );
                    // Handle error silently or show snackbar
                    log('Camera switch error: $e');
                  }
                },
              ),
            ),
          ],
        ],
      ),
      body: _buildBody(),
    );
  }

  String _getAppBarTitle() {
    switch (widget.mode) {
      case ScannerMode.receiveStock:
        return 'Receive Stock';
      case ScannerMode.removeStock:
        return 'Remove Stock';
      case ScannerMode.normal:
        return 'Scan Barcode';
    }
  }

  Widget _buildBody() {
    if (_isInitializing) {
      return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            CircularProgressIndicator(color: Colors.blue),
            SizedBox(height: 16),
            Text(
              'Initializing camera...',
              style: TextStyle(fontSize: 16, color: Colors.white),
            ),
          ],
        ),
      );
    }

    if (_errorMessage != null) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(
                Icons.camera_alt_outlined,
                size: 64,
                color: Colors.white54,
              ),
              const SizedBox(height: 16),
              Text(
                _errorMessage!,
                textAlign: TextAlign.center,
                style: const TextStyle(fontSize: 16, color: Colors.white),
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                ),
                onPressed: () {
                  if (_errorMessage!.contains('permanently denied')) {
                    openAppSettings();
                  } else {
                    if (mounted) {
                      setState(() {
                        _errorMessage = null;
                        _isInitializing = true;
                      });
                    }
                    _initializeCamera();
                  }
                },
                child: Text(
                  _errorMessage!.contains('permanently denied')
                      ? 'Open Settings'
                      : 'Retry',
                ),
              ),
            ],
          ),
        ),
      );
    }

    if (!_hasPermission) {
      return const Center(
        child: Text(
          'Camera permission not granted',
          style: TextStyle(fontSize: 16, color: Colors.white),
        ),
      );
    }

    return Stack(
      children: [
        ClipRect(
          child: MobileScanner(
            controller: cameraController,
            onDetect: _onBarcodeDetected,
            errorBuilder: (context, error) {
              return Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(
                      Icons.error_outline,
                      size: 64,
                      color: Colors.red,
                    ),
                    const SizedBox(height: 16),
                    Text(
                      'Camera Error: ${error.errorDetails?.message ?? 'Unknown error'}',
                      textAlign: TextAlign.center,
                      style: const TextStyle(fontSize: 16, color: Colors.white),
                    ),
                    const SizedBox(height: 20),
                    ElevatedButton(
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.red,
                        foregroundColor: Colors.white,
                      ),
                      onPressed: () {
                        if (mounted) {
                          setState(() {
                            _isInitializing = true;
                          });
                        }
                        _initializeCamera();
                      },
                      child: const Text('Retry'),
                    ),
                  ],
                ),
              );
            },
          ),
        ),
        Container(
          decoration: ShapeDecoration(
            shape: ModernScannerOverlay(
              borderColor: _getBorderColor(),
              borderWidth: 3.0,
              overlayColor: Colors.black.withValues(alpha: 0.3),
              borderRadius: 16,
              borderLength: 40,
              cutOutSize: 280,
            ),
          ),
        ),
        Positioned(
          bottom: 120,
          left: 20,
          right: 20,
          child: Container(
            padding: const EdgeInsets.all(20),
            decoration: BoxDecoration(
              color: Colors.black.withValues(alpha: .8),
              borderRadius: BorderRadius.circular(16),
              border: Border.all(
                color: _getBorderColor().withValues(alpha: 0.3),
              ),
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(_getModeIcon(), color: _getBorderColor(), size: 24),
                    const SizedBox(width: 8),
                    Text(
                      _getModeTitle(),
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 16,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                Text(
                  _getModeDescription(),
                  style: const TextStyle(color: Colors.white70, fontSize: 14),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
        ),
        if (_isProcessing)
          Container(
            color: Colors.black.withValues(alpha: 0.7),
            child: Center(
              child: Container(
                padding: const EdgeInsets.all(24),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(16),
                ),
                child: const Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    CircularProgressIndicator(color: Colors.blue),
                    SizedBox(height: 16),
                    Text(
                      'Processing barcode...',
                      style: TextStyle(
                        color: Colors.black87,
                        fontSize: 16,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
      ],
    );
  }

  Color _getBorderColor() {
    switch (widget.mode) {
      case ScannerMode.receiveStock:
        return Colors.green;
      case ScannerMode.removeStock:
        return Colors.red;
      case ScannerMode.normal:
        return Colors.blue;
    }
  }

  IconData _getModeIcon() {
    switch (widget.mode) {
      case ScannerMode.receiveStock:
        return Icons.add_box;
      case ScannerMode.removeStock:
        return Icons.remove_circle;
      case ScannerMode.normal:
        return Icons.qr_code_scanner;
    }
  }

  String _getModeTitle() {
    switch (widget.mode) {
      case ScannerMode.receiveStock:
        return 'Scan to Receive Stock';
      case ScannerMode.removeStock:
        return 'Scan to Remove Stock';
      case ScannerMode.normal:
        return 'Position barcode in the frame';
    }
  }

  String _getModeDescription() {
    switch (widget.mode) {
      case ScannerMode.receiveStock:
        return 'Scan products to add them to inventory';
      case ScannerMode.removeStock:
        return 'Scan products to remove from inventory';
      case ScannerMode.normal:
        return 'Camera will automatically scan when detected';
    }
  }

  void _onBarcodeDetected(BarcodeCapture capture) async {
    if (_isProcessing) return;

    final List<Barcode> barcodes = capture.barcodes;
    if (barcodes.isEmpty) return;

    final barcode = barcodes.first;
    if (barcode.rawValue == null) return;

    setState(() {
      _isProcessing = true;
    });

    try {
      await _handleBarcodeScanned(barcode.rawValue!);
    } finally {
      if (mounted) {
        setState(() {
          _isProcessing = false;
        });
      }
    }
  }

  Future<void> _handleBarcodeScanned(String barcodeValue) async {
    final inventoryProvider = Provider.of<InventoryProvider>(
      context,
      listen: false,
    );
    final salesProvider = Provider.of<SalesProvider>(context, listen: false);

    log('BarcodeScannerWidget: Scanned barcodeValue: $barcodeValue');
    log('BarcodeScannerWidget: Products in inventory:');
    for (var p in inventoryProvider.products) {
      log('  - Product ID: ${p.id}, Barcode: ${p.barcode}, Name: ${p.name}');
    }

    final existingProduct = inventoryProvider.products
        .where((product) => product.barcode == barcodeValue)
        .firstOrNull;

    if (existingProduct != null) {
      switch (widget.mode) {
        case ScannerMode.receiveStock:
          await _handleReceiveStock(existingProduct);
          break;
        case ScannerMode.removeStock:
          await _handleRemoveStock(existingProduct);
          break;
        case ScannerMode.normal:
          await _handleExistingProduct(existingProduct, salesProvider);
          break;
      }
    } else {
      await _handleNewProduct(barcodeValue);
    }
  }

  Future<void> _handleReceiveStock(Product product) async {
    await cameraController.stop();
    if (!mounted) return;

    final result = await showDialog<bool>(
      context: context,
      builder: (context) => ReceiveStockDialog(product: product),
    );

    if (result == true) {
      if (mounted) {
        Navigator.pop(context);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Stock received for ${product.name}'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } else {
      await cameraController.start();
    }
  }

  Future<void> _handleRemoveStock(Product product) async {
    await cameraController.stop();
    if (!mounted) return;

    if (product.stock <= 0) {
      await showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Out of Stock'),
          content: Text('There is no more stock for ${product.name}.'),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('OK'),
            ),
          ],
        ),
      );
      await cameraController.start();

      return;
    }

    final result = await _showRemoveStockDialog(
      context: context,
      product: product,
    );

    if (result != null && result.quantity > 0) {
      if (!mounted) return;
      final inventoryProvider = Provider.of<InventoryProvider>(
        context,
        listen: false,
      );

      bool success = false;

      // If the reason is "Damage", use addLoss to properly record the loss
      if (result.reason == 'Damage') {
        success = await inventoryProvider.addLoss(
          productId: product.id!,
          quantity: result.quantity,
          reason: LossReason.damaged,
        );
      } else {
        // For other reasons like "Miss stock", just reduce stock
        success = await inventoryProvider.reduceStock(
          product.id!,
          result.quantity,
          reason: result.reason,
        );
      }

      if (mounted) {
        if (success) {
          Navigator.pop(context);
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                'Removed ${result.quantity} units of ${product.name}',
              ),
              backgroundColor: Colors.orange,
            ),
          );
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Insufficient stock to remove'),
              backgroundColor: Colors.red,
            ),
          );
          await cameraController.start();
        }
      }
    } else {
      await cameraController.start();
    }
  }

  Future<StockUpdateResult?> _showRemoveStockDialog({
    required BuildContext context,
    required Product product,
  }) async {
    final quantityController = TextEditingController(text: '1');
    String reason = 'Damage'; // Default reason
    String? errorMessage;

    return await showDialog<StockUpdateResult>(
      context: context,
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setState) {
            return AlertDialog(
              title: Text('Remove Stock: ${product.name}'),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text('Current Stock: ${product.stock}'),
                  const SizedBox(height: 16),
                  TextField(
                    controller: quantityController,
                    keyboardType: TextInputType.number,
                    decoration: const InputDecoration(
                      labelText: 'Quantity to Remove',
                      border: OutlineInputBorder(),
                    ),
                    autofocus: true,
                    onChanged: (value) {
                      // Clear error message when user types
                      if (errorMessage != null) {
                        setState(() {
                          errorMessage = null;
                        });
                      }
                    },
                  ),
                  if (errorMessage != null) ...[
                    const SizedBox(height: 8),
                    Text(
                      errorMessage!,
                      style: const TextStyle(color: Colors.red, fontSize: 12),
                    ),
                  ],
                  const SizedBox(height: 16),
                  DropdownButtonFormField<String>(
                    initialValue: reason,
                    decoration: const InputDecoration(
                      labelText: 'Reason for Removal',
                      border: OutlineInputBorder(),
                    ),
                    items: ['Damage', 'Miss stock']
                        .map(
                          (label) => DropdownMenuItem(
                            value: label,
                            child: Text(label),
                          ),
                        )
                        .toList(),
                    onChanged: (value) {
                      if (value != null) {
                        setState(() {
                          reason = value;
                        });
                      }
                    },
                  ),
                ],
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text('Cancel'),
                ),
                ElevatedButton(
                  onPressed: () {
                    final qty = int.tryParse(quantityController.text);

                    if (qty == null || qty <= 0) {
                      setState(() {
                        errorMessage = 'Please enter a valid quantity';
                      });
                      return;
                    }

                    if (qty > product.stock) {
                      setState(() {
                        errorMessage =
                            'Cannot remove $qty units. Only ${product.stock} units available';
                      });
                      return;
                    }

                    // Show confirmation dialog
                    _showConfirmationDialog(
                      context: context,
                      product: product,
                      quantity: qty,
                      reason: reason,
                    );
                  },
                  style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
                  child: const Text('Remove'),
                ),
              ],
            );
          },
        );
      },
    );
  }

  Future<void> _showConfirmationDialog({
    required BuildContext context,
    required Product product,
    required int quantity,
    required String reason,
  }) async {
    final navigator = Navigator.of(context);
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Confirm Stock Removal'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Product: ${product.name}'),
            const SizedBox(height: 8),
            Text('Quantity to remove: $quantity'),
            const SizedBox(height: 8),
            Text('Reason: $reason'),
            const SizedBox(height: 8),
            Text('Remaining stock: ${product.stock - quantity}'),
            const SizedBox(height: 16),
            const Text(
              'Are you sure you want to remove this stock?',
              style: TextStyle(fontWeight: FontWeight.bold),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
            child: const Text('Confirm Remove'),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      if (!navigator.mounted) return;
      navigator.pop(StockUpdateResult(quantity: quantity, reason: reason));
    }
  }

  Future<void> _handleExistingProduct(
    Product product,
    SalesProvider salesProvider,
  ) async {
    await cameraController.stop();

    if (!mounted) return;

    final action = await showDialog<String>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Product Found: ${product.name}'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            FutureBuilder<double>(
              future: TaxService.calculateSellingPriceWithRule(
                product.cost,
                productId: product.id,
                categoryName: product.category,
              ),
              builder: (context, snapshot) {
                if (snapshot.hasData) {
                  return Text('Price: ₱${snapshot.data!.toStringAsFixed(2)}');
                }
                return const Text('Price: Calculating...');
              },
            ),
            Text('Stock: ${product.stock} available'),
            if (product.isLowStock)
              const Text(
                'Low Stock!',
                style: TextStyle(
                  color: Colors.red,
                  fontWeight: FontWeight.bold,
                ),
              ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, 'cancel'),
            child: const Text('Cancel'),
          ),
          if (product.stock > 0)
            ElevatedButton(
              onPressed: () => Navigator.pop(context, 'add_to_cart'),
              child: const Text('Add to Cart'),
            ),
          TextButton(
            onPressed: () => Navigator.pop(context, 'view_details'),
            child: const Text('View Details'),
          ),
        ],
      ),
    );

    if (action == 'add_to_cart' && product.stock > 0) {
      await salesProvider.addItemToCurrentSale(product, 1);
      if (mounted) {
        Navigator.pop(context);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('${product.name} added to cart'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } else if (action == 'view_details') {
      if (mounted) {
        showDialog(
          context: context,
          builder: (context) => AddProductDialog(product: product),
        );
      }
    } else {
      await cameraController.start();
    }
  }

  Future<void> _handleNewProduct(String barcodeValue) async {
    await cameraController.stop();

    if (!mounted) return;

    final result = await showDialog<bool>(
      context: context,
      builder: (context) => BarcodeProductDialog(barcode: barcodeValue),
    );

    if (result == true) {
      if (mounted) {
        // Show success overlay before closing
        _showSuccessOverlay();

        // Close scanner after showing success
        Future.delayed(const Duration(seconds: 2), () {
          if (mounted) {
            Navigator.pop(context);
          }
        });
      } else {
        await cameraController.start();
      }
    }
  }

  void _showSuccessOverlay() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => Dialog(
        backgroundColor: Colors.transparent,
        child: Container(
          padding: const EdgeInsets.all(24),
          decoration: BoxDecoration(
            color: Colors.green,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(Icons.check_circle, color: Colors.white, size: 48),
              const SizedBox(height: 16),
              const Text(
                'Product Added!',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 8),
              const Text(
                'Successfully added to inventory',
                style: TextStyle(color: Colors.white70, fontSize: 14),
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ),
    );

    // Auto-close the success overlay
    Future.delayed(const Duration(seconds: 2), () {
      if (mounted) {
        Navigator.pop(context);
      }
    });
  }

  @override
  void dispose() {
    try {
      cameraController.dispose();
    } catch (e, s) {
      ErrorLogger.logError(
        'Error disposing camera controller',
        error: e,
        stackTrace: s,
      );
      // Handle disposal error silently
    }
    super.dispose();
  }
}

class ModernScannerOverlay extends ShapeBorder {
  const ModernScannerOverlay({
    this.borderColor = Colors.blue,
    this.borderWidth = 3.0,
    this.overlayColor = const Color.fromRGBO(0, 0, 0, 30),
    this.borderRadius = 16,
    this.borderLength = 40,
    this.cutOutSize = 280,
  });

  final Color borderColor;
  final double borderWidth;
  final Color overlayColor;
  final double borderRadius;
  final double borderLength;
  final double cutOutSize;

  @override
  EdgeInsetsGeometry get dimensions => const EdgeInsets.all(10);

  @override
  Path getInnerPath(Rect rect, {TextDirection? textDirection}) {
    return Path()
      ..fillType = PathFillType.evenOdd
      ..addPath(getOuterPath(rect), Offset.zero);
  }

  @override
  Path getOuterPath(Rect rect, {TextDirection? textDirection}) {
    Path getLeftTopPath(Rect rect) {
      return Path()
        ..moveTo(rect.left, rect.bottom)
        ..lineTo(rect.left, rect.top + borderRadius)
        ..quadraticBezierTo(
          rect.left,
          rect.top,
          rect.left + borderRadius,
          rect.top,
        )
        ..lineTo(rect.right, rect.top);
    }

    return getLeftTopPath(rect)
      ..lineTo(rect.right, rect.bottom)
      ..lineTo(rect.left, rect.bottom)
      ..lineTo(rect.left, rect.top);
  }

  @override
  void paint(Canvas canvas, Rect rect, {TextDirection? textDirection}) {
    final width = rect.width;
    final height = rect.height;
    final cutOutWidth = cutOutSize < width ? cutOutSize : width - borderWidth;
    final cutOutHeight = cutOutSize < height
        ? cutOutSize
        : height - borderWidth;

    final backgroundPaint = Paint()
      ..color = overlayColor
      ..style = PaintingStyle.fill;

    final cutOutRect = Rect.fromLTWH(
      rect.left + (width - cutOutWidth) / 2 + borderWidth,
      rect.top + (height - cutOutHeight) / 2 + borderWidth,
      cutOutWidth - borderWidth * 2,
      cutOutHeight - borderWidth * 2,
    );

    canvas
      ..saveLayer(rect, backgroundPaint)
      ..drawRect(rect, backgroundPaint)
      ..drawRRect(
        RRect.fromRectAndRadius(cutOutRect, Radius.circular(borderRadius)),
        Paint()..blendMode = BlendMode.clear,
      )
      ..restore();

    final borderPaint = Paint()
      ..color = borderColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = borderWidth
      ..strokeCap = StrokeCap.round;

    final glowPaint = Paint()
      ..color = borderColor.withValues(alpha: 0.3)
      ..style = PaintingStyle.stroke
      ..strokeWidth = borderWidth * 2
      ..strokeCap = StrokeCap.round;

    final glowPath = Path()
      ..moveTo(cutOutRect.left - borderLength, cutOutRect.top)
      ..lineTo(cutOutRect.left, cutOutRect.top)
      ..lineTo(cutOutRect.left, cutOutRect.top + borderLength)
      ..moveTo(cutOutRect.right + borderLength, cutOutRect.top)
      ..lineTo(cutOutRect.right, cutOutRect.top)
      ..lineTo(cutOutRect.right, cutOutRect.top + borderLength)
      ..moveTo(cutOutRect.left - borderLength, cutOutRect.bottom)
      ..lineTo(cutOutRect.left, cutOutRect.bottom)
      ..lineTo(cutOutRect.left, cutOutRect.bottom - borderLength)
      ..moveTo(cutOutRect.right + borderLength, cutOutRect.bottom)
      ..lineTo(cutOutRect.right, cutOutRect.bottom)
      ..lineTo(cutOutRect.right, cutOutRect.bottom - borderLength);

    canvas.drawPath(glowPath, glowPaint);

    final borderPath = Path()
      ..moveTo(cutOutRect.left - borderLength, cutOutRect.top)
      ..lineTo(cutOutRect.left, cutOutRect.top)
      ..lineTo(cutOutRect.left, cutOutRect.top + borderLength)
      ..moveTo(cutOutRect.right + borderLength, cutOutRect.top)
      ..lineTo(cutOutRect.right, cutOutRect.top)
      ..lineTo(cutOutRect.right, cutOutRect.top + borderLength)
      ..moveTo(cutOutRect.left - borderLength, cutOutRect.bottom)
      ..lineTo(cutOutRect.left, cutOutRect.bottom)
      ..lineTo(cutOutRect.left, cutOutRect.bottom - borderLength)
      ..moveTo(cutOutRect.right + borderLength, cutOutRect.bottom)
      ..lineTo(cutOutRect.right, cutOutRect.bottom)
      ..lineTo(cutOutRect.right, cutOutRect.bottom - borderLength);

    canvas.drawPath(borderPath, borderPaint);
  }

  @override
  ShapeBorder scale(double t) {
    return ModernScannerOverlay(
      borderColor: borderColor,
      borderWidth: borderWidth,
      overlayColor: overlayColor,
      borderRadius: borderRadius,
      borderLength: borderLength,
      cutOutSize: cutOutSize,
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\batch_list_widget.dart
â•‘ SIZE: 7.25 KB
â•‘ MODIFIED: 10/25/2025 14:36:00
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:prostock/models/inventory_batch.dart';

class BatchListWidget extends StatelessWidget {
  final List<InventoryBatch> batches;
  final bool showDepleted;

  const BatchListWidget({
    super.key,
    required this.batches,
    this.showDepleted = false,
  });

  @override
  Widget build(BuildContext context) {
    final displayBatches = showDepleted
        ? batches
        : batches.where((b) => b.hasStock).toList();

    if (displayBatches.isEmpty) {
      return const Card(
        child: Padding(
          padding: EdgeInsets.all(16.0),
          child: Center(
            child: Text(
              'No batches available',
              style: TextStyle(
                fontSize: 14,
                color: Colors.grey,
                fontStyle: FontStyle.italic,
              ),
            ),
          ),
        ),
      );
    }

    return ListView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      itemCount: displayBatches.length,
      itemBuilder: (context, index) {
        final batch = displayBatches[index];
        final isOldest = index == 0 && batch.hasStock;

        return Card(
          elevation: isOldest ? 3 : 1,
          margin: const EdgeInsets.symmetric(vertical: 4, horizontal: 8),
          color: batch.isDepleted
              ? Colors.grey.shade100
              : (isOldest ? Colors.blue.shade50 : null),
          child: ListTile(
            leading: CircleAvatar(
              backgroundColor: batch.isDepleted
                  ? Colors.grey
                  : (isOldest ? Colors.blue : Colors.green),
              child: Text(
                '${index + 1}',
                style: const TextStyle(color: Colors.white),
              ),
            ),
            title: Row(
              children: [
                Expanded(
                  child: Text(
                    batch.batchNumber,
                    style: TextStyle(
                      fontWeight: isOldest
                          ? FontWeight.bold
                          : FontWeight.normal,
                      decoration: batch.isDepleted
                          ? TextDecoration.lineThrough
                          : null,
                    ),
                  ),
                ),
                if (isOldest && !batch.isDepleted)
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 2,
                    ),
                    decoration: BoxDecoration(
                      color: Colors.blue,
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: const Text(
                      'FIFO NEXT',
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 10,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                if (batch.isDepleted)
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 2,
                    ),
                    decoration: BoxDecoration(
                      color: Colors.grey,
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: const Text(
                      'DEPLETED',
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 10,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
              ],
            ),
            subtitle: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const SizedBox(height: 4),
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        'Received: ${DateFormat('MMM d, y').format(batch.dateReceived)}',
                        style: const TextStyle(fontSize: 12),
                      ),
                    ),
                    Text(
                      'Cost: ₱${batch.unitCost.toStringAsFixed(2)}',
                      style: const TextStyle(
                        fontSize: 12,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 4),
                Row(
                  children: [
                    Expanded(
                      child: LinearProgressIndicator(
                        value: batch.quantityReceived > 0
                            ? batch.quantitySold / batch.quantityReceived
                            : 0,
                        backgroundColor: Colors.grey.shade300,
                        valueColor: AlwaysStoppedAnimation<Color>(
                          batch.isDepleted
                              ? Colors.grey
                              : (batch.percentageSold > 75
                                    ? Colors.orange
                                    : Colors.green),
                        ),
                      ),
                    ),
                    const SizedBox(width: 8),
                    Text(
                      '${batch.quantityRemaining}/${batch.quantityReceived}',
                      style: const TextStyle(
                        fontSize: 11,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 2),
                Text(
                  'Sold: ${batch.quantitySold} (${batch.percentageSold.toStringAsFixed(0)}%)',
                  style: const TextStyle(fontSize: 11, color: Colors.grey),
                ),
                if (batch.notes != null && batch.notes!.isNotEmpty)
                  Padding(
                    padding: const EdgeInsets.only(top: 4),
                    child: Text(
                      batch.notes!,
                      style: const TextStyle(
                        fontSize: 10,
                        fontStyle: FontStyle.italic,
                        color: Colors.grey,
                      ),
                    ),
                  ),
              ],
            ),
            trailing: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  '₱${batch.totalValue.toStringAsFixed(2)}',
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 14,
                  ),
                ),
                const Text(
                  'Total Value',
                  style: TextStyle(fontSize: 10, color: Colors.grey),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\confirmation_dialog.dart
â•‘ SIZE: 1.51 KB
â•‘ MODIFIED: 09/05/2025 18:55:47
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


import 'package:flutter/material.dart';

class ConfirmationDialog extends StatelessWidget {
  final String title;
  final String content;
  final VoidCallback onConfirm;
  final String confirmText;
  final String cancelText;

  const ConfirmationDialog({
    super.key,
    required this.title,
    required this.content,
    required this.onConfirm,
    this.confirmText = 'Confirm',
    this.cancelText = 'Cancel',
  });

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(title),
      content: Text(content),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(false),
          child: Text(cancelText),
        ),
        ElevatedButton(
          onPressed: () {
            onConfirm();
            Navigator.of(context).pop(true);
          },
          child: Text(confirmText),
        ),
      ],
    );
  }
}

Future<bool?> showConfirmationDialog({
  required BuildContext context,
  required String title,
  required String content,
  String confirmText = 'Confirm',
  String cancelText = 'Cancel',
}) {
  return showDialog<bool>(
    context: context,
    builder: (context) => AlertDialog(
      title: Text(title),
      content: Text(content),
      actions: <Widget>[
        TextButton(
          onPressed: () => Navigator.of(context).pop(false),
          child: Text(cancelText),
        ),
        ElevatedButton(
          onPressed: () => Navigator.of(context).pop(true),
          child: Text(confirmText),
        ),
      ],
    ),
  );
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\connectivity_status.dart
â•‘ SIZE: 0.7 KB
â•‘ MODIFIED: 10/02/2025 13:10:37
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/services/offline_manager.dart';

class ConnectivityStatus extends StatelessWidget {
  const ConnectivityStatus({super.key});

  @override
  Widget build(BuildContext context) {
    final offlineManager = Provider.of<OfflineManager>(context);

    return Container(
      width: double.infinity,
      color: offlineManager.isOnline ? Colors.green : Colors.red,
      padding: const EdgeInsets.all(8.0),
      child: Text(
        offlineManager.isOnline ? 'Online' : 'Offline',
        textAlign: TextAlign.center,
        style: TextStyle(color: Theme.of(context).colorScheme.onError),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\dashboard_card.dart
â•‘ SIZE: 2.69 KB
â•‘ MODIFIED: 08/17/2025 13:11:54
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import '../utils/currency_utils.dart';

class DashboardCard extends StatelessWidget {
  final String title;
  final String value;
  final IconData icon;
  final Color color;
  final bool isCurrency;

  const DashboardCard({
    super.key,
    required this.title,
    required this.value,
    required this.icon,
    required this.color,
    this.isCurrency = false, // Default to false for count values
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 4,
      child: Padding(
        padding: const EdgeInsets.all(
          12,
        ), // Reduced padding to prevent overflow
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisAlignment:
              MainAxisAlignment.spaceBetween, // Better space distribution
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Icon(
                  icon,
                  color: color,
                  size: 28, // Reduced icon size to prevent overflow
                ),
                Flexible(
                  // Added Flexible to prevent text overflow
                  child: Text(
                    _formatDisplayValue(value),
                    style: TextStyle(
                      fontSize: 20, // Reduced font size to prevent overflow
                      fontWeight: FontWeight.bold,
                      color: color,
                    ),
                    overflow: TextOverflow.ellipsis, // Handle text overflow
                  ),
                ),
              ],
            ),
            const SizedBox(height: 4), // Reduced spacing
            Text(
              title,
              style: const TextStyle(
                fontSize: 12, // Reduced font size
                color: Colors.grey,
              ),
              overflow: TextOverflow.ellipsis, // Handle text overflow
              maxLines: 2, // Allow title to wrap to 2 lines if needed
            ),
          ],
        ),
      ),
    );
  }

  String _formatDisplayValue(String value) {
    if (isCurrency) {
      // If the value already contains currency symbol, validate it
      if (value.contains('₱') || value.contains('\$')) {
        // Replace any $ symbols with ₱ symbols
        return value.replaceAll('\$', '₱');
      }

      // If it's a pure number, try to parse and format it as currency
      final numericValue = double.tryParse(value);
      if (numericValue != null) {
        return CurrencyUtils.formatCurrency(numericValue);
      }
    }

    // For non-currency values, just return the value as-is (whole numbers)
    return value;
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\delete_confirmation_dialog.dart
â•‘ SIZE: 4.26 KB
â•‘ MODIFIED: 09/19/2025 12:47:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';

class DeleteConfirmationDialog extends StatelessWidget {
  final String title;
  final String message;
  final String? itemName;
  final VoidCallback onConfirm;
  final VoidCallback? onCancel;

  const DeleteConfirmationDialog({
    super.key,
    required this.title,
    required this.message,
    this.itemName,
    required this.onConfirm,
    this.onCancel,
  });

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Row(
        children: [
          Icon(
            Icons.warning_amber_rounded,
            color: Colors.orange[600],
            size: 28,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              title,
              style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
          ),
        ],
      ),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(message, style: const TextStyle(fontSize: 16)),
          if (itemName != null) ...[
            const SizedBox(height: 12),
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.grey[100],
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.grey[300]!),
              ),
              child: Row(
                children: [
                  Icon(Icons.info_outline, color: Colors.blue[600], size: 20),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'Item: $itemName',
                      style: TextStyle(
                        fontSize: 14,
                        fontWeight: FontWeight.w500,
                        color: Colors.grey[700],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
          const SizedBox(height: 16),
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: Colors.red[50],
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: Colors.red[200]!),
            ),
            child: Row(
              children: [
                Icon(Icons.error_outline, color: Colors.red[600], size: 20),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    'This action cannot be undone.',
                    style: TextStyle(
                      fontSize: 14,
                      fontWeight: FontWeight.w500,
                      color: Colors.red[700],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: onCancel ?? () => Navigator.of(context).pop(),
          child: const Text(
            'Cancel',
            style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
          ),
        ),
        ElevatedButton(
          onPressed: () {
            Navigator.of(context).pop();
            onConfirm();
          },
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.red[600],
            foregroundColor: Colors.white,
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          ),
          child: const Text(
            'Delete',
            style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
          ),
        ),
      ],
    );
  }

  static Future<bool?> show({
    required BuildContext context,
    required String title,
    required String message,
    String? itemName,
    required VoidCallback onConfirm,
    VoidCallback? onCancel,
  }) {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => DeleteConfirmationDialog(
        title: title,
        message: message,
        itemName: itemName,
        onConfirm: onConfirm,
        onCancel: onCancel,
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\dialog_helpers.dart
â•‘ SIZE: 0.6 KB
â•‘ MODIFIED: 09/19/2025 12:47:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/models/customer.dart';
import 'package:prostock/widgets/manage_balance_dialog.dart';

class DialogHelpers {
  static Future<bool?> showManageBalanceDialog({
    required BuildContext context,
    required Customer customer,
    required Function(String customerId, double amount) onUpdateBalance,
  }) {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => ManageBalanceDialog(
        customer: customer,
        onUpdateBalance: onUpdateBalance,
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\enhanced_text_field.dart
â•‘ SIZE: 4.49 KB
â•‘ MODIFIED: 10/02/2025 17:06:21
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';

class EnhancedTextField extends StatefulWidget {
  final TextEditingController controller;
  final String labelText;
  final IconData prefixIcon;
  final bool isPassword;
  final String? Function(String?)? validator;
  final void Function(String)? onChanged;
  final String? errorText;
  final String? helperText;
  final bool showValidationIcon;
  final TextInputType? keyboardType;
  final bool enabled;

  const EnhancedTextField({
    super.key,
    required this.controller,
    required this.labelText,
    required this.prefixIcon,
    this.isPassword = false,
    this.validator,
    this.onChanged,
    this.errorText,
    this.helperText,
    this.showValidationIcon = true,
    this.keyboardType,
    this.enabled = true,
  });

  @override
  State<EnhancedTextField> createState() => _EnhancedTextFieldState();
}

class _EnhancedTextFieldState extends State<EnhancedTextField> {
  bool _isPasswordVisible = false;
  bool _isValid = false;
  bool _hasBeenTouched = false;

  @override
  void initState() {
    super.initState();
    widget.controller.addListener(_onTextChanged);
  }

  @override
  void dispose() {
    widget.controller.removeListener(_onTextChanged);
    super.dispose();
  }

  void _onTextChanged() {
    if (!_hasBeenTouched && widget.controller.text.isNotEmpty) {
      setState(() {
        _hasBeenTouched = true;
      });
    }

    if (widget.validator != null) {
      final validationResult = widget.validator!(widget.controller.text);
      setState(() {
        _isValid =
            validationResult == null && widget.controller.text.isNotEmpty;
      });
    }

    if (widget.onChanged != null) {
      widget.onChanged!(widget.controller.text);
    }
  }

  @override
  Widget build(BuildContext context) {
    return TextFormField(
      controller: widget.controller,
      obscureText: widget.isPassword && !_isPasswordVisible,
      keyboardType: widget.keyboardType,
      enabled: widget.enabled,
      decoration: InputDecoration(
        labelText: widget.labelText,
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(
            color: _hasBeenTouched
                ? (_isValid ? Colors.green : Colors.grey)
                : Colors.grey,
          ),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(
            color: _hasBeenTouched
                ? (_isValid ? Colors.green : Theme.of(context).primaryColor)
                : Theme.of(context).primaryColor,
            width: 2,
          ),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Colors.red, width: 2),
        ),
        focusedErrorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Colors.red, width: 2),
        ),
        prefixIcon: Icon(
          widget.prefixIcon,
          color: _hasBeenTouched
              ? (_isValid ? Colors.green : Colors.grey)
              : Colors.grey,
        ),
        suffixIcon: _buildSuffixIcon(),
        filled: true,
        fillColor: Theme.of(context).colorScheme.surface,
        errorText: widget.errorText,
        helperText: widget.helperText,
        helperMaxLines: 3,
      ),
      validator: widget.validator,
      onChanged: (value) {
        if (!_hasBeenTouched) {
          setState(() {
            _hasBeenTouched = true;
          });
        }
        if (widget.onChanged != null) {
          widget.onChanged!(value);
        }
      },
    );
  }

  Widget? _buildSuffixIcon() {
    if (widget.isPassword) {
      return IconButton(
        icon: Icon(
          _isPasswordVisible ? Icons.visibility : Icons.visibility_off,
          color: Colors.grey,
        ),
        onPressed: () {
          setState(() {
            _isPasswordVisible = !_isPasswordVisible;
          });
        },
      );
    }

    if (widget.showValidationIcon &&
        _hasBeenTouched &&
        widget.controller.text.isNotEmpty) {
      return Icon(
        _isValid ? Icons.check_circle : Icons.error,
        color: _isValid ? Colors.green : Colors.red,
      );
    }

    return null;
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\export_filter_dialog.dart
â•‘ SIZE: 6.38 KB
â•‘ MODIFIED: 10/21/2025 09:01:39
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';

class ExportFilterOptions {
  bool useDataRangeFilter;
  bool limitItemCount;
  int maxItemCount;
  bool summaryOnly;
  DateTime? startDate;
  DateTime? endDate;

  ExportFilterOptions({
    this.useDataRangeFilter = false,
    this.limitItemCount = true,
    this.maxItemCount = 100,
    this.summaryOnly = false,
    this.startDate,
    this.endDate,
  });
}

class ExportFilterDialog extends StatefulWidget {
  final ExportFilterOptions initialOptions;
  final Function(ExportFilterOptions) onApply;

  const ExportFilterDialog({
    super.key,
    required this.initialOptions,
    required this.onApply,
  });

  @override
  State<ExportFilterDialog> createState() => _ExportFilterDialogState();
}

class _ExportFilterDialogState extends State<ExportFilterDialog> {
  late ExportFilterOptions options;

  @override
  void initState() {
    super.initState();
    options = ExportFilterOptions(
      useDataRangeFilter: widget.initialOptions.useDataRangeFilter,
      limitItemCount: widget.initialOptions.limitItemCount,
      maxItemCount: widget.initialOptions.maxItemCount,
      summaryOnly: widget.initialOptions.summaryOnly,
      startDate: widget.initialOptions.startDate,
      endDate: widget.initialOptions.endDate,
    );
  }

  Future<void> _selectDateRange(BuildContext context) async {
    final initialDateRange = DateTimeRange(
      start:
          options.startDate ??
          DateTime.now().subtract(const Duration(days: 30)),
      end: options.endDate ?? DateTime.now(),
    );

    final dateRange = await showDateRangePicker(
      context: context,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
      initialDateRange: initialDateRange,
      builder: (context, child) {
        return Theme(
          data: Theme.of(context).copyWith(
            colorScheme: ColorScheme.light(
              primary: Theme.of(context).primaryColor,
              onPrimary: Colors.white,
              surface: Colors.white,
              onSurface: Colors.black87,
            ),
            dialogTheme: DialogThemeData(backgroundColor: Colors.white),
          ),
          child: child!,
        );
      },
    );

    if (dateRange != null) {
      setState(() {
        options.startDate = dateRange.start;
        options.endDate = dateRange.end;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Filter Export Data'),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Date range filter
            CheckboxListTile(
              title: const Text('Filter by date range'),
              subtitle:
                  options.useDataRangeFilter &&
                      options.startDate != null &&
                      options.endDate != null
                  ? Text(
                      '${options.startDate!.toLocal().toString().split(' ')[0]} - ${options.endDate!.toLocal().toString().split(' ')[0]}',
                    )
                  : const Text('Use date range filter'),
              value: options.useDataRangeFilter,
              onChanged: (value) =>
                  setState(() => options.useDataRangeFilter = value!),
            ),

            if (options.useDataRangeFilter)
              Padding(
                padding: const EdgeInsets.only(
                  left: 16,
                  right: 16,
                  top: 0,
                  bottom: 8,
                ),
                child: ElevatedButton.icon(
                  onPressed: () => _selectDateRange(context),
                  icon: const Icon(Icons.calendar_today, size: 16),
                  label: const Text('Select Dates'),
                  style: ElevatedButton.styleFrom(
                    minimumSize: const Size.fromHeight(40),
                  ),
                ),
              ),

            const Divider(),

            // Limit number of items
            CheckboxListTile(
              title: const Text('Limit number of entries'),
              subtitle: options.limitItemCount
                  ? Text('Maximum ${options.maxItemCount} items per section')
                  : const Text(
                      'Include all data (may cause errors if too large)',
                    ),
              value: options.limitItemCount,
              onChanged: (value) =>
                  setState(() => options.limitItemCount = value!),
            ),

            if (options.limitItemCount)
              Padding(
                padding: const EdgeInsets.only(
                  left: 16,
                  right: 16,
                  top: 0,
                  bottom: 8,
                ),
                child: DropdownButtonFormField<int>(
                  decoration: const InputDecoration(
                    labelText: 'Maximum items',
                    border: OutlineInputBorder(),
                  ),
                  initialValue: options.maxItemCount,
                  items: [25, 50, 100, 200, 300]
                      .map(
                        (count) => DropdownMenuItem(
                          value: count,
                          child: Text('$count items'),
                        ),
                      )
                      .toList(),
                  onChanged: (value) =>
                      setState(() => options.maxItemCount = value!),
                ),
              ),

            const Divider(),

            // Show summary only
            CheckboxListTile(
              title: const Text('Summary only'),
              subtitle: const Text(
                'Only include summary data, not detailed records',
              ),
              value: options.summaryOnly,
              onChanged: (value) =>
                  setState(() => options.summaryOnly = value!),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('Cancel'),
        ),
        ElevatedButton(
          onPressed: () {
            Navigator.pop(context, options);
          },
          child: const Text('Apply & Export'),
        ),
      ],
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\filter_toggle_buttons.dart
â•‘ SIZE: 1.2 KB
â•‘ MODIFIED: 09/16/2025 22:27:53
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';

class FilterToggleButtons extends StatelessWidget {
  final String selectedFilter;
  final Function(String) onFilterChanged;
  final Color fillColor;
  final Color color;

  const FilterToggleButtons({
    super.key,
    required this.selectedFilter,
    required this.onFilterChanged,
    required this.fillColor,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: ToggleButtons(
        isSelected: [
          selectedFilter == "Daily",
          selectedFilter == "Weekly",
          selectedFilter == "Monthly",
          selectedFilter == "Yearly",
        ],
        onPressed: (index) {
          final filter = ["Daily", "Weekly", "Monthly", "Yearly"][index];
          onFilterChanged(filter);
        },
        borderRadius: BorderRadius.circular(12),
        selectedColor: Colors.white,
        fillColor: fillColor,
        color: color,
        constraints: const BoxConstraints(
          minHeight: 36,
          minWidth: 70,
        ),
        children: const [
          Text("Daily"),
          Text("Weekly"),
          Text("Monthly"),
          Text("Yearly"),
        ],
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\financial_summary_chart.dart
â•‘ SIZE: 2.28 KB
â•‘ MODIFIED: 09/09/2025 10:27:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';

class FinancialSummaryChart extends StatelessWidget {
  final double totalRevenue;
  final double totalCost;
  final double totalProfit;

  const FinancialSummaryChart({
    super.key,
    required this.totalRevenue,
    required this.totalCost,
    required this.totalProfit,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: 300,
      child: BarChart(
        BarChartData(
          alignment: BarChartAlignment.spaceAround,
          maxY: _calculateMaxY(),
          barTouchData: BarTouchData(
            touchTooltipData: BarTouchTooltipData(
              getTooltipColor: (group) => Colors.blueGrey,
            ),
          ),
          titlesData: const FlTitlesData(
            leftTitles: AxisTitles(
              sideTitles: SideTitles(showTitles: false),
            ),
            topTitles: AxisTitles(
              sideTitles: SideTitles(showTitles: false),
            ),
            bottomTitles: AxisTitles(
              sideTitles: SideTitles(
                showTitles: true,
                reservedSize: 30,
              ),
            ),
          ),
          borderData: FlBorderData(
            show: false,
          ),
          barGroups: _createBarGroups(),
        ),
      ),
    );
  }

  double _calculateMaxY() {
    final values = [totalRevenue, totalCost, totalProfit.abs()];
    values.sort();
    return values.last * 1.2;
  }

  List<BarChartGroupData> _createBarGroups() {
    return [
      BarChartGroupData(
        x: 0,
        barRods: [
          BarChartRodData(
            toY: totalRevenue,
            color: Colors.green,
            width: 22,
          ),
        ],
        showingTooltipIndicators: [0],
      ),
      BarChartGroupData(
        x: 1,
        barRods: [
          BarChartRodData(
            toY: totalCost,
            color: Colors.red,
            width: 22,
          ),
        ],
        showingTooltipIndicators: [0],
      ),
      BarChartGroupData(
        x: 2,
        barRods: [
          BarChartRodData(
            toY: totalProfit,
            color: totalProfit >= 0 ? Colors.blue : Colors.orange,
            width: 22,
          ),
        ],
        showingTooltipIndicators: [0],
      ),
    ];
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\inventory_chart.dart
â•‘ SIZE: 7.83 KB
â•‘ MODIFIED: 10/21/2025 07:26:57
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:provider/provider.dart';
import '../providers/inventory_provider.dart';
import '../utils/currency_utils.dart';
import '../services/tax_service.dart';
import '../models/product.dart';

class InventoryChart extends StatelessWidget {
  const InventoryChart({super.key});

  Future<Map<String, double>> _calculateCategoryData(
    List<Product> products,
  ) async {
    final categoryData = <String, double>{};
    for (final product in products) {
      final category = product.category ?? 'Uncategorized';
      final price = await TaxService.calculateSellingPriceWithRule(
        product.cost,
        productId: product.id,
        categoryName: product.category,
      );
      final value = price * product.stock;
      categoryData[category] = (categoryData[category] ?? 0) + value;
    }
    return categoryData;
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<InventoryProvider>(
      builder: (context, provider, child) {
        if (provider.products.isEmpty) {
          return const Card(
            child: Padding(
              padding: EdgeInsets.all(32),
              child: Center(child: Text('No inventory data available')),
            ),
          );
        }

        return FutureBuilder<Map<String, double>>(
          future: _calculateCategoryData(provider.products),
          builder: (context, snapshot) {
            if (!snapshot.hasData) {
              return const Card(
                child: Padding(
                  padding: EdgeInsets.all(32),
                  child: Center(child: CircularProgressIndicator()),
                ),
              );
            }

            final categoryData = snapshot.data!;

            // Fixed number of distinct colors for better visual separation
            final colors = [
              Colors.red,
              Colors.blue,
              Colors.green,
              Colors.purple,
              Colors.orange,
              Colors.teal,
              Colors.pink,
              Colors.indigo,
              Colors.amber,
              Colors.cyan,
              Colors.deepOrange,
              Colors.lime,
            ];

            // Assign a distinct color to each category
            final categoryColors = <String, Color>{};
            int colorIndex = 0;
            for (final category in categoryData.keys) {
              categoryColors[category] = colors[colorIndex % colors.length];
              colorIndex++;
            }

            final sections = categoryData.entries.map((entry) {
              final total = categoryData.values.fold(
                0.0,
                (sum, value) => sum + value,
              );
              final percentage = total > 0 ? (entry.value / total * 100) : 0;

              return PieChartSectionData(
                color: categoryColors[entry.key]!,
                value: entry.value,
                title: '${percentage.toStringAsFixed(1)}%',
                radius: 55, // Reduced radius to avoid overflow
                titleStyle: const TextStyle(
                  fontSize: 12,
                  fontWeight: FontWeight.bold,
                  color: Colors.white,
                ),
              );
            }).toList();

            return Card(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      'Inventory Value by Category',
                      style: TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8), // Reduced spacing
                    // Container with fixed height to prevent overflow
                    SizedBox(
                      height: 250, // Adjusted height
                      child: Row(
                        children: [
                          Expanded(
                            flex: 3,
                            child: PieChart(
                              PieChartData(
                                sections: sections,
                                centerSpaceRadius: 35, // Reduced center space
                                sectionsSpace:
                                    1, // Smaller space between sections
                              ),
                            ),
                          ),
                          Expanded(
                            flex: 2,
                            child: SizedBox(
                              height: 250, // Match container height
                              child: ListView(
                                shrinkWrap: true,
                                children: categoryData.entries.map((entry) {
                                  return Padding(
                                    padding: const EdgeInsets.symmetric(
                                      vertical: 2,
                                    ),
                                    child: Row(
                                      children: [
                                        Container(
                                          width: 12,
                                          height: 12,
                                          decoration: BoxDecoration(
                                            color: categoryColors[entry.key],
                                            shape: BoxShape.circle,
                                          ),
                                        ),
                                        const SizedBox(width: 4),
                                        Expanded(
                                          child: Column(
                                            crossAxisAlignment:
                                                CrossAxisAlignment.start,
                                            children: [
                                              Text(
                                                entry.key,
                                                style: const TextStyle(
                                                  fontSize:
                                                      10, // Reduced font size
                                                ),
                                                overflow: TextOverflow.ellipsis,
                                              ),
                                              Text(
                                                CurrencyUtils.formatCurrency(
                                                  entry.value,
                                                ),
                                                style: const TextStyle(
                                                  fontSize:
                                                      9, // Reduced font size
                                                  color: Colors.grey,
                                                ),
                                              ),
                                            ],
                                          ),
                                        ),
                                      ],
                                    ),
                                  );
                                }).toList(),
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        );
      },
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\loss_breakdown_list.dart
â•‘ SIZE: 1.18 KB
â•‘ MODIFIED: 09/09/2025 10:19:58
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/utils/currency_utils.dart';

class LossBreakdownList extends StatelessWidget {
  final Map<String, double> lossBreakdown;

  const LossBreakdownList({super.key, required this.lossBreakdown});

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Loss Breakdown',
          style: TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 12),
        ListView.builder(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          itemCount: lossBreakdown.keys.length,
          itemBuilder: (context, index) {
            final reason = lossBreakdown.keys.elementAt(index);
            final totalLoss = lossBreakdown[reason]!;
            return ListTile(
              title: Text(reason),
              trailing: Text(
                CurrencyUtils.formatCurrency(totalLoss),
                style: const TextStyle(color: Colors.red),
              ),
            );
          },
        ),
      ],
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\loss_over_time_chart.dart
â•‘ SIZE: 5.17 KB
â•‘ MODIFIED: 09/17/2025 11:24:55
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:prostock/utils/chart_utils.dart';
import '../models/loss.dart';
import 'filter_toggle_buttons.dart';

class LossOverTimeChart extends StatefulWidget {
  final List<Loss> losses;

  const LossOverTimeChart({super.key, required this.losses});

  @override
  State<LossOverTimeChart> createState() => _LossOverTimeChartState();
}

class _LossOverTimeChartState extends State<LossOverTimeChart> {
  String _selectedFilter = "Daily"; // default

  @override
  Widget build(BuildContext context) {
    return AspectRatio(
      aspectRatio: 1.2,
      child: Card(
        elevation: 6,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              /// Header + Filter
              Column(
                children: [
                  const Text(
                    "Losses Over Time",
                    style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 8),

                  /// Filter Buttons
                  FilterToggleButtons(
                    selectedFilter: _selectedFilter,
                    onFilterChanged: (filter) {
                      setState(() {
                        _selectedFilter = filter;
                      });
                    },
                    fillColor: Colors.red,
                    color: Colors.red,
                  ),
                ],
              ),
              const SizedBox(height: 12),

              /// Chart
              Expanded(child: BarChart(_mainData())),
            ],
          ),
        ),
      ),
    );
  }

  BarChartData _mainData() {
    final barGroups = _getChartGroups();

    return BarChartData(
      barGroups: barGroups,
      gridData: FlGridData(
        show: true,
        drawVerticalLine: true,
        getDrawingHorizontalLine: (value) =>
            FlLine(color: Colors.grey.shade300, strokeWidth: 0.5),
        getDrawingVerticalLine: (value) =>
            FlLine(color: Colors.grey.shade300, strokeWidth: 0.5),
      ),
      titlesData: FlTitlesData(
        show: true,
        rightTitles: const AxisTitles(
          sideTitles: SideTitles(showTitles: false),
        ),
        topTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
        bottomTitles: AxisTitles(
          sideTitles: SideTitles(
            showTitles: true,
            reservedSize: 32,
            interval: 1,
            getTitlesWidget: bottomTitleWidgets,
          ),
        ),
        leftTitles: AxisTitles(
          sideTitles: SideTitles(
            showTitles: true,
            reservedSize: 48,
            getTitlesWidget: leftTitleWidgets,
          ),
        ),
      ),
      borderData: FlBorderData(show: false),
    );
  }

  List<BarChartGroupData> _getChartGroups() {
    if (widget.losses.isEmpty) return [];

    // groupDataByFilter now handles time scoping and merging internally
    final groupedLosses = ChartUtils.groupDataByFilter<Loss>(
      widget.losses,
      _selectedFilter,
      (loss) => loss.timestamp,
      (loss) => loss.totalCost,
    );

    final sortedKeys = groupedLosses.keys.toList()..sort();

    return List.generate(sortedKeys.length, (i) {
      final date = sortedKeys[i];
      final total = groupedLosses[date]!;
      return BarChartGroupData(
        x: i,
        barRods: [
          BarChartRodData(
            toY: total,
            gradient: LinearGradient(
              colors: [Colors.red.shade400, Colors.red.shade800],
              begin: Alignment.bottomCenter,
              end: Alignment.topCenter,
            ),
          ),
        ],
      );
    });
  }

  Widget bottomTitleWidgets(double value, TitleMeta meta) {
    const style = TextStyle(
      color: Color(0xff68737d),
      fontWeight: FontWeight.bold,
      fontSize: 12,
    );

    final groupedKeys = _getSortedKeys();
    if (value.toInt() >= groupedKeys.length) return const SizedBox.shrink();

    final date = groupedKeys[value.toInt()];
    final text = ChartUtils.formatBottomTitle(date, _selectedFilter);

    return SideTitleWidget(
      meta: meta,
      space: 6,
      child: Transform.rotate(
        angle: -0.5, // Tilt text by ~30 degrees
        child: Text(text, style: style),
      ),
    );
  }

  List<DateTime> _getSortedKeys() {
    // groupDataByFilter now handles time scoping and merging internally
    final groupedLosses = ChartUtils.groupDataByFilter<Loss>(
      widget.losses,
      _selectedFilter,
      (loss) => loss.timestamp,
      (loss) => loss.totalCost,
    );

    return groupedLosses.keys.toList()..sort();
  }

  Widget leftTitleWidgets(double value, TitleMeta meta) {
    const style = TextStyle(
      color: Color(0xff67727d),
      fontWeight: FontWeight.bold,
      fontSize: 12,
    );

    String text;
    if (value >= 1000) {
      text = '${(value / 1000).toStringAsFixed(1)}k';
    } else {
      text = value.toStringAsFixed(0);
    }

    return Text(text, style: style, textAlign: TextAlign.left);
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\manage_balance_dialog.dart
â•‘ SIZE: 12.15 KB
â•‘ MODIFIED: 09/29/2025 07:58:51
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:prostock/models/customer.dart';
import 'package:prostock/widgets/confirmation_dialog.dart';

class ManageBalanceDialog extends StatefulWidget {
  final Customer customer;
  final Function(String customerId, double amount) onUpdateBalance;

  const ManageBalanceDialog({
    super.key,
    required this.customer,
    required this.onUpdateBalance,
  });

  @override
  State<ManageBalanceDialog> createState() => _ManageBalanceDialogState();
}

class _ManageBalanceDialogState extends State<ManageBalanceDialog> {
  final _formKey = GlobalKey<FormState>();
  final _amountController = TextEditingController();
  final _notesController = TextEditingController();

  bool _isLoading = false;
  String? _error;
  BalanceOperation _selectedOperation = BalanceOperation.add;

  @override
  void initState() {
    super.initState();
    _amountController.addListener(_validateAmount);
  }

  @override
  void dispose() {
    _amountController.dispose();
    _notesController.dispose();
    super.dispose();
  }

  void _validateAmount() {
    if (_amountController.text.isNotEmpty) {
      final amount = double.tryParse(_amountController.text);
      if (amount != null) {
        final newBalance = _selectedOperation == BalanceOperation.add
            ? widget.customer.balance + amount
            : widget.customer.balance - amount;

        setState(() {
          if (newBalance < 0) {
            _error = 'Balance cannot be negative';
          } else if (newBalance > widget.customer.creditLimit &&
              widget.customer.creditLimit > 0) {
            _error =
                'Balance exceeds credit limit of ${widget.customer.creditLimit}';
          } else {
            _error = null;
          }
        });
      }
    } else {
      setState(() {
        _error = null;
      });
    }
  }

  void _onOperationChanged(BalanceOperation operation) {
    setState(() {
      _selectedOperation = operation;
    });
    _validateAmount();
  }

  Future<void> _submitBalanceUpdate() async {
    if (!_formKey.currentState!.validate()) return;

    final amount = double.tryParse(_amountController.text);
    if (amount == null || amount <= 0) return;

    final actualAmount = _selectedOperation == BalanceOperation.add
        ? amount
        : -amount;

    // Show confirmation dialog
    final confirmed = await showConfirmationDialog(
      context: context,
      title:
          'Confirm Balance ${_selectedOperation == BalanceOperation.add ? 'Addition' : 'Deduction'}',
      content:
          'Are you sure you want to ${_selectedOperation == BalanceOperation.add ? 'add' : 'deduct'} ₱${amount.toStringAsFixed(2)} to/from ${widget.customer.name}\'s balance?\n\n'
          'Current Balance: ₱${widget.customer.balance.toStringAsFixed(2)}\n'
          'New Balance: ₱${_getNewBalance().toStringAsFixed(2)}',
      confirmText: _selectedOperation == BalanceOperation.add
          ? 'Add'
          : 'Deduct',
      cancelText: 'Cancel',
    );

    if (confirmed != true) return;

    setState(() {
      _isLoading = true;
    });

    try {
      await widget.onUpdateBalance(widget.customer.id, actualAmount);
      if (mounted) {
        // Close dialog immediately after successful operation
        Navigator.of(context).pop(true);
        // Show success message after dialog is closed
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              'Balance ${_selectedOperation == BalanceOperation.add ? 'added' : 'deducted'} successfully',
            ),
            backgroundColor: Colors.green[600],
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _error = e.toString();
        });
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Row(
        children: [
          Icon(Icons.account_balance_wallet, color: Colors.blue[600], size: 28),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              'Manage Balance',
              style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
          ),
        ],
      ),
      content: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Customer Info
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.blue[50],
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.blue[200]!),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    widget.customer.name,
                    style: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    'Current Balance: ₱${widget.customer.balance.toStringAsFixed(2)}',
                    style: TextStyle(
                      fontSize: 14,
                      color: widget.customer.balance > 0
                          ? Colors.red[600]
                          : Colors.green[600],
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  if (widget.customer.creditLimit > 0)
                    Text(
                      'Credit Limit: ₱${widget.customer.creditLimit.toStringAsFixed(2)}',
                      style: TextStyle(fontSize: 12, color: Colors.grey[600]),
                    ),
                ],
              ),
            ),

            const SizedBox(height: 20),

            // Operation Type
            Text(
              'Operation Type',
              style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
            ),
            const SizedBox(height: 8),
            SegmentedButton<BalanceOperation>(
              segments: const [
                ButtonSegment<BalanceOperation>(
                  value: BalanceOperation.add,
                  label: Text('Add'),
                  icon: Icon(Icons.add),
                ),
                ButtonSegment<BalanceOperation>(
                  value: BalanceOperation.deduct,
                  label: Text('Deduct'),
                  icon: Icon(Icons.remove),
                ),
              ],
              selected: {_selectedOperation},
              onSelectionChanged: (selection) {
                if (selection.isNotEmpty) {
                  _onOperationChanged(selection.first);
                }
              },
            ),

            const SizedBox(height: 16),

            // Amount Input
            TextFormField(
              controller: _amountController,
              decoration: const InputDecoration(
                labelText: 'Amount',
                prefixText: '₱',
                border: OutlineInputBorder(),
                hintText: '0.00',
              ),
              keyboardType: const TextInputType.numberWithOptions(
                decimal: true,
              ),
              inputFormatters: [
                FilteringTextInputFormatter.allow(RegExp(r'^\d*\.?\d*')),
              ],
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return 'Please enter an amount';
                }
                final amount = double.tryParse(value);
                if (amount == null || amount <= 0) {
                  return 'Please enter a valid amount';
                }
                return null;
              },
            ),

            const SizedBox(height: 16),

            // Notes Input
            TextFormField(
              controller: _notesController,
              decoration: const InputDecoration(
                labelText: 'Notes (Optional)',
                border: OutlineInputBorder(),
                hintText: 'Reason for balance change...',
              ),
              maxLines: 2,
            ),

            // Error Display
            if (_error != null) ...[
              const SizedBox(height: 12),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.red[50],
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.red[200]!),
                ),
                child: Row(
                  children: [
                    Icon(Icons.error_outline, color: Colors.red[600], size: 20),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        _error!,
                        style: TextStyle(color: Colors.red[700], fontSize: 14),
                      ),
                    ),
                  ],
                ),
              ),
            ],

            // Preview
            if (_amountController.text.isNotEmpty && _error == null) ...[
              const SizedBox(height: 16),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.green[50],
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.green[200]!),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.info_outline,
                      color: Colors.green[600],
                      size: 20,
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        'New Balance: ₱${_getNewBalance().toStringAsFixed(2)}',
                        style: TextStyle(
                          color: Colors.green[700],
                          fontSize: 14,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
          child: const Text(
            'Cancel',
            style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
          ),
        ),
        ElevatedButton(
          onPressed: _isLoading || _error != null ? null : _submitBalanceUpdate,
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.blue[600],
            foregroundColor: Colors.white,
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          ),
          child: _isLoading
              ? const SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                    valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                  ),
                )
              : Text(
                  _selectedOperation == BalanceOperation.add ? 'Add' : 'Deduct',
                  style: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                  ),
                ),
        ),
      ],
    );
  }

  double _getNewBalance() {
    final amount = double.tryParse(_amountController.text) ?? 0;
    return _selectedOperation == BalanceOperation.add
        ? widget.customer.balance + amount
        : widget.customer.balance - amount;
  }
}

enum BalanceOperation { add, deduct }




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\manual_stock_adjustment_dialog.dart
â•‘ SIZE: 18.79 KB
â•‘ MODIFIED: 10/02/2025 12:23:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/product.dart';
import '../models/loss_reason.dart';
import '../providers/inventory_provider.dart';
import '../utils/currency_utils.dart';
import '../services/tax_service.dart';

enum StockAdjustmentType { receive, remove }

class ManualStockAdjustmentDialog extends StatefulWidget {
  final StockAdjustmentType type;

  const ManualStockAdjustmentDialog({super.key, required this.type});

  @override
  State<ManualStockAdjustmentDialog> createState() =>
      _ManualStockAdjustmentDialogState();
}

class _ManualStockAdjustmentDialogState
    extends State<ManualStockAdjustmentDialog> {
  final _formKey = GlobalKey<FormState>();
  final _quantityController = TextEditingController();
  final _costController = TextEditingController();
  final _searchController = TextEditingController();

  Product? _selectedProduct;
  List<Product> _filteredProducts = [];
  bool _isLoading = false;
  String? _selectedReason = 'Damage'; // Default to match barcode scanner

  @override
  void initState() {
    super.initState();
    _searchController.addListener(_filterProducts);
    _filterProducts(); // Initial load

    // Set initial cost price if product is provided (for receive stock)
    if (widget.type == StockAdjustmentType.receive) {
      _costController.text = '0.00';
    }
  }

  @override
  void dispose() {
    _quantityController.dispose();
    _costController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  void _filterProducts() {
    final inventoryProvider = context.read<InventoryProvider>();
    final query = _searchController.text.toLowerCase();

    setState(() {
      _filteredProducts = inventoryProvider.products
          .where(
            (product) =>
                product.name.toLowerCase().contains(query) ||
                product.barcode?.toLowerCase().contains(query) == true,
          )
          .toList();
    });
  }

  void _selectProduct(Product product) {
    setState(() {
      _selectedProduct = product;
    });
    _searchController.text = product.name;

    // Set cost price for receive stock
    if (widget.type == StockAdjustmentType.receive) {
      _costController.text = product.cost.toString();
    }
  }

  void _clearSelection() {
    setState(() {
      _selectedProduct = null;
    });
    _searchController.clear();
  }

  void _showErrorSnackBar(String message) {
    if (context.mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(message), backgroundColor: Colors.red),
      );
    }
  }

  void _showSuccessSnackBar(String message) {
    if (context.mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(message), backgroundColor: Colors.green),
      );
    }
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) return;
    if (_selectedProduct == null) {
      _showErrorSnackBar('Please select a product');
      return;
    }

    final quantity = int.parse(_quantityController.text);
    final costPrice = widget.type == StockAdjustmentType.receive
        ? double.parse(_costController.text)
        : null;
    final reason = widget.type == StockAdjustmentType.remove
        ? _selectedReason ?? 'Manual removal'
        : 'Restocking';

    if (quantity <= 0) {
      _showErrorSnackBar('Quantity must be greater than zero');
      return;
    }

    // For remove operations, check if enough stock is available
    if (widget.type == StockAdjustmentType.remove) {
      if (_selectedProduct!.stock < quantity) {
        _showErrorSnackBar(
          'Insufficient stock. Available: ${_selectedProduct!.stock}',
        );
        return;
      }
    }

    // Show confirmation dialog
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(
          widget.type == StockAdjustmentType.receive
              ? 'Confirm Stock Receipt'
              : 'Confirm Stock Removal',
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Product: ${_selectedProduct!.name}'),
            const SizedBox(height: 8),
            Text(
              widget.type == StockAdjustmentType.receive
                  ? 'Quantity to receive: $quantity'
                  : 'Quantity to remove: $quantity',
            ),
            const SizedBox(height: 8),
            if (widget.type == StockAdjustmentType.receive &&
                costPrice != null) ...[
              Text('Cost price: ₱${costPrice.toStringAsFixed(2)}'),
              const SizedBox(height: 8),
            ],
            Text('Current stock: ${_selectedProduct!.stock}'),
            const SizedBox(height: 8),
            Text(
              widget.type == StockAdjustmentType.receive
                  ? 'Resulting stock: ${_selectedProduct!.stock + quantity}'
                  : 'Resulting stock: ${_selectedProduct!.stock - quantity}',
            ),
            if (widget.type == StockAdjustmentType.remove) ...[
              const SizedBox(height: 8),
              Text('Reason: $reason'),
            ],
            const SizedBox(height: 16),
            Text(
              widget.type == StockAdjustmentType.receive
                  ? 'Are you sure you want to receive this stock?'
                  : 'Are you sure you want to remove this stock?',
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: ElevatedButton.styleFrom(
              backgroundColor: widget.type == StockAdjustmentType.receive
                  ? Colors.green
                  : Colors.red,
            ),
            child: Text(
              widget.type == StockAdjustmentType.receive
                  ? 'Confirm Receive'
                  : 'Confirm Remove',
            ),
          ),
        ],
      ),
    );

    if (confirmed != true) return;

    if (!mounted) return;

    setState(() {
      _isLoading = true;
    });

    try {
      final inventoryProvider = context.read<InventoryProvider>();
      bool success;

      if (widget.type == StockAdjustmentType.receive) {
        // For receive stock, we need to update the product with new cost price first
        if (costPrice != null && costPrice != _selectedProduct!.cost) {
          final updatedProduct = _selectedProduct!.copyWith(cost: costPrice);
          await inventoryProvider.updateProduct(updatedProduct);
        }

        // Then receive the stock
        success = await inventoryProvider.receiveStock(
          _selectedProduct!.id!,
          quantity,
        );
      } else {
        // Handle different removal reasons properly (mirroring barcode scanner logic)
        if (_selectedReason == 'Damage') {
          // Use addLoss for damage to create proper loss records
          success = await inventoryProvider.addLoss(
            productId: _selectedProduct!.id!,
            quantity: quantity,
            reason: LossReason.damaged,
          );
        } else {
          // For "Miss stock" and other reasons, just reduce stock
          success = await inventoryProvider.reduceStock(
            _selectedProduct!.id!,
            quantity,
            reason: reason,
          );
        }
      }

      if (!mounted) return;

      if (success) {
        if (mounted) {
          _showSuccessSnackBar(
            widget.type == StockAdjustmentType.receive
                ? 'Stock received successfully'
                : 'Stock removed successfully',
          );
          Navigator.of(context).pop(true);
        }
      } else {
        if (mounted) {
          _showErrorSnackBar(
            inventoryProvider.error ?? 'Failed to update stock',
          );
        }
      }
    } catch (e) {
      if (!mounted) return;
      _showErrorSnackBar('Error: ${e.toString()}');
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(
        widget.type == StockAdjustmentType.receive
            ? 'Manual Stock Receipt'
            : 'Manual Stock Removal',
      ),
      content: SizedBox(
        width: double.maxFinite,
        height: MediaQuery.of(context).size.height * 0.7,
        child: Form(
          key: _formKey,
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                // Product Search
                TextFormField(
                  controller: _searchController,
                  decoration: InputDecoration(
                    labelText: 'Search Product',
                    hintText: 'Type product name or barcode',
                    prefixIcon: const Icon(Icons.search),
                    suffixIcon: _selectedProduct != null
                        ? IconButton(
                            icon: const Icon(Icons.clear),
                            onPressed: _clearSelection,
                          )
                        : null,
                    border: const OutlineInputBorder(),
                  ),
                  validator: (value) {
                    if (_selectedProduct == null) {
                      return 'Please select a product';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // Product Selection Dropdown
                if (_searchController.text.isNotEmpty &&
                    _filteredProducts.isNotEmpty)
                  Container(
                    height: 200,
                    decoration: BoxDecoration(
                      border: Border.all(color: Colors.grey),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: ListView.builder(
                      itemCount: _filteredProducts.length,
                      itemBuilder: (context, index) {
                        final product = _filteredProducts[index];
                        return ListTile(
                          title: Text(
                            product.name,
                            overflow: TextOverflow.ellipsis,
                          ),
                          subtitle: FutureBuilder<double>(
                            future: TaxService.calculateSellingPriceWithRule(
                              product.cost,
                              productId: product.id,
                              categoryName: product.category,
                            ),
                            builder: (context, snapshot) {
                              if (snapshot.hasData) {
                                return Text(
                                  'Stock: ${product.stock} | Price: ${CurrencyUtils.formatCurrency(snapshot.data!)}',
                                  overflow: TextOverflow.ellipsis,
                                );
                              }
                              return Text(
                                'Stock: ${product.stock} | Price: Calculating...',
                                overflow: TextOverflow.ellipsis,
                              );
                            },
                          ),
                          trailing: Text(
                            product.barcode ?? 'No barcode',
                            style: const TextStyle(fontSize: 12),
                            overflow: TextOverflow.ellipsis,
                          ),
                          onTap: () => _selectProduct(product),
                        );
                      },
                    ),
                  ),

                // Selected Product Display
                if (_selectedProduct != null) ...[
                  const SizedBox(height: 16),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: Colors.blue.shade50,
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(color: Colors.blue.shade200),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Text(
                          'Selected Product',
                          style: TextStyle(
                            fontWeight: FontWeight.bold,
                            color: Colors.blue.shade700,
                          ),
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'Name: ${_selectedProduct!.name}',
                          overflow: TextOverflow.ellipsis,
                        ),
                        Text('Current Stock: ${_selectedProduct!.stock}'),
                        FutureBuilder<double>(
                          future: TaxService.calculateSellingPriceWithRule(
                            _selectedProduct!.cost,
                            productId: _selectedProduct!.id,
                            categoryName: _selectedProduct!.category,
                          ),
                          builder: (context, snapshot) {
                            if (snapshot.hasData) {
                              return Text(
                                'Price: ${CurrencyUtils.formatCurrency(snapshot.data!)}',
                              );
                            }
                            return const Text('Price: Calculating...');
                          },
                        ),
                        if (_selectedProduct!.barcode != null)
                          Text(
                            'Barcode: ${_selectedProduct!.barcode}',
                            overflow: TextOverflow.ellipsis,
                          ),
                      ],
                    ),
                  ),
                ],

                const SizedBox(height: 16),

                // Quantity Input
                TextFormField(
                  controller: _quantityController,
                  keyboardType: TextInputType.number,
                  decoration: InputDecoration(
                    labelText: 'Quantity',
                    border: const OutlineInputBorder(),
                    suffixText: 'units',
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter a quantity';
                    }
                    if (int.tryParse(value) == null || int.parse(value) <= 0) {
                      return 'Please enter a valid quantity';
                    }
                    return null;
                  },
                ),

                const SizedBox(height: 16),

                // Cost Price Input (for receive stock only)
                if (widget.type == StockAdjustmentType.receive) ...[
                  TextFormField(
                    controller: _costController,
                    keyboardType: const TextInputType.numberWithOptions(
                      decimal: true,
                    ),
                    decoration: const InputDecoration(
                      labelText: 'New Cost Price',
                      border: OutlineInputBorder(),
                      prefixText: '₱ ',
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Please enter a cost price';
                      }
                      if (double.tryParse(value) == null ||
                          double.parse(value) < 0) {
                        return 'Please enter a valid cost price';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                ],

                // Reason Dropdown (for remove stock only)
                if (widget.type == StockAdjustmentType.remove) ...[
                  DropdownButtonFormField<String>(
                    initialValue: _selectedReason,
                    decoration: const InputDecoration(
                      labelText: 'Reason',
                      border: OutlineInputBorder(),
                    ),
                    items: const [
                      DropdownMenuItem(value: 'Damage', child: Text('Damage')),
                      DropdownMenuItem(
                        value: 'Miss stock',
                        child: Text('Miss stock'),
                      ),
                    ],
                    onChanged: (value) {
                      setState(() {
                        _selectedReason = value;
                      });
                    },
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Please select a reason';
                      }
                      return null;
                    },
                  ),
                ],
              ],
            ),
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        ElevatedButton(
          onPressed: _isLoading ? null : _submit,
          style: ElevatedButton.styleFrom(
            backgroundColor: widget.type == StockAdjustmentType.receive
                ? Colors.green
                : Colors.red,
          ),
          child: _isLoading
              ? const SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                    valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                  ),
                )
              : Text(
                  widget.type == StockAdjustmentType.receive
                      ? 'Receive Stock'
                      : 'Remove Stock',
                ),
        ),
      ],
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\offline_status_widget.dart
â•‘ SIZE: 4.27 KB
â•‘ MODIFIED: 08/31/2025 14:16:49
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../services/offline_manager.dart';

class OfflineStatusWidget extends StatelessWidget {
  const OfflineStatusWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Consumer<OfflineManager>(
      builder: (context, offlineManager, child) {
        if (offlineManager.isOnline &&
            offlineManager.pendingOperationsCount == 0) {
          return const SizedBox.shrink();
        }

        return Container(
          width: double.infinity,
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          decoration: BoxDecoration(
            color: offlineManager.isOnline
                ? Colors.orange.shade100
                : Colors.red.shade100,
            border: Border(
              bottom: BorderSide(
                color: offlineManager.isOnline ? Colors.orange : Colors.red,
                width: 1,
              ),
            ),
          ),
          child: Column(
            children: [
              Row(
                children: [
                  Icon(
                    offlineManager.isOnline
                        ? (offlineManager.isSyncing
                            ? Icons.sync
                            : Icons.cloud_queue)
                        : Icons.cloud_off,
                    color: offlineManager.isOnline
                        ? Colors.orange.shade700
                        : Colors.red.shade700,
                    size: 16,
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      _getStatusMessage(offlineManager),
                      style: TextStyle(
                        color: offlineManager.isOnline
                            ? Colors.orange.shade700
                            : Colors.red.shade700,
                        fontSize: 12,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                  if (offlineManager.pendingOperationsCount > 0 &&
                      offlineManager.isOnline)
                    TextButton(
                      onPressed: offlineManager.isSyncing
                          ? null
                          : () {
                              offlineManager.syncPendingOperations();
                            },
                      style: TextButton.styleFrom(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 8,
                          vertical: 4,
                        ),
                        minimumSize: Size.zero,
                        tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                      ),
                      child: Text(
                        offlineManager.isSyncing ? 'Syncing...' : 'Sync Now',
                        style: TextStyle(
                          color: Colors.orange.shade700,
                          fontSize: 11,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                ],
              ),
              if (offlineManager.isSyncing)
                Padding(
                  padding: const EdgeInsets.only(top: 8.0),
                  child: LinearProgressIndicator(
                    value: offlineManager.totalOperationsToSync > 0
                        ? offlineManager.syncProgress /
                            offlineManager.totalOperationsToSync
                        : 0,
                  ),
                ),
            ],
          ),
        );
      },
    );
  }

  String _getStatusMessage(OfflineManager offlineManager) {
    if (!offlineManager.isOnline) {
      if (offlineManager.pendingOperationsCount > 0) {
        return 'Offline - ${offlineManager.pendingOperationsCount} changes pending sync';
      }
      return 'Offline - Changes will sync when connection is restored';
    }

    if (offlineManager.isSyncing) {
      return 'Syncing ${offlineManager.pendingOperationsCount} pending changes...';
    }

    if (offlineManager.pendingOperationsCount > 0) {
      return '${offlineManager.pendingOperationsCount} changes waiting to sync';
    }

    return 'All changes synced';
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\password_strength_checklist.dart
â•‘ SIZE: 4.36 KB
â•‘ MODIFIED: 10/04/2025 06:17:12
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';

class PasswordStrengthChecklist extends StatelessWidget {
  final String password;
  final bool isVisible;

  const PasswordStrengthChecklist({
    super.key,
    required this.password,
    this.isVisible = true,
  });

  @override
  Widget build(BuildContext context) {
    if (!isVisible) return const SizedBox.shrink();

    final checks = _getPasswordChecks(password);
    final overallStrength = _getOverallStrength(checks);

    return AnimatedContainer(
      duration: const Duration(milliseconds: 300),
      margin: const EdgeInsets.only(top: 8),
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainer,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: Theme.of(context).colorScheme.outline.withValues(alpha: .3),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.security,
                size: 16,
                color: _getStrengthColor(overallStrength),
              ),
              const SizedBox(width: 8),
              Text(
                'Password Strength: ${_getStrengthText(overallStrength)}',
                style: TextStyle(
                  fontSize: 14,
                  fontWeight: FontWeight.w600,
                  color: _getStrengthColor(overallStrength),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          LinearProgressIndicator(
            value: overallStrength / 4,
            backgroundColor: Colors.grey.shade300,
            valueColor: AlwaysStoppedAnimation<Color>(
              _getStrengthColor(overallStrength),
            ),
          ),
          const SizedBox(height: 12),
          ...checks.entries.map(
            (entry) => _buildCheckItem(entry.key, entry.value, context),
          ),
        ],
      ),
    );
  }

  Widget _buildCheckItem(String text, bool isValid, BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        children: [
          AnimatedContainer(
            duration: const Duration(milliseconds: 200),
            child: Icon(
              isValid ? Icons.check_circle : Icons.radio_button_unchecked,
              size: 16,
              color: isValid
                  ? Colors.green
                  : Theme.of(context).colorScheme.onSurfaceVariant,
            ),
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              text,
              style: TextStyle(
                fontSize: 12,
                color: isValid
                    ? Colors.green
                    : Theme.of(context).colorScheme.onSurfaceVariant,
                fontWeight: isValid ? FontWeight.w500 : FontWeight.normal,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Map<String, bool> _getPasswordChecks(String password) {
    return {
      'At least 8 characters': password.length >= 8,
      'Contains uppercase letter (A-Z)': password.contains(RegExp(r'[A-Z]')),
      'Contains lowercase letter (a-z)': password.contains(RegExp(r'[a-z]')),
      'Contains number (0-9)': password.contains(RegExp(r'[0-9]')),
      'Contains special character (!@#\$%^&*)': password.contains(
        RegExp(r'[!@#$%^&*(),.?":{}|<>]'),
      ),
    };
  }

  int _getOverallStrength(Map<String, bool> checks) {
    return checks.values.where((check) => check).length;
  }

  Color _getStrengthColor(int strength) {
    switch (strength) {
      case 0:
      case 1:
        return Colors.red;
      case 2:
        return Colors.orange;
      case 3:
        return Colors.yellow.shade700;
      case 4:
      case 5:
        return Colors.green;
      default:
        return Colors.grey;
    }
  }

  String _getStrengthText(int strength) {
    switch (strength) {
      case 0:
      case 1:
        return 'Very Weak';
      case 2:
        return 'Weak';
      case 3:
        return 'Fair';
      case 4:
        return 'Good';
      case 5:
        return 'Strong';
      default:
        return 'Unknown';
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\price_history_dialog.dart
â•‘ SIZE: 2.38 KB
â•‘ MODIFIED: 08/31/2025 20:15:51
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:prostock/models/price_history.dart';
import 'package:prostock/services/firestore/product_service.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

class PriceHistoryDialog extends StatefulWidget {
  final String productId;

  const PriceHistoryDialog({super.key, required this.productId});

  @override
  PriceHistoryDialogState createState() => PriceHistoryDialogState();
}

class PriceHistoryDialogState extends State<PriceHistoryDialog> {
  late Future<List<PriceHistory>> _priceHistoryFuture;

  @override
  void initState() {
    super.initState();
    final productService = ProductService(FirebaseFirestore.instance);
    _priceHistoryFuture = productService.getPriceHistory(
      widget.productId,
    );
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Price History'),
      content: FutureBuilder<List<PriceHistory>>(
        future: _priceHistoryFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }
          if (snapshot.hasError) {
            return const Center(child: Text('Error loading price history.'));
          }
          if (!snapshot.hasData || snapshot.data!.isEmpty) {
            return const Center(child: Text('No price history found.'));
          }

          final priceHistory = snapshot.data!;

          return SizedBox(
            width: double.maxFinite,
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: priceHistory.length,
              itemBuilder: (context, index) {
                final history = priceHistory[index];
                return ListTile(
                  title: Text(
                    'Price: ₱${history.price.toStringAsFixed(2)}', // Using Peso symbol
                    style: const TextStyle(fontWeight: FontWeight.bold),
                  ),
                  subtitle: Text(
                    DateFormat.yMMMd().add_jm().format(history.timestamp),
                  ),
                );
              },
            ),
          );
        },
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Close'),
        ),
      ],
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\receipt_dialog.dart
â•‘ SIZE: 14.45 KB
â•‘ MODIFIED: 10/04/2025 03:06:41
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/services/printing_service.dart';
import '../models/receipt.dart';
import '../utils/currency_utils.dart';

class ReceiptDialog extends StatelessWidget {
  final Receipt receipt;
  final double? cashTendered;
  final double? change;

  const ReceiptDialog({
    super.key,
    required this.receipt,
    this.cashTendered,
    this.change,
  });

  @override
  Widget build(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;
    final maxDialogHeight = screenHeight * 0.9; // Use 90% of screen height

    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Container(
        width: MediaQuery.of(context).size.width * 0.9,
        constraints: BoxConstraints(maxWidth: 400, maxHeight: maxDialogHeight),
        padding: const EdgeInsets.all(20),
        child: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              // Header
              Container(
                padding: const EdgeInsets.only(bottom: 16),
                decoration: const BoxDecoration(
                  border: Border(
                    bottom: BorderSide(color: Colors.grey, width: 2),
                  ),
                ),
                child: Column(
                  children: [
                    const Text(
                      'RETAIL CREDIT MANAGER',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                      textAlign: TextAlign.center,
                    ),
                    const SizedBox(height: 8),
                    Text(
                      'Receipt: ${receipt.formattedReceiptNumber}',
                      style: const TextStyle(
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    Text(
                      receipt.formattedTimestamp,
                      style: const TextStyle(fontSize: 12, color: Colors.grey),
                    ),
                  ],
                ),
              ),

              const SizedBox(height: 16),

              // Customer and Payment Info
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        'Customer:',
                        style: TextStyle(
                          fontSize: 12,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      Text(
                        receipt.customerName ?? 'Walk-in Customer',
                        style: const TextStyle(fontSize: 12),
                      ),
                    ],
                  ),
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.end,
                    children: [
                      const Text(
                        'Payment:',
                        style: TextStyle(
                          fontSize: 12,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      Text(
                        receipt.paymentMethod.toUpperCase(),
                        style: const TextStyle(fontSize: 12),
                      ),
                    ],
                  ),
                ],
              ),

              const SizedBox(height: 16),

              // Items
              Container(
                constraints: BoxConstraints(
                  maxHeight:
                      maxDialogHeight *
                      0.4, // Limit items to 40% of dialog height
                ),
                child: SingleChildScrollView(
                  child: Column(
                    children: [
                      // Items header
                      Container(
                        padding: const EdgeInsets.symmetric(vertical: 8),
                        decoration: const BoxDecoration(
                          border: Border(
                            bottom: BorderSide(color: Colors.grey),
                          ),
                        ),
                        child: const Row(
                          children: [
                            Expanded(
                              flex: 3,
                              child: Text(
                                'Item',
                                style: TextStyle(
                                  fontSize: 12,
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                            ),
                            Expanded(
                              child: Text(
                                'Qty',
                                style: TextStyle(
                                  fontSize: 12,
                                  fontWeight: FontWeight.w600,
                                ),
                                textAlign: TextAlign.center,
                              ),
                            ),
                            Expanded(
                              child: Text(
                                'Price',
                                style: TextStyle(
                                  fontSize: 12,
                                  fontWeight: FontWeight.w600,
                                ),
                                textAlign: TextAlign.right,
                              ),
                            ),
                            Expanded(
                              child: Text(
                                'Total',
                                style: TextStyle(
                                  fontSize: 12,
                                  fontWeight: FontWeight.w600,
                                ),
                                textAlign: TextAlign.right,
                              ),
                            ),
                          ],
                        ),
                      ),

                      // Items list
                      ...receipt.items.map(
                        (item) => Padding(
                          padding: const EdgeInsets.symmetric(vertical: 4),
                          child: Row(
                            children: [
                              Expanded(
                                flex: 3,
                                child: Text(
                                  item.productName,
                                  style: const TextStyle(fontSize: 11),
                                  maxLines: 2,
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                              Expanded(
                                child: Text(
                                  '${item.quantity}',
                                  style: const TextStyle(fontSize: 11),
                                  textAlign: TextAlign.center,
                                ),
                              ),
                              Expanded(
                                child: Text(
                                  CurrencyUtils.formatCurrency(item.unitPrice),
                                  style: const TextStyle(fontSize: 11),
                                  textAlign: TextAlign.right,
                                ),
                              ),
                              Expanded(
                                child: Text(
                                  CurrencyUtils.formatCurrency(item.totalPrice),
                                  style: const TextStyle(fontSize: 11),
                                  textAlign: TextAlign.right,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),

              const SizedBox(height: 16),

              // Totals
              Container(
                padding: const EdgeInsets.symmetric(vertical: 12),
                decoration: const BoxDecoration(
                  border: Border(top: BorderSide(color: Colors.grey, width: 2)),
                ),
                child: Column(
                  children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Text('Subtotal:', style: TextStyle(fontSize: 14)),
                        Text(
                          CurrencyUtils.formatCurrency(receipt.subtotal),
                          style: const TextStyle(fontSize: 14),
                        ),
                      ],
                    ),
                    if (receipt.tax > 0) ...[
                      const SizedBox(height: 4),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          const Text('Tax:', style: TextStyle(fontSize: 14)),
                          Text(
                            CurrencyUtils.formatCurrency(receipt.tax),
                            style: const TextStyle(fontSize: 14),
                          ),
                        ],
                      ),
                    ],
                    const SizedBox(height: 8),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Text(
                          'TOTAL:',
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        Text(
                          CurrencyUtils.formatCurrency(receipt.total),
                          style: const TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                            color: Colors.green,
                          ),
                        ),
                      ],
                    ),
                    if (cashTendered != null && cashTendered! > 0) ...[
                      const SizedBox(height: 8),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          const Text(
                            'Cash Tendered:',
                            style: TextStyle(fontSize: 14),
                          ),
                          Text(
                            CurrencyUtils.formatCurrency(cashTendered!),
                            style: const TextStyle(fontSize: 14),
                          ),
                        ],
                      ),
                    ],
                    if (change != null && change! > 0) ...[
                      const SizedBox(height: 4),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          const Text('Change:', style: TextStyle(fontSize: 14)),
                          Text(
                            CurrencyUtils.formatCurrency(change!),
                            style: const TextStyle(
                              fontSize: 14,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ],
                ),
              ),

              const SizedBox(height: 20),

              // Action buttons
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton.icon(
                      onPressed: () {
                        final printingService = PrintingService();
                        if (printingService.isConnected) {
                          printingService.printReceipt(
                            receipt,
                            cashTendered: cashTendered,
                            change: change,
                          );
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                              content: Text('Sent to printer'),
                              backgroundColor: Colors.green,
                            ),
                          );
                        } else {
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                              content: Text(
                                'No printer connected. Please set up a printer in settings.',
                              ),
                              backgroundColor: Colors.red,
                            ),
                          );
                        }
                      },
                      icon: const Icon(Icons.print),
                      label: const Text('Print'),
                      style: OutlinedButton.styleFrom(
                        padding: const EdgeInsets.symmetric(vertical: 12),
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton.icon(
                      onPressed: () {
                        Navigator.of(context).pop();
                      },
                      icon: const Icon(Icons.check),
                      label: const Text('Done'),
                      style: ElevatedButton.styleFrom(
                        padding: const EdgeInsets.symmetric(vertical: 12),
                      ),
                    ),
                  ),
                ],
              ),

              const SizedBox(height: 12),

              // Footer
              const Text(
                'Thank you for your business!',
                style: TextStyle(
                  fontSize: 12,
                  fontStyle: FontStyle.italic,
                  color: Colors.grey,
                ),
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\receive_stock_dialog.dart
â•‘ SIZE: 9.78 KB
â•‘ MODIFIED: 10/26/2025 13:06:48
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/product.dart';
import '../providers/inventory_provider.dart';

class ReceiveStockDialog extends StatefulWidget {
  final Product product;

  const ReceiveStockDialog({super.key, required this.product});

  @override
  ReceiveStockDialogState createState() => ReceiveStockDialogState();
}

class ReceiveStockDialogState extends State<ReceiveStockDialog> {
  final _formKey = GlobalKey<FormState>();
  final _quantityController = TextEditingController();
  final _costController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _costController.text = widget.product.cost.toString();
  }

  @override
  void dispose() {
    _quantityController.dispose();
    _costController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text('Receive Stock for ${widget.product.name}'),
      content: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextFormField(
              controller: _quantityController,
              keyboardType: TextInputType.number,
              decoration: const InputDecoration(
                labelText: 'Quantity Received',
                border: OutlineInputBorder(),
              ),
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return 'Please enter a quantity';
                }
                if (int.tryParse(value) == null || int.parse(value) <= 0) {
                  return 'Please enter a valid quantity';
                }
                return null;
              },
            ),
            const SizedBox(height: 16),
            TextFormField(
              controller: _costController,
              keyboardType: const TextInputType.numberWithOptions(
                decimal: true,
              ),
              decoration: const InputDecoration(
                labelText: 'New Cost Price',
                border: OutlineInputBorder(),
              ),
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return 'Please enter a cost price';
                }
                if (double.tryParse(value) == null || double.parse(value) < 0) {
                  return 'Please enter a valid cost price';
                }
                return null;
              },
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        ElevatedButton(onPressed: _submit, child: const Text('Receive')),
      ],
    );
  }

  void _submit() async {
    if (_formKey.currentState!.validate()) {
      final quantity = int.parse(_quantityController.text);
      final newCost = double.parse(_costController.text);

      // Get current batch information
      final inventoryProvider = context.read<InventoryProvider>();
      final batches = await inventoryProvider.getBatchesForProduct(
        widget.product.id!,
      );

      final currentStock = widget.product.stock;
      final totalQuantity = currentStock + quantity;

      // Calculate what the average cost will be
      final totalValue =
          (currentStock * widget.product.cost) + (quantity * newCost);
      final averageCost = totalQuantity > 0
          ? totalValue / totalQuantity
          : newCost;

      // Confirm action with the user before applying changes
      if (!mounted) return;
      final bool? confirmed = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Confirm Stock Receipt'),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Product: ${widget.product.name}',
                  style: const TextStyle(fontWeight: FontWeight.bold),
                ),
                const Divider(),
                const SizedBox(height: 8),
                Text('Quantity to receive: $quantity units'),
                Text('Batch cost: ₱${newCost.toStringAsFixed(2)} per unit'),
                const SizedBox(height: 16),
                if (batches.isNotEmpty) ...[
                  const Text(
                    'Current Batches (FIFO Order):',
                    style: TextStyle(fontWeight: FontWeight.bold, fontSize: 12),
                  ),
                  const SizedBox(height: 4),
                  ...batches
                      .take(3)
                      .map(
                        (batch) => Padding(
                          padding: const EdgeInsets.only(left: 8, bottom: 2),
                          child: Text(
                            '• ${batch.batchNumber}: ${batch.quantityRemaining} units @ ₱${batch.unitCost.toStringAsFixed(2)}',
                            style: const TextStyle(fontSize: 11),
                          ),
                        ),
                      ),
                  if (batches.length > 3)
                    Padding(
                      padding: const EdgeInsets.only(left: 8),
                      child: Text(
                        '... and ${batches.length - 3} more batch(es)',
                        style: const TextStyle(
                          fontSize: 11,
                          fontStyle: FontStyle.italic,
                        ),
                      ),
                    ),
                  const SizedBox(height: 12),
                ],
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.green.shade50,
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.green.shade300),
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        'After Receiving:',
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          fontSize: 12,
                        ),
                      ),
                      const SizedBox(height: 8),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          const Text(
                            'Total Stock:',
                            style: TextStyle(fontSize: 11),
                          ),
                          Text(
                            '$totalQuantity units',
                            style: const TextStyle(
                              fontSize: 11,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ],
                      ),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          const Text(
                            'Total Batches:',
                            style: TextStyle(fontSize: 11),
                          ),
                          Text(
                            '${batches.length + 1}',
                            style: const TextStyle(fontSize: 11),
                          ),
                        ],
                      ),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          const Text(
                            'Average Cost:',
                            style: TextStyle(fontSize: 11),
                          ),
                          Text(
                            '₱${averageCost.toStringAsFixed(2)}',
                            style: const TextStyle(fontSize: 11),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 16),
                const Text(
                  'This will create a new batch. Sales will use FIFO (oldest batch first).',
                  style: TextStyle(fontSize: 11, fontStyle: FontStyle.italic),
                ),
              ],
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () => Navigator.of(context).pop(true),
              style: ElevatedButton.styleFrom(backgroundColor: Colors.green),
              child: const Text('Receive Stock'),
            ),
          ],
        ),
      );

      if (confirmed != true) {
        return;
      }

      if (!mounted) return;

      // Call the receiveStockWithCost method that creates a batch
      final success = await inventoryProvider.receiveStockWithCost(
        widget.product.id!,
        quantity,
        newCost,
      );

      if (!mounted) return;

      if (success) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Stock received: $quantity units added to new batch'),
            backgroundColor: Colors.green,
          ),
        );
        Navigator.of(context).pop(true);
      } else {
        // Show error if failed
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(inventoryProvider.error ?? 'Failed to receive stock'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\report_helpers.dart
â•‘ SIZE: 8.12 KB
â•‘ MODIFIED: 10/27/2025 09:50:05
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/models/receipt.dart';
import 'package:prostock/models/sale.dart';
import 'package:prostock/models/sale_item.dart';
import 'package:prostock/services/firestore/customer_service.dart';
import 'package:prostock/services/firestore/product_service.dart';
import 'package:prostock/services/firestore/sale_service.dart';
import 'package:prostock/services/local_database_service.dart';
import 'package:prostock/widgets/receipt_dialog.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

Widget buildSummaryCard(
  BuildContext context,
  String title,
  String value,
  IconData icon,
  Color color,
) {
  final colorScheme = Theme.of(context).colorScheme;
  final textTheme = Theme.of(context).textTheme;

  // Determine which theme color container to use based on the input color
  Color containerColor;
  Color onContainerColor;

  // Map common colors to theme equivalents
  if (color == Colors.green) {
    containerColor = colorScheme.primaryContainer;
    onContainerColor = colorScheme.onPrimaryContainer;
  } else if (color == Colors.red) {
    containerColor = colorScheme.errorContainer;
    onContainerColor = colorScheme.onErrorContainer;
  } else if (color == Colors.orange) {
    containerColor = colorScheme.tertiaryContainer;
    onContainerColor = colorScheme.onTertiaryContainer;
  } else if (color == Colors.blue) {
    containerColor = colorScheme.secondaryContainer;
    onContainerColor = colorScheme.onSecondaryContainer;
  } else {
    // Default to primary for other colors
    containerColor = colorScheme.primaryContainer;
    onContainerColor = colorScheme.onPrimaryContainer;
  }

  return Card(
    elevation: 1,
    clipBehavior: Clip.antiAlias,
    child: InkWell(
      onTap: () {
        final messenger = ScaffoldMessenger.of(context);
        messenger.clearSnackBars();
        messenger.showSnackBar(
          SnackBar(
            content: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(icon, color: colorScheme.onPrimary, size: 16),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    '$title: $value',
                    style: const TextStyle(fontWeight: FontWeight.w500),
                  ),
                ),
              ],
            ),
            backgroundColor: colorScheme.primary,
            duration: const Duration(seconds: 3),
            behavior: SnackBarBehavior.floating,
            margin: const EdgeInsets.all(16),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(8),
            ),
          ),
        );
      },
      borderRadius: BorderRadius.circular(12),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Icon in colored container
            Container(
              padding: const EdgeInsets.all(6),
              decoration: BoxDecoration(
                color: containerColor,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Icon(icon, color: onContainerColor, size: 20),
            ),
            const SizedBox(height: 8),

            // Title
            Text(
              title,
              style: textTheme.labelSmall?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
            const SizedBox(height: 4),

            // Value with hint icon
            Row(
              children: [
                Flexible(
                  child: FittedBox(
                    fit: BoxFit.scaleDown,
                    alignment: Alignment.centerLeft,
                    child: Text(
                      _formatLargeNumber(value),
                      style: textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                        color: colorScheme.onSurface,
                      ),
                    ),
                  ),
                ),
                if (_formatLargeNumber(value) != value) ...[
                  const SizedBox(width: 4),
                  Icon(
                    Icons.info_outline,
                    size: 14,
                    color: colorScheme.outline.withOpacity(0.6),
                  ),
                ],
              ],
            ),
          ],
        ),
      ),
    ),
  );
}

String _formatLargeNumber(String value) {
  String cleanValue = value.replaceAll(RegExp(r'[₱,\s]'), '');
  double? numValue = double.tryParse(cleanValue);
  if (numValue == null) return value;

  if (numValue >= 1000000) {
    return '₱${(numValue / 1000000).toStringAsFixed(1)}M';
  } else if (numValue >= 1000) {
    return '₱${(numValue / 1000).toStringAsFixed(1)}K';
  } else {
    return value;
  }
}

Future<void> showHistoricalReceipt(BuildContext context, Sale sale) async {
  try {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const Center(child: CircularProgressIndicator()),
    );

    final saleService = SaleService(FirebaseFirestore.instance);
    final customerService = CustomerService(FirebaseFirestore.instance);
    final productService = ProductService(FirebaseFirestore.instance);

    List<SaleItem> saleItems = [];
    if (sale.isSynced == 1) {
      saleItems = await saleService.getSaleItemsBySaleId(sale.id!);
    } else {
      final localItems = await LocalDatabaseService.instance.getSaleItems(
        sale.id!,
      );
      saleItems = localItems.map((item) => SaleItem.fromMap(item)).toList();
    }

    String? customerName;
    if (sale.customerId != null) {
      final customer = await customerService.getCustomerById(sale.customerId!);
      customerName = customer?.name;
    }

    // Group sale items by product to avoid duplicate lines
    final Map<String, Map<String, dynamic>> grouped = {};
    for (final item in saleItems) {
      if (grouped.containsKey(item.productId)) {
        final existing = grouped[item.productId]!;
        existing['quantity'] = (existing['quantity'] as int) + item.quantity;
        existing['totalPrice'] =
            (existing['totalPrice'] as double) + item.totalPrice;
        // Keep unitPrice consistent; if it varies, recompute later from total/qty
      } else {
        grouped[item.productId] = {
          'productId': item.productId,
          'quantity': item.quantity,
          'unitPrice': item.unitPrice,
          'totalPrice': item.totalPrice,
        };
      }
    }

    // Build receipt items from grouped data
    List<ReceiptItem> receiptItems = [];
    for (final groupedItem in grouped.values) {
      final productId = groupedItem['productId'] as String;
      final product = await productService.getProductById(productId);
      final quantity = groupedItem['quantity'] as int;
      final totalPrice = groupedItem['totalPrice'] as double;
      final unitPrice = quantity > 0
          ? (totalPrice / quantity)
          : (groupedItem['unitPrice'] as double);

      receiptItems.add(
        ReceiptItem(
          productName: product?.name ?? 'Unknown Product',
          quantity: quantity,
          unitPrice: unitPrice,
          totalPrice: totalPrice,
        ),
      );
    }

    final receipt = Receipt(
      receiptNumber: sale.id.toString(),
      timestamp: sale.createdAt,
      customerName: customerName,
      paymentMethod: sale.paymentMethod,
      items: receiptItems,
      subtotal: sale.totalAmount,
      tax: 0.0,
      total: sale.totalAmount,
      saleId: sale.id.toString(),
    );

    if (context.mounted) {
      Navigator.of(context).pop();
      showDialog(
        context: context,
        builder: (context) => ReceiptDialog(receipt: receipt),
      );
    }
  } catch (e) {
    if (context.mounted) {
      Navigator.of(context).pop();
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error loading receipt: ${e.toString()}'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\sales_chart.dart
â•‘ SIZE: 3.52 KB
â•‘ MODIFIED: 08/27/2025 07:24:54
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import '../utils/currency_utils.dart';

class SalesChart extends StatelessWidget {
  const SalesChart({super.key});

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Sales Trend (Last 7 Days)',
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 200,
              child: LineChart(
                LineChartData(
                  gridData: const FlGridData(show: true),
                  titlesData: FlTitlesData(
                    leftTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        reservedSize: 40,
                        getTitlesWidget: (value, meta) {
                          return Text(
                            CurrencyUtils.formatCurrency(value),
                            style: const TextStyle(fontSize: 12),
                          );
                        },
                      ),
                    ),
                    bottomTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        getTitlesWidget: (value, meta) {
                          const days = [
                            'Mon',
                            'Tue',
                            'Wed',
                            'Thu',
                            'Fri',
                            'Sat',
                            'Sun',
                          ];
                          if (value.toInt() >= 0 &&
                              value.toInt() < days.length) {
                            return Text(
                              days[value.toInt()],
                              style: const TextStyle(fontSize: 12),
                            );
                          }
                          return const Text('');
                        },
                      ),
                    ),
                    rightTitles: const AxisTitles(
                      sideTitles: SideTitles(showTitles: false),
                    ),
                    topTitles: const AxisTitles(
                      sideTitles: SideTitles(showTitles: false),
                    ),
                  ),
                  borderData: FlBorderData(show: true),
                  lineBarsData: [
                    LineChartBarData(
                      spots: [
                        const FlSpot(0, 150),
                        const FlSpot(1, 200),
                        const FlSpot(2, 180),
                        const FlSpot(3, 250),
                        const FlSpot(4, 300),
                        const FlSpot(5, 280),
                        const FlSpot(6, 320),
                      ],
                      isCurved: true,
                      color: Colors.blue,
                      barWidth: 3,
                      dotData: const FlDotData(show: true),
                      belowBarData: BarAreaData(
                        show: true,
                        color: Colors.blue.withValues(alpha: 0.1),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\sales_over_time_chart.dart
â•‘ SIZE: 5.57 KB
â•‘ MODIFIED: 09/17/2025 11:24:57
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:prostock/utils/chart_utils.dart';
import '../models/sale.dart';
import 'filter_toggle_buttons.dart';

class SalesOverTimeChart extends StatefulWidget {
  final List<Sale> sales;

  const SalesOverTimeChart({super.key, required this.sales});

  @override
  State<SalesOverTimeChart> createState() => _SalesOverTimeChartState();
}

class _SalesOverTimeChartState extends State<SalesOverTimeChart> {
  String _selectedFilter = "Daily"; // default

  @override
  Widget build(BuildContext context) {
    return AspectRatio(
      aspectRatio: 1.2,
      child: Card(
        elevation: 6,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              /// Header + Filter
              Column(
                children: [
                  const Text(
                    "Sales Over Time",
                    style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 8),

                  /// Filter Buttons
                  FilterToggleButtons(
                    selectedFilter: _selectedFilter,
                    onFilterChanged: (filter) {
                      setState(() {
                        _selectedFilter = filter;
                      });
                    },
                    fillColor: Colors.blue,
                    color: Colors.blueGrey,
                  ),
                ],
              ),
              const SizedBox(height: 12),

              /// Chart
              Expanded(child: LineChart(_mainData())),
            ],
          ),
        ),
      ),
    );
  }

  LineChartData _mainData() {
    final spots = _getChartSpots();

    return LineChartData(
      gridData: FlGridData(
        show: true,
        drawVerticalLine: true,
        getDrawingHorizontalLine: (value) =>
            FlLine(color: Colors.grey.shade300, strokeWidth: 0.5),
        getDrawingVerticalLine: (value) =>
            FlLine(color: Colors.grey.shade300, strokeWidth: 0.5),
      ),
      titlesData: FlTitlesData(
        show: true,
        rightTitles: const AxisTitles(
          sideTitles: SideTitles(showTitles: false),
        ),
        topTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
        bottomTitles: AxisTitles(
          sideTitles: SideTitles(
            showTitles: true,
            reservedSize: 32,
            interval: 1,
            getTitlesWidget: bottomTitleWidgets,
          ),
        ),
        leftTitles: AxisTitles(
          sideTitles: SideTitles(
            showTitles: true,
            reservedSize: 48,
            getTitlesWidget: leftTitleWidgets,
          ),
        ),
      ),
      borderData: FlBorderData(show: false),
      minX: 0,
      maxX: (spots.length - 1).toDouble(),
      minY: 0,
      lineBarsData: [
        LineChartBarData(
          spots: spots,
          isCurved: true,
          gradient: LinearGradient(
            colors: [Colors.blue.shade400, Colors.blue.shade800],
          ),
          barWidth: 4,
          isStrokeCapRound: true,
          dotData: const FlDotData(show: false),
          belowBarData: BarAreaData(
            show: true,
            gradient: LinearGradient(
              colors: [
                Colors.blue.withValues(alpha: 0.3),
                Colors.blue.withValues(alpha: 0.05),
              ],
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
            ),
          ),
        ),
      ],
    );
  }

  List<FlSpot> _getChartSpots() {
    if (widget.sales.isEmpty) return [const FlSpot(0, 0)];

    // groupDataByFilter now handles time scoping and merging internally
    final groupedSales = ChartUtils.groupDataByFilter<Sale>(
      widget.sales,
      _selectedFilter,
      (sale) => sale.createdAt,
      (sale) => sale.totalAmount,
    );

    final sortedKeys = groupedSales.keys.toList()..sort();

    return List.generate(sortedKeys.length, (i) {
      final date = sortedKeys[i];
      final total = groupedSales[date]!;
      return FlSpot(i.toDouble(), total);
    });
  }

  Widget bottomTitleWidgets(double value, TitleMeta meta) {
    const style = TextStyle(
      color: Color(0xff68737d),
      fontWeight: FontWeight.bold,
      fontSize: 12,
    );

    final groupedKeys = _getSortedKeys();
    if (value.toInt() >= groupedKeys.length) return const SizedBox.shrink();

    final date = groupedKeys[value.toInt()];
    final text = ChartUtils.formatBottomTitle(date, _selectedFilter);

    return SideTitleWidget(
      meta: meta,
      space: 6,
      child: Transform.rotate(
        angle: -0.5, // Tilt text by ~30 degrees
        child: Text(text, style: style),
      ),
    );
  }

  List<DateTime> _getSortedKeys() {
    // groupDataByFilter now handles time scoping and merging internally
    final groupedSales = ChartUtils.groupDataByFilter<Sale>(
      widget.sales,
      _selectedFilter,
      (sale) => sale.createdAt,
      (sale) => sale.totalAmount,
    );

    return groupedSales.keys.toList()..sort();
  }

  Widget leftTitleWidgets(double value, TitleMeta meta) {
    const style = TextStyle(
      color: Color(0xff67727d),
      fontWeight: FontWeight.bold,
      fontSize: 12,
    );

    String text;
    if (value >= 1000) {
      text = '${(value / 1000).toStringAsFixed(1)}k';
    } else {
      text = value.toStringAsFixed(0);
    }

    return Text(text, style: style);
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\stock_movement_report_widget.dart
â•‘ SIZE: 5.52 KB
â•‘ MODIFIED: 10/02/2025 12:23:17
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
import '../providers/inventory_provider.dart';
import '../providers/stock_movement_provider.dart';

class StockMovementReportWidget extends StatefulWidget {
  const StockMovementReportWidget({super.key});

  @override
  State<StockMovementReportWidget> createState() =>
      _StockMovementReportWidgetState();
}

class _StockMovementReportWidgetState extends State<StockMovementReportWidget> {
  DateTime? _startDate;
  DateTime? _endDate;

  Future<void> _selectDateRange(BuildContext context) async {
    final initialDateRange = DateTimeRange(
      start: _startDate ?? DateTime.now().subtract(const Duration(days: 7)),
      end: _endDate ?? DateTime.now(),
    );
    final newDateRange = await showDateRangePicker(
      context: context,
      firstDate: DateTime(2020),
      lastDate: DateTime.now().add(const Duration(days: 1)),
      initialDateRange: initialDateRange,
    );

    if (newDateRange != null) {
      setState(() {
        _startDate = newDateRange.start;
        _endDate = newDateRange.end;
      });
      _loadMovements();
    }
  }

  void _loadMovements() {
    Provider.of<StockMovementProvider>(
      context,
      listen: false,
    ).loadMovements(startDate: _startDate, endDate: _endDate);
  }

  @override
  void initState() {
    super.initState();
    // Initial load without date filter
    _loadMovements();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.all(8.0),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              Text(
                _startDate != null && _endDate != null
                    ? 'Period: ${DateFormat.yMd().format(_startDate!)} - ${DateFormat.yMd().format(_endDate!)}'
                    : 'All time',
                style: const TextStyle(fontWeight: FontWeight.bold),
              ),
              IconButton(
                icon: const Icon(Icons.calendar_today),
                onPressed: () => _selectDateRange(context),
              ),
            ],
          ),
        ),
        Expanded(
          child: Consumer<StockMovementProvider>(
            builder: (context, provider, child) {
              if (provider.isLoading && provider.movements.isEmpty) {
                return const Center(child: CircularProgressIndicator());
              }

              if (provider.error != null) {
                return Center(
                  child: Text(
                    'Error: ${provider.error}',
                    style: const TextStyle(color: Colors.red),
                  ),
                );
              }

              final inventoryProvider = Provider.of<InventoryProvider>(
                context,
                listen: false,
              );
              final movements = provider.movements;

              if (movements.isEmpty) {
                return const Center(
                  child: Text('No stock movements recorded for this period.'),
                );
              }

              return ListView.builder(
                itemCount: movements.length,
                itemBuilder: (context, index) {
                  final movement = movements[index];
                  final product = inventoryProvider.getProductById(
                    movement.productId,
                  );
                  final productName = product?.name ?? movement.productName;

                  final isStockIn = movement.movementType == 'stock_in';
                  final isStockOut = movement.movementType == 'stock_out';
                  final icon = isStockIn
                      ? Icons.arrow_upward
                      : isStockOut
                      ? Icons.arrow_downward
                      : Icons.sync_alt;
                  final color = isStockIn
                      ? Colors.green
                      : isStockOut
                      ? Colors.red
                      : Colors.orange;

                  return Card(
                    margin: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    child: ListTile(
                      leading: CircleAvatar(
                        backgroundColor: color,
                        child: Icon(icon, color: Colors.white),
                      ),
                      title: Text(
                        productName,
                        style: const TextStyle(fontWeight: FontWeight.bold),
                      ),
                      subtitle: Text(
                        '${movement.reason ?? movement.movementType} - ${DateFormat.yMd().add_jm().format(movement.createdAt)}',
                      ),
                      trailing: Text(
                        '${isStockIn
                            ? '+'
                            : isStockOut
                            ? '-'
                            : ''}${movement.quantity.abs()}',
                        style: TextStyle(
                          color: color,
                          fontWeight: FontWeight.bold,
                          fontSize: 16,
                        ),
                      ),
                    ),
                  );
                },
              );
            },
          ),
        ),
      ],
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\sync_failure_dialog.dart
â•‘ SIZE: 1.51 KB
â•‘ MODIFIED: 08/31/2025 13:50:42
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/providers/sync_failure_provider.dart';
import 'package:provider/provider.dart';

class SyncFailureDialog extends StatelessWidget {
  const SyncFailureDialog({super.key});

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Sync Failures'),
      content: Consumer<SyncFailureProvider>(
        builder: (context, provider, child) {
          if (provider.failures.isEmpty) {
            return const Text('No sync failures.');
          }

          return SizedBox(
            width: double.maxFinite,
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: provider.failures.length,
              itemBuilder: (context, index) {
                final failure = provider.failures[index];
                return ListTile(
                  title: Text('Operation: ${failure.operation.type.toString().split('.').last}'),
                  subtitle: Text('Error: ${failure.error}'),
                );
              },
            ),
          );
        },
      ),
      actions: [
        TextButton(
          onPressed: () {
            Provider.of<SyncFailureProvider>(context, listen: false).clearFailures();
            Navigator.of(context).pop();
          },
          child: const Text('Clear and Close'),
        ),
        TextButton(
          onPressed: () {
            Navigator.of(context).pop();
          },
          child: const Text('Close'),
        ),
      ],
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\sync_status_indicator.dart
â•‘ SIZE: 2.2 KB
â•‘ MODIFIED: 09/19/2025 15:21:00
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:prostock/services/offline_manager.dart';

class SyncStatusIndicator extends StatelessWidget {
  final Color? color;
  final EdgeInsetsGeometry? padding;
  const SyncStatusIndicator({super.key, this.color, this.padding});

  @override
  Widget build(BuildContext context) {
    return Consumer<OfflineManager>(
      builder: (context, offlineManager, child) {
        final isOnline = offlineManager.isOnline;
        final isSyncing = offlineManager.isSyncing;
        final total = offlineManager.totalOperationsToSync;
        final progress = offlineManager.syncProgress;
        final hasPending = offlineManager.pendingOperationsCount > 0;

        Widget icon;
        String tooltip;

        if (!isOnline) {
          icon = const Icon(Icons.cloud_off, color: Colors.orangeAccent);
          tooltip = 'Offline - operations will be queued';
        } else if (isSyncing) {
          icon = Stack(
            alignment: Alignment.center,
            children: [
              const SizedBox(
                width: 24,
                height: 24,
                child: CircularProgressIndicator(strokeWidth: 2),
              ),
              const Icon(Icons.cloud_sync, size: 16),
            ],
          );
          tooltip = 'Syncing $progress / $total';
        } else if (hasPending) {
          icon = const Icon(Icons.cloud_queue, color: Colors.orangeAccent);
          tooltip = 'Pending operations: $total';
        } else {
          icon = const Icon(Icons.cloud_done, color: Colors.lightGreen);
          tooltip = 'All changes synced';
        }

        return Padding(
          padding: padding ?? const EdgeInsets.symmetric(horizontal: 8),
          child: Tooltip(
            message: tooltip,
            child: InkWell(
              borderRadius: BorderRadius.circular(20),
              onTap: () async {
                if (isOnline && hasPending && !isSyncing) {
                  await offlineManager.syncPendingOperations();
                }
              },
              child: icon,
            ),
          ),
        );
      },
    );
  }
}




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ FILE: D:\flutter project\prostock\lib\widgets\top_selling_products_list.dart
â•‘ SIZE: 1.46 KB
â•‘ MODIFIED: 09/09/2025 10:18:23
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'package:flutter/material.dart';
import 'package:prostock/models/product.dart';
import 'package:prostock/models/sale_item.dart';

class TopSellingProductsList extends StatelessWidget {
  final List<Product> topProducts;
  final List<SaleItem> saleItems;

  const TopSellingProductsList({
    super.key,
    required this.topProducts,
    required this.saleItems,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Top Selling Products',
          style: TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 12),
        ListView.builder(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          itemCount: topProducts.length,
          itemBuilder: (context, index) {
            final product = topProducts[index];
            final quantitySold = _getQuantitySold(product.id!);
            return ListTile(
              leading: CircleAvatar(
                child: Text((index + 1).toString()),
              ),
              title: Text(product.name),
              trailing: Text('Sold: $quantitySold'),
            );
          },
        ),
      ],
    );
  }

  int _getQuantitySold(String productId) {
    return saleItems
        .where((item) => item.productId == productId)
        .fold(0, (sum, item) => sum + item.quantity);
  }
}



